{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/release-notes/typescript-3-5.html","result":{"data":{"markdownRemark":{"id":"206b03f8-8949-5644-bf35-c3af0ee1829c","excerpt":"Speed improvements TypeScript 3.5 introduces several optimizations around type-checking and incremental builds. Type-checking speed-ups TypeScript 3.5 contains…","html":"<h2 id=\"speed-improvements\" style=\"position:relative;\"><a href=\"#speed-improvements\" aria-label=\"speed improvements permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Speed improvements</h2>\n<p>TypeScript 3.5 introduces several optimizations around type-checking and incremental builds.</p>\n<h3 id=\"type-checking-speed-ups\" style=\"position:relative;\"><a href=\"#type-checking-speed-ups\" aria-label=\"type checking speed ups permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type-checking speed-ups</h3>\n<p>TypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently.\nThese improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.</p>\n<h3 id=\"--incremental-improvements\" style=\"position:relative;\"><a href=\"#--incremental-improvements\" aria-label=\"  incremental improvements permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>--incremental</code> improvements</h3>\n<p>TypeScript 3.5 improves on 3.4’s <code>--incremental</code> build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc.\nIn scenarios involving hundreds of projects using TypeScript’s project references in <code>--build</code> mode, <a href=\"https://github.com/Microsoft/TypeScript/pull/31101\">we’ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4</a>!</p>\n<p>For more details, you can see the pull requests to</p>\n<ul>\n<li><a href=\"https://github.com/Microsoft/TypeScript/pull/31100\">cache module resolution</a></li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/pull/31101\">cache settings calculated from <code>tsconfig.json</code></a></li>\n</ul>\n<h2 id=\"the-omit-helper-type\" style=\"position:relative;\"><a href=\"#the-omit-helper-type\" aria-label=\"the omit helper type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The <code>Omit</code> helper type</h2>\n<p>TypeScript 3.5 introduces the new <code>Omit</code> helper type, which creates a new type with some properties dropped from the original.</p>\n<pre><code class=\"language-ts\">type Person = {\n  name: string;\n  age: number;\n  location: string;\n};\n\ntype QuantumPerson = Omit&#x3C;Person, \"location\">;\n\n// equivalent to\ntype QuantumPerson = {\n  name: string;\n  age: number;\n};\n</code></pre>\n<p>Here we were able to copy over all the properties of <code>Person</code> except for <code>location</code> using the <code>Omit</code> helper.</p>\n<p>For more details, <a href=\"https://github.com/Microsoft/TypeScript/pull/30552\">see the pull request on GitHub to add <code>Omit</code></a>, as well as <a href=\"https://github.com/microsoft/TypeScript/pull/31134\">the change to use <code>Omit</code> for object rest</a>.</p>\n<h3 id=\"improved-excess-property-checks-in-union-types\" style=\"position:relative;\"><a href=\"#improved-excess-property-checks-in-union-types\" aria-label=\"improved excess property checks in union types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Improved excess property checks in union types</h3>\n<p>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn’t have been.\nFor instance, TypeScript 3.4 permitted the incorrect <code>name</code> property in the object literal even though its types don’t match between <code>Point</code> and <code>Label</code>.</p>\n<pre><code class=\"language-ts\">type Point = {\n  x: number;\n  y: number;\n};\n\ntype Label = {\n  name: string;\n};\n\nconst thing: Point | Label = {\n  x: 0,\n  y: 0,\n  name: true // uh-oh!\n};\n</code></pre>\n<p>Previously, a non-disciminated union wouldn’t have <em>any</em> excess property checking done on its members, and as a result, the incorrectly typed <code>name</code> property slipped by.</p>\n<p>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to <em>some</em> union member and have the appropriate type, meaning that the sample above correctly issues an error.</p>\n<p>Note that partial overlap is still permitted as long as the property types are valid.</p>\n<pre><code class=\"language-ts\">const pl: Point | Label = {\n  x: 0,\n  y: 0,\n  name: \"origin\" // okay\n};\n</code></pre>\n<h2 id=\"the---allowumdglobalaccess-flag\" style=\"position:relative;\"><a href=\"#the---allowumdglobalaccess-flag\" aria-label=\"the   allowumdglobalaccess flag permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The <code>--allowUmdGlobalAccess</code> flag</h2>\n<p>In TypeScript 3.5, you can now reference UMD global declarations like</p>\n<pre><code>export as namespace foo;\n</code></pre>\n<p>from anywhere - even modules - using the new <code>--allowUmdGlobalAccess</code> flag.</p>\n<p>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</p>\n<p>For more details, <a href=\"https://github.com/Microsoft/TypeScript/pull/30776/files\">see the pull request on GitHub</a>.</p>\n<h2 id=\"smarter-union-type-checking\" style=\"position:relative;\"><a href=\"#smarter-union-type-checking\" aria-label=\"smarter union type checking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Smarter union type checking</h2>\n<p>In TypeScript 3.4 and prior, the following example would fail:</p>\n<pre><code class=\"language-ts\">type S = { done: boolean; value: number };\ntype T = { done: false; value: number } | { done: true; value: number };\n\ndeclare let source: S;\ndeclare let target: T;\n\ntarget = source;\n</code></pre>\n<p>That’s because <code>S</code> isn’t assignable to <code>{ done: false, value: number }</code> nor <code>{ done: true, value: number }</code>.\nWhy?\nBecause the <code>done</code> property in <code>S</code> isn’t specific enough - it’s <code>boolean</code> whereas each constituent of <code>T</code> has a <code>done</code> property that’s specifically <code>true</code> or <code>false</code>.\nThat’s what we meant by each constituent type being checked in isolation: TypeScript doesn’t just union each property together and see if <code>S</code> is assignable to that.\nIf it did, some bad code could get through like the following:</p>\n<pre><code class=\"language-ts\">interface Foo {\n  kind: \"foo\";\n  value: string;\n}\n\ninterface Bar {\n  kind: \"bar\";\n  value: number;\n}\n\nfunction doSomething(x: Foo | Bar) {\n  if (x.kind === \"foo\") {\n    x.value.toLowerCase();\n  }\n}\n\n// uh-oh - luckily TypeScript errors here!\ndoSomething({\n  kind: \"foo\",\n  value: 123\n});\n</code></pre>\n<p>However, this was a bit overly strict for the original example.\nIf you figure out the precise type of any possible value of <code>S</code>, you can actually see that it matches the types in <code>T</code> exactly.</p>\n<p>In TypeScript 3.5, when assigning to types with discriminant properties like in <code>T</code>, the language actually <em>will</em> go further and decompose types like <code>S</code> into a union of every possible inhabitant type.\nIn this case, since <code>boolean</code> is a union of <code>true</code> and <code>false</code>, <code>S</code> will be viewed as a union of <code>{ done: false, value: number }</code> and <code>{ done: true, value: number }</code>.</p>\n<p>For more details, you can <a href=\"https://github.com/microsoft/TypeScript/pull/30779\">see the original pull request on GitHub</a>.</p>\n<h2 id=\"higher-order-type-inference-from-generic-constructors\" style=\"position:relative;\"><a href=\"#higher-order-type-inference-from-generic-constructors\" aria-label=\"higher order type inference from generic constructors permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Higher order type inference from generic constructors</h2>\n<p>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</p>\n<pre><code class=\"language-ts\">function compose&#x3C;T, U, V>(f: (x: T) => U, g: (y: U) => V): (x: T) => V {\n  return x => g(f(x));\n}\n</code></pre>\n<p>took other generic functions as arguments, like so:</p>\n<pre><code class=\"language-ts\">function arrayify&#x3C;T>(x: T): T[] {\n  return [x];\n}\n\ntype Box&#x3C;U> = { value: U };\nfunction boxify&#x3C;U>(y: U): Box&#x3C;U> {\n  return { value: y };\n}\n\nlet newFn = compose(arrayify, boxify);\n</code></pre>\n<p>Instead of a relatively useless type like <code>(x: {}) => Box&#x3C;{}[]></code>, which older versions of the language would infer, TypeScript 3.4’s inference allows <code>newFn</code> to be generic.\nIts new type is <code>&#x3C;T>(x: T) => Box&#x3C;T[]></code>.</p>\n<p>TypeScript 3.5 generalizes this behavior to work on constructor functions as well.</p>\n<pre><code class=\"language-ts\">class Box&#x3C;T> {\n  kind: \"box\";\n  value: T;\n  constructor(value: T) {\n    this.value = value;\n  }\n}\n\nclass Bag&#x3C;U> {\n  kind: \"bag\";\n  value: U;\n  constructor(value: U) {\n    this.value = value;\n  }\n}\n\nfunction composeCtor&#x3C;T, U, V>(\n  F: new (x: T) => U,\n  G: new (y: U) => V\n): (x: T) => V {\n  return x => new G(new F(x));\n}\n\nlet f = composeCtor(Box, Bag); // has type '&#x3C;T>(x: T) => Bag&#x3C;Box&#x3C;T>>'\nlet a = f(1024); // has type 'Bag&#x3C;Box&#x3C;number>>'\n</code></pre>\n<p>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</p>\n<pre><code class=\"language-ts\">type ComponentClass&#x3C;P> = new (props: P) => Component&#x3C;P>;\ndeclare class Component&#x3C;P> {\n  props: P;\n  constructor(props: P);\n}\n\ndeclare function myHoc&#x3C;P>(C: ComponentClass&#x3C;P>): ComponentClass&#x3C;P>;\n\ntype NestedProps&#x3C;T> = { foo: number; stuff: T };\n\ndeclare class GenericComponent&#x3C;T> extends Component&#x3C;NestedProps&#x3C;T>> {}\n\n// type is 'new &#x3C;T>(props: NestedProps&#x3C;T>) => Component&#x3C;NestedProps&#x3C;T>>'\nconst GenericComponent2 = myHoc(GenericComponent);\n</code></pre>\n<p>To learn more, <a href=\"https://github.com/microsoft/TypeScript/pull/31116\">check out the original pull request on GitHub</a>.</p>","headings":[{"value":"Speed improvements","depth":2},{"value":"Type-checking speed-ups","depth":3},{"value":"--incremental improvements","depth":3},{"value":"The Omit helper type","depth":2},{"value":"Improved excess property checks in union types","depth":3},{"value":"The --allowUmdGlobalAccess flag","depth":2},{"value":"Smarter union type checking","depth":2},{"value":"Higher order type inference from generic constructors","depth":2}],"frontmatter":{"permalink":"/docs/handbook/release-notes/typescript-3-5.html","title":"TypeScript 3.5","disable_toc":null,"handbook":null,"oneline":"TypeScript 3.5 Release Notes","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"4-typescript-3.5","slug":"/docs/handbook/release-notes/typescript-3-5.html","repoPath":"/packages/documentation/copy/en/release-notes/TypeScript 3.5.md","lang":"en","modifiedTime":"2021-05-31T12:14:15.540Z"}},"staticQueryHashes":[]}