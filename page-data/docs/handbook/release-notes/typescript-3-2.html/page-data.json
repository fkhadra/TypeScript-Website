{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/release-notes/typescript-3-2.html","result":{"data":{"markdownRemark":{"id":"d44207e6-af67-57ef-8ec6-57b8fa3d0d8c","excerpt":"strictBindCallApply TypeScript 3.2 introduces a new --strictBindCallApply compiler option (in the --strict family of options) with which the bind, call, and…","html":"<h2 id=\"strictbindcallapply\" style=\"position:relative;\"><a href=\"#strictbindcallapply\" aria-label=\"strictbindcallapply permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>strictBindCallApply</code></h2>\n<p>TypeScript 3.2 introduces a new <code>--strictBindCallApply</code> compiler option (in the <code>--strict</code> family of options) with which the <code>bind</code>, <code>call</code>, and <code>apply</code> methods on function objects are strongly typed and strictly checked.</p>\n<pre><code class=\"language-ts\">function foo(a: number, b: string): string {\n  return a + b;\n}\n\nlet a = foo.apply(undefined, [10]); // error: too few argumnts\nlet b = foo.apply(undefined, [10, 20]); // error: 2nd argument is a number\nlet c = foo.apply(undefined, [10, \"hello\", 30]); // error: too many arguments\nlet d = foo.apply(undefined, [10, \"hello\"]); // okay! returns a string\n</code></pre>\n<p>This is achieved by introducing two new types, <code>CallableFunction</code> and <code>NewableFunction</code>, in <code>lib.d.ts</code>. These types contain specialized generic method declarations for <code>bind</code>, <code>call</code>, and <code>apply</code> for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In <code>--strictBindCallApply</code> mode these declarations are used in place of the (very permissive) declarations provided by type <code>Function</code>.</p>\n<h2 id=\"caveats\" style=\"position:relative;\"><a href=\"#caveats\" aria-label=\"caveats permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caveats</h2>\n<p>Since the stricter checks may uncover previously unreported errors, this is a breaking change in <code>--strict</code> mode.</p>\n<p>Additionally, <a href=\"https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450\">another caveat</a> of this new functionality is that due to certain limitations, <code>bind</code>, <code>call</code>, and <code>apply</code> can’t yet fully model generic functions or functions that have overloads.\nWhen using these methods on a generic function, type parameters will be substituted with the empty object type (<code>{}</code>), and when used on a function with overloads, only the last overload will ever be modeled.</p>\n<h2 id=\"generic-spread-expressions-in-object-literals\" style=\"position:relative;\"><a href=\"#generic-spread-expressions-in-object-literals\" aria-label=\"generic spread expressions in object literals permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generic spread expressions in object literals</h2>\n<p>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the <code>Object.assign</code> function and JSX literals. For example:</p>\n<pre><code class=\"language-ts\">function taggedObject&#x3C;T, U extends string>(obj: T, tag: U) {\n  return { ...obj, tag }; // T &#x26; { tag: U }\n}\n\nlet x = taggedObject({ x: 10, y: 20 }, \"point\"); // { x: number, y: number } &#x26; { tag: \"point\" }\n</code></pre>\n<p>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</p>\n<pre><code class=\"language-ts\">function foo1&#x3C;T>(t: T, obj1: { a: string }, obj2: { b: string }) {\n  return { ...obj1, x: 1, ...t, ...obj2, y: 2 }; // { a: string, x: number } &#x26; T &#x26; { b: string, y: number }\n}\n</code></pre>\n<p>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</p>\n<pre><code class=\"language-ts\">function spread&#x3C;T, U>(t: T, u: U) {\n  return { ...t, ...u }; // T &#x26; U\n}\n\ndeclare let x: { a: string; b: number };\ndeclare let y: { b: string; c: boolean };\n\nlet s1 = { ...x, ...y }; // { a: string, b: string, c: boolean }\nlet s2 = spread(x, y); // { a: string, b: number } &#x26; { b: string, c: boolean }\nlet b1 = s1.b; // string\nlet b2 = s2.b; // number &#x26; string\n</code></pre>\n<h2 id=\"generic-object-rest-variables-and-parameters\" style=\"position:relative;\"><a href=\"#generic-object-rest-variables-and-parameters\" aria-label=\"generic object rest variables and parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generic object rest variables and parameters</h2>\n<p>TypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined <code>Pick</code> and <code>Exclude</code> helper types from <code>lib.d.ts</code>, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.</p>\n<pre><code class=\"language-ts\">function excludeTag&#x3C;T extends { tag: string }>(obj: T) {\n  let { tag, ...rest } = obj;\n  return rest; // Pick&#x3C;T, Exclude&#x3C;keyof T, \"tag\">>\n}\n\nconst taggedPoint = { x: 10, y: 20, tag: \"point\" };\nconst point = excludeTag(taggedPoint); // { x: number, y: number }\n</code></pre>\n<h2 id=\"bigint\" style=\"position:relative;\"><a href=\"#bigint\" aria-label=\"bigint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BigInt</h2>\n<p>BigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers.\nTypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting <code>esnext</code>.</p>\n<p>BigInt support in TypeScript introduces a new primitive type called the <code>bigint</code> (all lowercase).\nYou can get a <code>bigint</code> by calling the <code>BigInt()</code> function or by writing out a BigInt literal by adding an <code>n</code> to the end of any integer numeric literal:</p>\n<pre><code class=\"language-ts\">let foo: bigint = BigInt(100); // the BigInt function\nlet bar: bigint = 100n; // a BigInt literal\n\n// *Slaps roof of fibonacci function*\n// This bad boy returns ints that can get *so* big!\nfunction fibonacci(n: bigint) {\n  let result = 1n;\n  for (let last = 0n, i = 0n; i &#x3C; n; i++) {\n    const current = result;\n    result += last;\n    last = current;\n  }\n  return result;\n}\n\nfibonacci(10000n);\n</code></pre>\n<p>While you might imagine close interaction between <code>number</code> and <code>bigint</code>, the two are separate domains.</p>\n<pre><code class=\"language-ts\">declare let foo: number;\ndeclare let bar: bigint;\n\nfoo = bar; // error: Type 'bigint' is not assignable to type 'number'.\nbar = foo; // error: Type 'number' is not assignable to type 'bigint'.\n</code></pre>\n<p>As specified in ECMAScript, mixing <code>number</code>s and <code>bigint</code>s in arithmetic operations is an error.\nYou’ll have to explicitly convert values to <code>BigInt</code>s.</p>\n<pre><code class=\"language-ts\">console.log(3.141592 * 10000n); // error\nconsole.log(3145 * 10n); // error\nconsole.log(BigInt(3145) * 10n); // okay!\n</code></pre>\n<p>Also important to note is that <code>bigint</code>s produce a new string when using the <code>typeof</code> operator: the string <code>\"bigint\"</code>.\nThus, TypeScript correctly narrows using <code>typeof</code> as you’d expect.</p>\n<pre><code class=\"language-ts\">function whatKindOfNumberIsIt(x: number | bigint) {\n  if (typeof x === \"bigint\") {\n    console.log(\"'x' is a bigint!\");\n  } else {\n    console.log(\"'x' is a floating-point number\");\n  }\n}\n</code></pre>\n<p>We’d like to extend a huge thanks to <a href=\"https://github.com/calebsander\">Caleb Sander</a> for all the work on this feature.\nWe’re grateful for the contribution, and we’re sure our users are too!</p>\n<h2 id=\"caveats-1\" style=\"position:relative;\"><a href=\"#caveats-1\" aria-label=\"caveats 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caveats</h2>\n<p>As we mentioned, BigInt support is only available for the <code>esnext</code> target.\nIt may not be obvious, but because BigInts have different behavior for mathematical operators like <code>+</code>, <code>-</code>, <code>*</code>, etc., providing functionality for older targets where the feature doesn’t exist (like <code>es2017</code> and below) would involve rewriting each of these operations.\nTypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.</p>\n<p>For that reason, we have no immediate plans to provide downleveling support.\nOn the bright side, Node 11 and newer versions of Chrome already support this feature, so you’ll be able to use BigInts there when targeting <code>esnext</code>.</p>\n<p>Certain targets may include a polyfill or BigInt-like runtime object.\nFor those purposes you may want to add <code>esnext.bigint</code> to the <code>lib</code> setting in your compiler options.</p>\n<h2 id=\"non-unit-types-as-union-discriminants\" style=\"position:relative;\"><a href=\"#non-unit-types-as-union-discriminants\" aria-label=\"non unit types as union discriminants permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-unit types as union discriminants</h2>\n<p>TypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property.\nCommon properties of unions are now considered discriminants as long as they contain <em>some</em> singleton type (e.g. a string literal, <code>null</code>, or <code>undefined</code>), and they contain no generics.</p>\n<p>As a result, TypeScript 3.2 considers the <code>error</code> property in the following example to be a discriminant, whereas before it wouldn’t since <code>Error</code> isn’t a singleton type.\nThanks to this, narrowing works correctly in the body of the <code>unwrap</code> function.</p>\n<pre><code class=\"language-ts\">type Result&#x3C;T> = { error: Error; data: null } | { error: null; data: T };\n\nfunction unwrap&#x3C;T>(result: Result&#x3C;T>) {\n  if (result.error) {\n    // Here 'error' is non-null\n    throw result.error;\n  }\n\n  // Now 'data' is non-null\n  return result.data;\n}\n</code></pre>\n<h2 id=\"tsconfigjson-inheritance-via-nodejs-packages\" style=\"position:relative;\"><a href=\"#tsconfigjson-inheritance-via-nodejs-packages\" aria-label=\"tsconfigjson inheritance via nodejs packages permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>tsconfig.json</code> inheritance via Node.js packages</h2>\n<p>TypeScript 3.2 now resolves <code>tsconfig.json</code>s from <code>node_modules</code>. When using a bare path for the <code>\"extends\"</code> field in <code>tsconfig.json</code>, TypeScript will dive into <code>node_modules</code> packages for us.</p>\n<pre><code class=\"language-jsonc\" data-meta=\"tsconfig\">{\n  \"extends\": \"@my-team/tsconfig-base\",\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    // Override certain options on a project-by-project basis.\n    \"strictBindCallApply\": false\n  }\n}\n</code></pre>\n<p>Here, TypeScript will climb up <code>node_modules</code> folders looking for a <code>@my-team/tsconfig-base</code> package. For each of those packages, TypeScript will first check whether <code>package.json</code> contains a <code>\"tsconfig\"</code> field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a <code>tsconfig.json</code> at the root. This is similar to the lookup process for <code>.js</code> files in packages that Node uses, and the <code>.d.ts</code> lookup process that TypeScript already uses.</p>\n<p>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</p>\n<h2 id=\"the-new---showconfig-flag\" style=\"position:relative;\"><a href=\"#the-new---showconfig-flag\" aria-label=\"the new   showconfig flag permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The new <code>--showConfig</code> flag</h2>\n<p><code>tsc</code>, the TypeScript compiler, supports a new flag called <code>--showConfig</code>.\nWhen running <code>tsc --showConfig</code>, TypeScript will calculate the effective <code>tsconfig.json</code> (after calculating options inherited from the <code>extends</code> field) and print that out.\nThis can be useful for diagnosing configuration issues in general.</p>\n<h2 id=\"objectdefineproperty-declarations-in-javascript\" style=\"position:relative;\"><a href=\"#objectdefineproperty-declarations-in-javascript\" aria-label=\"objectdefineproperty declarations in javascript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>Object.defineProperty</code> declarations in JavaScript</h2>\n<p>When writing in JavaScript files (using <code>allowJs</code>), TypeScript now recognizes declarations that use <code>Object.defineProperty</code>.\nThis means you’ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the <code>checkJs</code> option or adding a <code>// @ts-check</code> comment to the top of your file).</p>\n<pre><code class=\"language-js\">// @ts-check\n\nlet obj = {};\nObject.defineProperty(obj, \"x\", { value: \"hello\", writable: false });\n\nobj.x.toLowercase();\n//    ~~~~~~~~~~~\n//    error:\n//     Property 'toLowercase' does not exist on type 'string'.\n//     Did you mean 'toLowerCase'?\n\nobj.x = \"world\";\n//  ~\n//  error:\n//   Cannot assign to 'x' because it is a read-only property.\n</code></pre>","headings":[{"value":"strictBindCallApply","depth":2},{"value":"Caveats","depth":2},{"value":"Generic spread expressions in object literals","depth":2},{"value":"Generic object rest variables and parameters","depth":2},{"value":"BigInt","depth":2},{"value":"Caveats","depth":2},{"value":"Non-unit types as union discriminants","depth":2},{"value":"tsconfig.json inheritance via Node.js packages","depth":2},{"value":"The new --showConfig flag","depth":2},{"value":"Object.defineProperty declarations in JavaScript","depth":2}],"frontmatter":{"permalink":"/docs/handbook/release-notes/typescript-3-2.html","title":"TypeScript 3.2","disable_toc":null,"handbook":null,"oneline":"TypeScript 3.2 Release Notes","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"4-typescript-3.2","slug":"/docs/handbook/release-notes/typescript-3-2.html","repoPath":"/packages/documentation/copy/en/release-notes/TypeScript 3.2.md","lang":"en","modifiedTime":"2021-05-31T12:14:15.540Z"}},"staticQueryHashes":[]}