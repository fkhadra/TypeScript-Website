{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/release-notes/typescript-1-4.html","result":{"data":{"markdownRemark":{"id":"d7a62ea5-62cb-5da5-beb4-baf98ba8f88d","excerpt":"Union types Overview Union types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a…","html":"<h2 id=\"union-types\" style=\"position:relative;\"><a href=\"#union-types\" aria-label=\"union types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Union types</h2>\n<h3 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h3>\n<p>Union types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a <code>string</code>, a <code>string[]</code> or a function that returns a <code>string</code>. You can now write:</p>\n<pre><code class=\"language-ts\">interface RunOptions {\n  program: string;\n  commandline: string[] | string | (() => string);\n}\n</code></pre>\n<p>Assignment to union types works very intuitively — anything you could assign to one of the union type’s members is assignable to the union:</p>\n<pre><code class=\"language-ts\">var opts: RunOptions = /* ... */;\nopts.commandline = '-hello world'; // OK\nopts.commandline = ['-hello', 'world']; // OK\nopts.commandline = [42]; // Error, number is not string or string[]\n</code></pre>\n<p>When reading from a union type, you can see any properties that are shared by them:</p>\n<pre><code class=\"language-ts\">if (opts.commandline.length === 0) {\n  // OK, string and string[] both have 'length' property\n  console.log(\"it's empty\");\n}\n</code></pre>\n<p>Using Type Guards, you can easily work with a variable of a union type:</p>\n<pre><code class=\"language-ts\">function formatCommandline(c: string | string[]) {\n  if (typeof c === \"string\") {\n    return c.trim();\n  } else {\n    return c.join(\" \");\n  }\n}\n</code></pre>\n<h3 id=\"stricter-generics\" style=\"position:relative;\"><a href=\"#stricter-generics\" aria-label=\"stricter generics permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stricter Generics</h3>\n<p>With union types able to represent a wide range of type scenarios, we’ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:</p>\n<pre><code class=\"language-ts\">function equal&#x3C;T>(lhs: T, rhs: T): boolean {\n  return lhs === rhs;\n}\n\n// Previously: No error\n// New behavior: Error, no best common type between 'string' and 'number'\nvar e = equal(42, \"hello\");\n</code></pre>\n<p>With union types, you can now specify the desired behavior at both the function declaration site and the call site:</p>\n<pre><code class=\"language-ts\">// 'choose' function where types must match\nfunction choose1&#x3C;T>(a: T, b: T): T {\n  return Math.random() > 0.5 ? a : b;\n}\nvar a = choose1(\"hello\", 42); // Error\nvar b = choose1&#x3C;string | number>(\"hello\", 42); // OK\n\n// 'choose' function where types need not match\nfunction choose2&#x3C;T, U>(a: T, b: U): T | U {\n  return Math.random() > 0.5 ? a : b;\n}\nvar c = choose2(\"bar\", \"foo\"); // OK, c: string\nvar d = choose2(\"hello\", 42); // OK, d: string|number\n</code></pre>\n<h3 id=\"better-type-inference\" style=\"position:relative;\"><a href=\"#better-type-inference\" aria-label=\"better type inference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Better Type Inference</h3>\n<p>Union types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:</p>\n<pre><code class=\"language-ts\">var x = [1, \"hello\"]; // x: Array&#x3C;string|number>\nx[0] = \"world\"; // OK\nx[0] = false; // Error, boolean is not string or number\n</code></pre>\n<h2 id=\"let-declarations\" style=\"position:relative;\"><a href=\"#let-declarations\" aria-label=\"let declarations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>let</code> declarations</h2>\n<p>In JavaScript, <code>var</code> declarations are “hoisted” to the top of their enclosing scope. This can result in confusing bugs:</p>\n<pre><code class=\"language-ts\">console.log(x); // meant to write 'y' here\n/* later in the same block */\nvar x = \"hello\";\n</code></pre>\n<p>The new ES6 keyword <code>let</code>, now supported in TypeScript, declares a variable with more intuitive “block” semantics. A <code>let</code> variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</p>\n<pre><code class=\"language-ts\">if (foo) {\n  console.log(x); // Error, cannot refer to x before its declaration\n  let x = \"hello\";\n} else {\n  console.log(x); // Error, x is not declared in this block\n}\n</code></pre>\n<p><code>let</code> is only available when targeting ECMAScript 6 (<code>--target ES6</code>).</p>\n<h2 id=\"const-declarations\" style=\"position:relative;\"><a href=\"#const-declarations\" aria-label=\"const declarations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>const</code> declarations</h2>\n<p>The other new ES6 declaration type supported in TypeScript is <code>const</code>. A <code>const</code> variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don’t want to change the value after its initialization:</p>\n<pre><code class=\"language-ts\">const halfPi = Math.PI / 2;\nhalfPi = 2; // Error, can't assign to a `const`\n</code></pre>\n<p><code>const</code> is only available when targeting ECMAScript 6 (<code>--target ES6</code>).</p>\n<h2 id=\"template-strings\" style=\"position:relative;\"><a href=\"#template-strings\" aria-label=\"template strings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Template strings</h2>\n<p>TypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:</p>\n<pre><code class=\"language-ts\">var name = \"TypeScript\";\nvar greeting = `Hello, ${name}! Your name has ${name.length} characters`;\n</code></pre>\n<p>When compiling to pre-ES6 targets, the string is decomposed:</p>\n<pre><code class=\"language-js\">var name = \"TypeScript!\";\nvar greeting =\n  \"Hello, \" + name + \"! Your name has \" + name.length + \" characters\";\n</code></pre>\n<h2 id=\"type-guards\" style=\"position:relative;\"><a href=\"#type-guards\" aria-label=\"type guards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Guards</h2>\n<p>A common pattern in JavaScript is to use <code>typeof</code> or <code>instanceof</code> to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an <code>if</code> block.</p>\n<p>Using <code>typeof</code> to test a variable:</p>\n<pre><code class=\"language-ts\">var x: any = /* ... */;\nif(typeof x === 'string') {\n    console.log(x.subtr(1)); // Error, 'subtr' does not exist on 'string'\n}\n// x is still any here\nx.unknown(); // OK\n</code></pre>\n<p>Using <code>typeof</code> with union types and <code>else</code>:</p>\n<pre><code class=\"language-ts\">var x: string | HTMLElement = /* ... */;\nif(typeof x === 'string') {\n    // x is string here, as shown above\n}\nelse {\n    // x is HTMLElement here\n    console.log(x.innerHTML);\n}\n</code></pre>\n<p>Using <code>instanceof</code> with classes and union types:</p>\n<pre><code class=\"language-ts\">class Dog { woof() { } }\nclass Cat { meow() { } }\nvar pet: Dog|Cat = /* ... */;\nif (pet instanceof Dog) {\n    pet.woof(); // OK\n}\nelse {\n    pet.woof(); // Error\n}\n</code></pre>\n<h2 id=\"type-aliases\" style=\"position:relative;\"><a href=\"#type-aliases\" aria-label=\"type aliases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Aliases</h2>\n<p>You can now define an <em>alias</em> for a type using the <code>type</code> keyword:</p>\n<pre><code class=\"language-ts\">type PrimitiveArray = Array&#x3C;string | number | boolean>;\ntype MyNumber = number;\ntype NgScope = ng.IScope;\ntype Callback = () => void;\n</code></pre>\n<p>Type aliases are exactly the same as their original types; they are simply alternative names.</p>\n<h2 id=\"const-enum-completely-inlined-enums\" style=\"position:relative;\"><a href=\"#const-enum-completely-inlined-enums\" aria-label=\"const enum completely inlined enums permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>const enum</code> (completely inlined enums)</h2>\n<p>Enums are very useful, but some programs don’t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new <code>const enum</code> declaration works just like a regular <code>enum</code> for type safety, but erases completely at compile time.</p>\n<pre><code class=\"language-ts\">const enum Suit {\n  Clubs,\n  Diamonds,\n  Hearts,\n  Spades\n}\nvar d = Suit.Diamonds;\n</code></pre>\n<p>Compiles to exactly:</p>\n<pre><code class=\"language-js\">var d = 1;\n</code></pre>\n<p>TypeScript will also now compute enum values when possible:</p>\n<pre><code class=\"language-ts\">enum MyFlags {\n  None = 0,\n  Neat = 1,\n  Cool = 2,\n  Awesome = 4,\n  Best = Neat | Cool | Awesome\n}\nvar b = MyFlags.Best; // emits var b = 7;\n</code></pre>\n<h2 id=\"-noemitonerror-commandline-option\" style=\"position:relative;\"><a href=\"#-noemitonerror-commandline-option\" aria-label=\" noemitonerror commandline option permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>-noEmitOnError</code> commandline option</h2>\n<p>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a <code>string</code> to a <code>number</code>). This can be undesirable on build servers or other scenarios where only output from a “clean” build is desired. The new flag <code>noEmitOnError</code> prevents the compiler from emitting .js code if there were any errors.</p>\n<p>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</p>\n<h2 id=\"amd-module-names\" style=\"position:relative;\"><a href=\"#amd-module-names\" aria-label=\"amd module names permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AMD Module names</h2>\n<p>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. <code>r.js</code>).</p>\n<p>The new <code>amd-module name</code> tag allows passing an optional module name to the compiler:</p>\n<pre><code class=\"language-ts\">//// [amdModule.ts]\n///&#x3C;amd-module name='NamedModule'/>\nexport class C {}\n</code></pre>\n<p>Will result in assigning the name <code>NamedModule</code> to the module as part of calling the AMD <code>define</code>:</p>\n<pre><code class=\"language-js\">//// [amdModule.js]\ndefine(\"NamedModule\", [\"require\", \"exports\"], function(require, exports) {\n  var C = (function() {\n    function C() {}\n    return C;\n  })();\n  exports.C = C;\n});\n</code></pre>","headings":[{"value":"Union types","depth":2},{"value":"Overview","depth":3},{"value":"Stricter Generics","depth":3},{"value":"Better Type Inference","depth":3},{"value":"let declarations","depth":2},{"value":"const declarations","depth":2},{"value":"Template strings","depth":2},{"value":"Type Guards","depth":2},{"value":"Type Aliases","depth":2},{"value":"const enum (completely inlined enums)","depth":2},{"value":"-noEmitOnError commandline option","depth":2},{"value":"AMD Module names","depth":2}],"frontmatter":{"permalink":"/docs/handbook/release-notes/typescript-1-4.html","title":"TypeScript 1.4","disable_toc":null,"handbook":null,"oneline":"TypeScript 1.3 Release Notes","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"4-typescript-1.4","slug":"/docs/handbook/release-notes/typescript-1-4.html","repoPath":"/packages/documentation/copy/en/release-notes/TypeScript 1.4.md","lang":"en","modifiedTime":"2021-05-31T12:14:15.536Z"}},"staticQueryHashes":[]}