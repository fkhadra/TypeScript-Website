{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/release-notes/typescript-3-4.html","result":{"data":{"markdownRemark":{"id":"845c8f00-cc66-5cce-ac4e-a7228c9e3041","excerpt":"Faster subsequent builds with the --incremental flag TypeScript 3.4 introduces a new flag called --incremental which tells TypeScript to save information about…","html":"<h2 id=\"faster-subsequent-builds-with-the---incremental-flag\" style=\"position:relative;\"><a href=\"#faster-subsequent-builds-with-the---incremental-flag\" aria-label=\"faster subsequent builds with the   incremental flag permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Faster subsequent builds with the <code>--incremental</code> flag</h2>\n<p>TypeScript 3.4 introduces a new flag called <code>--incremental</code> which tells TypeScript to save information about the project graph from the last compilation.\nThe next time TypeScript is invoked with <code>--incremental</code>, it will use that information to detect the least costly way to type-check and emit changes to your project.</p>\n<pre><code class=\"language-jsonc\" data-meta=\"tsconfig\">// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"incremental\": true,\n    \"outDir\": \"./lib\"\n  },\n  \"include\": [\"./src\"]\n}\n</code></pre>\n<p>By default with these settings, when we run <code>tsc</code>, TypeScript will look for a file called <code>.tsbuildinfo</code> in the output directory (<code>./lib</code>).\nIf <code>./lib/.tsbuildinfo</code> doesn’t exist, it’ll be generated.\nBut if it does, <code>tsc</code> will try to use that file to incrementally type-check and update our output files.</p>\n<p>These <code>.tsbuildinfo</code> files can be safely deleted and don’t have any impact on our code at runtime - they’re purely used to make compilations faster.\nWe can also name them anything that we want, and place them anywhere we want using the <code>--tsBuildInfoFile</code> flag.</p>\n<pre><code class=\"language-jsonc\" data-meta=\"tsconfig\">// front-end.tsconfig.json\n{\n  \"compilerOptions\": {\n    \"incremental\": true,\n    \"tsBuildInfoFile\": \"./buildcache/front-end\",\n    \"outDir\": \"./lib\"\n  },\n  \"include\": [\"./src\"]\n}\n</code></pre>\n<h3 id=\"composite-projects\" style=\"position:relative;\"><a href=\"#composite-projects\" aria-label=\"composite projects permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composite projects</h3>\n<p>Part of the intent with composite projects (<code>tsconfig.json</code>s with <code>composite</code> set to <code>true</code>) is that references between different projects can be built incrementally.\nAs such, composite projects will <strong>always</strong> produce <code>.tsbuildinfo</code> files.</p>\n<h3 id=\"outfile\" style=\"position:relative;\"><a href=\"#outfile\" aria-label=\"outfile permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>outFile</code></h3>\n<p>When <code>outFile</code> is used, the build information file’s name will be based on the output file’s name.\nAs an example, if our output JavaScript file is <code>./output/foo.js</code>, then under the <code>--incremental</code> flag, TypeScript will generate the file <code>./output/foo.tsbuildinfo</code>.\nAs above, this can be controlled with the <code>--tsBuildInfoFile</code> flag.</p>\n<h2 id=\"higher-order-type-inference-from-generic-functions\" style=\"position:relative;\"><a href=\"#higher-order-type-inference-from-generic-functions\" aria-label=\"higher order type inference from generic functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Higher order type inference from generic functions</h2>\n<p>TypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences.\nThis means many function composition patterns now work better in 3.4.</p>\n<p>To get more specific, let’s build up some motivation and consider the following <code>compose</code> function:</p>\n<pre><code class=\"language-ts\">function compose&#x3C;A, B, C>(f: (arg: A) => B, g: (arg: B) => C): (arg: A) => C {\n  return (x) => g(f(x));\n}\n</code></pre>\n<p><code>compose</code> takes two other functions:</p>\n<ul>\n<li><code>f</code> which takes some argument (of type <code>A</code>) and returns a value of type <code>B</code></li>\n<li><code>g</code> which takes an argument of type <code>B</code> (the type <code>f</code> returned), and returns a value of type <code>C</code></li>\n</ul>\n<p><code>compose</code> then returns a function which feeds its argument through <code>f</code> and then <code>g</code>.</p>\n<p>When calling this function, TypeScript will try to figure out the types of <code>A</code>, <code>B</code>, and <code>C</code> through a process called <em>type argument inference</em>.\nThis inference process usually works pretty well:</p>\n<pre><code class=\"language-ts\">interface Person {\n  name: string;\n  age: number;\n}\n\nfunction getDisplayName(p: Person) {\n  return p.name.toLowerCase();\n}\n\nfunction getLength(s: string) {\n  return s.length;\n}\n\n// has type '(p: Person) => number'\nconst getDisplayNameLength = compose(getDisplayName, getLength);\n\n// works and returns the type 'number'\ngetDisplayNameLength({ name: \"Person McPersonface\", age: 42 });\n</code></pre>\n<p>The inference process is fairly straightforward here because <code>getDisplayName</code> and <code>getLength</code> use types that can easily be referenced.\nHowever, in TypeScript 3.3 and earlier, generic functions like <code>compose</code> didn’t work so well when passed other generic functions.</p>\n<pre><code class=\"language-ts\">interface Box&#x3C;T> {\n  value: T;\n}\n\nfunction makeArray&#x3C;T>(x: T): T[] {\n  return [x];\n}\n\nfunction makeBox&#x3C;U>(value: U): Box&#x3C;U> {\n  return { value };\n}\n\n// has type '(arg: {}) => Box&#x3C;{}[]>'\nconst makeBoxedArray = compose(makeArray, makeBox);\n\nmakeBoxedArray(\"hello!\").value[0].toUpperCase();\n//                                ~~~~~~~~~~~\n// error: Property 'toUpperCase' does not exist on type '{}'.\n</code></pre>\n<p>In older versions, TypeScript would infer the empty object type (<code>{}</code>) when inferring from other type variables like <code>T</code> and <code>U</code>.</p>\n<p>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript <em>will</em>, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</p>\n<p>In other words, instead of producing the type</p>\n<pre><code class=\"language-ts\">(arg: {}) => Box&#x3C;{}[]>\n</code></pre>\n<p>TypeScript 3.4 produces the type</p>\n<pre><code class=\"language-ts\">&#x3C;T>(arg: T) => Box&#x3C;T[]>\n</code></pre>\n<p>Notice that <code>T</code> has been propagated from <code>makeArray</code> into the resulting type’s type parameter list.\nThis means that genericity from <code>compose</code>’s arguments has been preserved and our <code>makeBoxedArray</code> sample will just work!</p>\n<pre><code class=\"language-ts\">interface Box&#x3C;T> {\n  value: T;\n}\n\nfunction makeArray&#x3C;T>(x: T): T[] {\n  return [x];\n}\n\nfunction makeBox&#x3C;U>(value: U): Box&#x3C;U> {\n  return { value };\n}\n\n// has type '&#x3C;T>(arg: T) => Box&#x3C;T[]>'\nconst makeBoxedArray = compose(makeArray, makeBox);\n\n// works with no problem!\nmakeBoxedArray(\"hello!\").value[0].toUpperCase();\n</code></pre>\n<p>For more details, you can <a href=\"https://github.com/Microsoft/TypeScript/pull/30215\">read more at the original change</a>.</p>\n<h2 id=\"improvements-for-readonlyarray-and-readonly-tuples\" style=\"position:relative;\"><a href=\"#improvements-for-readonlyarray-and-readonly-tuples\" aria-label=\"improvements for readonlyarray and readonly tuples permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Improvements for <code>ReadonlyArray</code> and <code>readonly</code> tuples</h2>\n<p>TypeScript 3.4 makes it a little bit easier to use read-only array-like types.</p>\n<h3 id=\"a-new-syntax-for-readonlyarray\" style=\"position:relative;\"><a href=\"#a-new-syntax-for-readonlyarray\" aria-label=\"a new syntax for readonlyarray permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A new syntax for <code>ReadonlyArray</code></h3>\n<p>The <code>ReadonlyArray</code> type describes <code>Array</code>s that can only be read from.\nAny variable with a reference to a <code>ReadonlyArray</code> can’t add, remove, or replace any elements of the array.</p>\n<pre><code class=\"language-ts\">function foo(arr: ReadonlyArray&#x3C;string>) {\n  arr.slice(); // okay\n  arr.push(\"hello!\"); // error!\n}\n</code></pre>\n<p>While it’s good practice to use <code>ReadonlyArray</code> over <code>Array</code> when no mutation is intended, it’s often been a pain given that arrays have a nicer syntax.\nSpecifically, <code>number[]</code> is a shorthand version of <code>Array&#x3C;number></code>, just as <code>Date[]</code> is a shorthand for <code>Array&#x3C;Date></code>.</p>\n<p>TypeScript 3.4 introduces a new syntax for <code>ReadonlyArray</code> using a new <code>readonly</code> modifier for array types.</p>\n<pre><code class=\"language-ts\">function foo(arr: readonly string[]) {\n  arr.slice(); // okay\n  arr.push(\"hello!\"); // error!\n}\n</code></pre>\n<h3 id=\"readonly-tuples\" style=\"position:relative;\"><a href=\"#readonly-tuples\" aria-label=\"readonly tuples permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>readonly</code> tuples</h3>\n<p>TypeScript 3.4 also introduces new support for <code>readonly</code> tuples.\nWe can prefix any tuple type with the <code>readonly</code> keyword to make it a <code>readonly</code> tuple, much like we now can with array shorthand syntax.\nAs you might expect, unlike ordinary tuples whose slots could be written to, <code>readonly</code> tuples only permit reading from those positions.</p>\n<pre><code class=\"language-ts\">function foo(pair: readonly [string, string]) {\n  console.log(pair[0]); // okay\n  pair[1] = \"hello!\"; // error\n}\n</code></pre>\n<p>The same way that ordinary tuples are types that extend from <code>Array</code> - a tuple with elements of type <code>T<sub>1</sub></code>, <code>T<sub>2</sub></code>, … <code>T<sub>n</sub></code> extends from <code>Array&#x3C; T<sub>1</sub> | T<sub>2</sub> | … T<sub>n</sub> ></code> - <code>readonly</code> tuples are types that extend from <code>ReadonlyArray</code>. So a <code>readonly</code> tuple with elements <code>T<sub>1</sub></code>, <code>T<sub>2</sub></code>, … <code>T<sub>n</sub></code> extends from <code>ReadonlyArray&#x3C; T<sub>1</sub> | T<sub>2</sub> | … T<sub>n</sub></code>.</p>\n<h3 id=\"readonly-mapped-type-modifiers-and-readonly-arrays\" style=\"position:relative;\"><a href=\"#readonly-mapped-type-modifiers-and-readonly-arrays\" aria-label=\"readonly mapped type modifiers and readonly arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>readonly</code> mapped type modifiers and <code>readonly</code> arrays</h3>\n<p>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types.\nThis meant that a mapped type like <code>Boxify</code> could work on arrays and tuples alike.</p>\n<pre><code class=\"language-ts\">interface Box&#x3C;T> {\n  value: T;\n}\n\ntype Boxify&#x3C;T> = {\n  [K in keyof T]: Box&#x3C;T[K]>;\n};\n\n// { a: Box&#x3C;string>, b: Box&#x3C;number> }\ntype A = Boxify&#x3C;{ a: string; b: number }>;\n\n// Array&#x3C;Box&#x3C;number>>\ntype B = Boxify&#x3C;number[]>;\n\n// [Box&#x3C;string>, Box&#x3C;number>]\ntype C = Boxify&#x3C;[string, boolean]>;\n</code></pre>\n<p>Unfortunately, mapped types like the <code>Readonly</code> utility type were effectively no-ops on array and tuple types.</p>\n<pre><code class=\"language-ts\">// lib.d.ts\ntype Readonly&#x3C;T> = {\n  readonly [K in keyof T]: T[K];\n};\n\n// How code acted *before* TypeScript 3.4\n\n// { readonly a: string, readonly b: number }\ntype A = Readonly&#x3C;{ a: string; b: number }>;\n\n// number[]\ntype B = Readonly&#x3C;number[]>;\n\n// [string, boolean]\ntype C = Readonly&#x3C;[string, boolean]>;\n</code></pre>\n<p>In TypeScript 3.4, the <code>readonly</code> modifier in a mapped type will automatically convert array-like types to their corresponding <code>readonly</code> counterparts.</p>\n<pre><code class=\"language-ts\">// How code acts now *with* TypeScript 3.4\n\n// { readonly a: string, readonly b: number }\ntype A = Readonly&#x3C;{ a: string; b: number }>;\n\n// readonly number[]\ntype B = Readonly&#x3C;number[]>;\n\n// readonly [string, boolean]\ntype C = Readonly&#x3C;[string, boolean]>;\n</code></pre>\n<p>Similarly, you could write a utility type like <code>Writable</code> mapped type that strips away <code>readonly</code>-ness, and that would convert <code>readonly</code> array containers back to their mutable equivalents.</p>\n<pre><code class=\"language-ts\">type Writable&#x3C;T> = {\n  -readonly [K in keyof T]: T[K];\n};\n\n// { a: string, b: number }\ntype A = Writable&#x3C;{\n  readonly a: string;\n  readonly b: number;\n}>;\n\n// number[]\ntype B = Writable&#x3C;readonly number[]>;\n\n// [string, boolean]\ntype C = Writable&#x3C;readonly [string, boolean]>;\n</code></pre>\n<h3 id=\"caveats\" style=\"position:relative;\"><a href=\"#caveats\" aria-label=\"caveats permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caveats</h3>\n<p>Despite its appearance, the <code>readonly</code> type modifier can only be used for syntax on array types and tuple types.\nIt is not a general-purpose type operator.</p>\n<pre><code class=\"language-ts\">let err1: readonly Set&#x3C;number>; // error!\nlet err2: readonly Array&#x3C;boolean>; // error!\n\nlet okay: readonly boolean[]; // works fine\n</code></pre>\n<p>You can <a href=\"https://github.com/Microsoft/TypeScript/pull/29435\">see more details in the pull request</a>.</p>\n<h2 id=\"const-assertions\" style=\"position:relative;\"><a href=\"#const-assertions\" aria-label=\"const assertions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>const</code> assertions</h2>\n<p>TypeScript 3.4 introduces a new construct for literal values called <em><code>const</code></em> assertions.\nIts syntax is a type assertion with <code>const</code> in place of the type name (e.g. <code>123 as const</code>).\nWhen we construct new literal expressions with <code>const</code> assertions, we can signal to the language that</p>\n<ul>\n<li>no literal types in that expression should be widened (e.g. no going from <code>\"hello\"</code> to <code>string</code>)</li>\n<li>object literals get <code>readonly</code> properties</li>\n<li>array literals become <code>readonly</code> tuples</li>\n</ul>\n<pre><code class=\"language-ts\">// Type '\"hello\"'\nlet x = \"hello\" as const;\n\n// Type 'readonly [10, 20]'\nlet y = [10, 20] as const;\n\n// Type '{ readonly text: \"hello\" }'\nlet z = { text: \"hello\" } as const;\n</code></pre>\n<p>Outside of <code>.tsx</code> files, the angle bracket assertion syntax can also be used.</p>\n<pre><code class=\"language-ts\">// Type '\"hello\"'\nlet x = &#x3C;const>\"hello\";\n\n// Type 'readonly [10, 20]'\nlet y = &#x3C;const>[10, 20];\n\n// Type '{ readonly text: \"hello\" }'\nlet z = &#x3C;const>{ text: \"hello\" };\n</code></pre>\n<p>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</p>\n<pre><code class=\"language-ts\">// Works with no types referenced or declared.\n// We only needed a single const assertion.\nfunction getShapes() {\n  let result = [\n    { kind: \"circle\", radius: 100 },\n    { kind: \"square\", sideLength: 50 },\n  ] as const;\n\n  return result;\n}\n\nfor (const shape of getShapes()) {\n  // Narrows perfectly!\n  if (shape.kind === \"circle\") {\n    console.log(\"Circle radius\", shape.radius);\n  } else {\n    console.log(\"Square side length\", shape.sideLength);\n  }\n}\n</code></pre>\n<p>Notice the above needed no type annotations.\nThe <code>const</code> assertion allowed TypeScript to take the most specific type of the expression.</p>\n<p>This can even be used to enable <code>enum</code>-like patterns in plain JavaScript code if you choose not to use TypeScript’s <code>enum</code> construct.</p>\n<pre><code class=\"language-ts\">export const Colors = {\n  red: \"RED\",\n  blue: \"BLUE\",\n  green: \"GREEN\",\n} as const;\n\n// or use an 'export default'\n\nexport default {\n  red: \"RED\",\n  blue: \"BLUE\",\n  green: \"GREEN\",\n} as const;\n</code></pre>\n<h3 id=\"caveats-1\" style=\"position:relative;\"><a href=\"#caveats-1\" aria-label=\"caveats 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Caveats</h3>\n<p>One thing to note is that <code>const</code> assertions can only be applied immediately on simple literal expressions.</p>\n<pre><code class=\"language-ts\">// Error! A 'const' assertion can only be applied to a\n// to a string, number, boolean, array, or object literal.\nlet a = (Math.random() &#x3C; 0.5 ? 0 : 1) as const;\nlet b = (60 * 60 * 1000) as const;\n\n// Works!\nlet c = Math.random() &#x3C; 0.5 ? (0 as const) : (1 as const);\nlet d = 3_600_000 as const;\n</code></pre>\n<p>Another thing to keep in mind is that <code>const</code> contexts don’t immediately convert an expression to be fully immutable.</p>\n<pre><code class=\"language-ts\">let arr = [1, 2, 3, 4];\n\nlet foo = {\n  name: \"foo\",\n  contents: arr,\n} as const;\n\nfoo.name = \"bar\"; // error!\nfoo.contents = []; // error!\n\nfoo.contents.push(5); // ...works!\n</code></pre>\n<p>For more details, you can <a href=\"https://github.com/Microsoft/TypeScript/pull/29510\">check out the respective pull request</a>.</p>\n<h2 id=\"type-checking-for-globalthis\" style=\"position:relative;\"><a href=\"#type-checking-for-globalthis\" aria-label=\"type checking for globalthis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type-checking for <code>globalThis</code></h2>\n<p>TypeScript 3.4 introduces support for type-checking ECMAScript’s new <code>globalThis</code> - a global variable that, well, refers to the global scope.\nUnlike the above solutions, <code>globalThis</code> provides a standard way for accessing the global scope which can be used across different environments.</p>\n<pre><code class=\"language-ts\">// in a global file:\n\nvar abc = 100;\n\n// Refers to 'abc' from above.\nglobalThis.abc = 200;\n</code></pre>\n<p>Note that global variables declared with <code>let</code> and <code>const</code> don’t show up on <code>globalThis</code>.</p>\n<pre><code class=\"language-ts\">let answer = 42;\n\n// error! Property 'answer' does not exist on 'typeof globalThis'.\nglobalThis.answer = 333333;\n</code></pre>\n<p>It’s also important to note that TypeScript doesn’t transform references to <code>globalThis</code> when compiling to older versions of ECMAScript.\nAs such, unless you’re targeting evergreen browsers (which already support <code>globalThis</code>), you may want to <a href=\"https://github.com/ljharb/globalThis\">use an appropriate polyfill</a> instead.</p>\n<p>For more details on the implementation, see <a href=\"https://github.com/Microsoft/TypeScript/pull/29332\">the feature’s pull request</a>.</p>","headings":[{"value":"Faster subsequent builds with the --incremental flag","depth":2},{"value":"Composite projects","depth":3},{"value":"outFile","depth":3},{"value":"Higher order type inference from generic functions","depth":2},{"value":"Improvements for ReadonlyArray and readonly tuples","depth":2},{"value":"A new syntax for ReadonlyArray","depth":3},{"value":"readonly tuples","depth":3},{"value":"readonly mapped type modifiers and readonly arrays","depth":3},{"value":"Caveats","depth":3},{"value":"const assertions","depth":2},{"value":"Caveats","depth":3},{"value":"Type-checking for globalThis","depth":2}],"frontmatter":{"permalink":"/docs/handbook/release-notes/typescript-3-4.html","title":"TypeScript 3.4","disable_toc":null,"handbook":null,"oneline":"TypeScript 3.4 Release Notes","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"4-typescript-3.4","slug":"/docs/handbook/release-notes/typescript-3-4.html","repoPath":"/packages/documentation/copy/en/release-notes/TypeScript 3.4.md","lang":"en","modifiedTime":"2021-05-31T12:14:15.540Z"}},"staticQueryHashes":[]}