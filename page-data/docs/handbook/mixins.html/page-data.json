{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/mixins.html","result":{"data":{"markdownRemark":{"id":"7a8e029c-1307-523c-ad51-d1e3ad991983","excerpt":"Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes…","html":"<p>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes.\nYou may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</p>\n<h2 id=\"how-does-a-mixin-work\" style=\"position:relative;\"><a href=\"#how-does-a-mixin-work\" aria-label=\"how does a mixin work permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How Does A Mixin Work?</h2>\n<p>The pattern relies on using Generics with class inheritance to extend a base class.\nTypeScript’s best mixin support is done via the class expression pattern.\nYou can read more about how this pattern works in <a href=\"https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\">JavaScript here</a>.</p>\n<p>To get started, we’ll need a class which will have the mixin’s applied on top of:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">class Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n</code></pre>\n<p>Then you need a type and a factory function which returns a class expression extending the base class.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// To get started, we need a type which we'll use to extend\n// other classes from. The main responsibility is to declare\n// that the type being passed in is a class.\n\ntype Constructor = new (...args: any[]) => {};\n\n// This mixin adds a scale property, with getters and setters\n// for changing it with an encapsulated private property:\n\nfunction Scale&#x3C;TBase extends Constructor>(Base: TBase) {\n  return class Scaling extends Base {\n    // Mixins may not declare private/protected properties\n    // however, you can use ES2020 private fields\n    _scale = 1;\n\n    setScale(scale: number) {\n      this._scale = scale;\n    }\n\n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\n</code></pre>\n<p>With these all set up, then you can create a class which represents the base class with mixins applied:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">class Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\ntype Constructor = new (...args: any[]) => {};\nfunction Scale&#x3C;TBase extends Constructor>(Base: TBase) {\n  return class Scaling extends Base {\n    // Mixins may not declare private/protected properties\n    // however, you can use ES2020 private fields\n    _scale = 1;\n\n    setScale(scale: number) {\n      this._scale = scale;\n    }\n\n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\n// ---cut---\n// Compose a new class from the Sprite class,\n// with the Mixin Scale applier:\nconst EightBitSprite = Scale(Sprite);\n\nconst flappySprite = new EightBitSprite(\"Bird\");\nflappySprite.setScale(0.8);\nconsole.log(flappySprite.scale);\n</code></pre>\n<h2 id=\"constrained-mixins\" style=\"position:relative;\"><a href=\"#constrained-mixins\" aria-label=\"constrained mixins permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Constrained Mixins</h2>\n<p>In the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want.</p>\n<p>To model this, we modify the original constructor type to accept a generic argument.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// This was our previous constructor:\ntype Constructor = new (...args: any[]) => {};\n// Now we use a generic version which can apply a constraint on\n// the class which this mixin is applied to\ntype GConstructor&#x3C;T = {}> = new (...args: any[]) => T;\n</code></pre>\n<p>This allows for creating classes which only work with constrained base classes:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type GConstructor&#x3C;T = {}> = new (...args: any[]) => T;\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n// ---cut---\ntype Positionable = GConstructor&#x3C;{ setPos: (x: number, y: number) => void }>;\ntype Spritable = GConstructor&#x3C;typeof Sprite>;\ntype Loggable = GConstructor&#x3C;{ print: () => void }>;\n</code></pre>\n<p>Then you can create mixins which only work when you have a particular base to build on:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type GConstructor&#x3C;T = {}> = new (...args: any[]) => T;\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\ntype Positionable = GConstructor&#x3C;{ setPos: (x: number, y: number) => void }>;\ntype Spritable = GConstructor&#x3C;typeof Sprite>;\ntype Loggable = GConstructor&#x3C;{ print: () => void }>;\n// ---cut---\n\nfunction Jumpable&#x3C;TBase extends Positionable>(Base: TBase) {\n  return class Jumpable extends Base {\n    jump() {\n      // This mixin will only work if it is passed a base\n      // class which has setPos defined because of the\n      // Positionable constraint.\n      this.setPos(0, 20);\n    }\n  };\n}\n</code></pre>\n<h2 id=\"alternative-pattern\" style=\"position:relative;\"><a href=\"#alternative-pattern\" aria-label=\"alternative pattern permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Alternative Pattern</h2>\n<p>Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @strict: false\n// Each mixin is a traditional ES class\nclass Jumpable {\n  jump() {}\n}\n\nclass Duckable {\n  duck() {}\n}\n\n// Including the base\nclass Sprite {\n  x = 0;\n  y = 0;\n}\n\n// Then you create an interface which merges\n// the expected mixins with the same name as your base\ninterface Sprite extends Jumpable, Duckable {}\n// Apply the mixins into the base class via\n// the JS at runtime\napplyMixins(Sprite, [Jumpable, Duckable]);\n\nlet player = new Sprite();\nplayer.jump();\nconsole.log(player.x, player.y);\n\n// This can live anywhere in your codebase:\nfunction applyMixins(derivedCtor: any, constructors: any[]) {\n  constructors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||\n          Object.create(null)\n      );\n    });\n  });\n}\n</code></pre>\n<p>This pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync.</p>\n<h2 id=\"constraints\" style=\"position:relative;\"><a href=\"#constraints\" aria-label=\"constraints permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Constraints</h2>\n<p>The mixin pattern is supported natively inside the TypeScript compiler by code flow analysis.\nThere are a few cases where you can hit the edges of the native support.</p>\n<h4 id=\"decorators-and-mixins-4881\" style=\"position:relative;\"><a href=\"#decorators-and-mixins-4881\" aria-label=\"decorators and mixins 4881 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decorators and Mixins <a href=\"https://github.com/microsoft/TypeScript/issues/4881\"><code>#4881</code></a></h4>\n<p>You cannot use decorators to provide mixins via code flow analysis:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\n// @errors: 2339\n// A decorator function which replicates the mixin pattern:\nconst Pausable = (target: typeof Player) => {\n  return class Pausable extends target {\n    shouldFreeze = false;\n  };\n};\n\n@Pausable\nclass Player {\n  x = 0;\n  y = 0;\n}\n\n// The Player class does not have the decorator's type merged:\nconst player = new Player();\nplayer.shouldFreeze;\n\n// It the runtime aspect could be manually replicated via\n// type composition or interface merging.\ntype FreezablePlayer = Player &#x26; { shouldFreeze: boolean };\n\nconst playerTwo = (new Player() as unknown) as FreezablePlayer;\nplayerTwo.shouldFreeze;\n</code></pre>\n<h4 id=\"static-property-mixins-17829\" style=\"position:relative;\"><a href=\"#static-property-mixins-17829\" aria-label=\"static property mixins 17829 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static Property Mixins <a href=\"https://github.com/microsoft/TypeScript/issues/17829\"><code>#17829</code></a></h4>\n<p>More of a gotcha than a constraint.\nThe class expression pattern creates singletons, so they can’t be mapped at the type system to support different variable types.</p>\n<p>You can work around this by using functions to return your classes which differ based on a generic:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function base&#x3C;T>() {\n  class Base {\n    static prop: T;\n  }\n  return Base;\n}\n\nfunction derived&#x3C;T>() {\n  class Derived extends base&#x3C;T>() {\n    static anotherProp: T;\n  }\n  return Derived;\n}\n\nclass Spec extends derived&#x3C;string>() {}\n\nSpec.prop; // string\nSpec.anotherProp; // string\n</code></pre>","headings":[{"value":"How Does A Mixin Work?","depth":2},{"value":"Constrained Mixins","depth":2},{"value":"Alternative Pattern","depth":2},{"value":"Constraints","depth":2},{"value":"Decorators and Mixins #4881","depth":4},{"value":"Static Property Mixins #17829","depth":4}],"frontmatter":{"permalink":"/docs/handbook/mixins.html","title":"Mixins","disable_toc":null,"handbook":null,"oneline":"Using the mixin pattern with TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-mixins","slug":"/docs/handbook/mixins.html","repoPath":"/packages/documentation/copy/en/reference/Mixins.md","lang":"en","modifiedTime":"2021-05-31T12:14:15.532Z"}},"staticQueryHashes":[]}