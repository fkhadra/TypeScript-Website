{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/advanced-types.html","result":{"data":{"markdownRemark":{"id":"84d53932-375e-5f7d-8d32-b83c1b7b22d4","excerpt":"This page lists some of the more advanced ways in which you can model types, it works in tandem with the Utility Types doc which includes types which are…","html":"<p>This page lists some of the more advanced ways in which you can model types, it works in tandem with the <a href=\"/docs/handbook/utility-types.html\">Utility Types</a> doc which includes types which are included in TypeScript and available globally.</p>\n<h2 id=\"type-guards-and-differentiating-types\" style=\"position:relative;\"><a href=\"#type-guards-and-differentiating-types\" aria-label=\"type guards and differentiating types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Guards and Differentiating Types</h2>\n<p>Union types are useful for modeling situations when values can overlap in the types they can take on.\nWhat happens when we need to know specifically whether we have a <code>Fish</code>?\nA common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member.\nAs we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2339\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ndeclare function getSmallPet(): Fish | Bird;\n// ---cut---\nlet pet = getSmallPet();\n\n// You can use the 'in' operator to check\nif (\"swim\" in pet) {\n  pet.swim();\n}\n// However, you cannot use property access\nif (pet.fly) {\n  pet.fly();\n}\n</code></pre>\n<p>To get the same code working via property accessors, we’ll need to use a type assertion:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ndeclare function getSmallPet(): Fish | Bird;\n// ---cut---\nlet pet = getSmallPet();\nlet fishPet = pet as Fish;\nlet birdPet = pet as Bird;\n\nif (fishPet.swim) {\n  fishPet.swim();\n} else if (birdPet.fly) {\n  birdPet.fly();\n}\n</code></pre>\n<p>This isn’t the sort of code you would want in your codebase however.</p>\n<h2 id=\"user-defined-type-guards\" style=\"position:relative;\"><a href=\"#user-defined-type-guards\" aria-label=\"user defined type guards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>User-Defined Type Guards</h2>\n<p>It would be much better if once we performed the check, we could know the type of <code>pet</code> within each branch.</p>\n<p>It just so happens that TypeScript has something called a <em>type guard</em>.\nA type guard is some expression that performs a runtime check that guarantees the type in some scope.</p>\n<h3 id=\"using-type-predicates\" style=\"position:relative;\"><a href=\"#using-type-predicates\" aria-label=\"using type predicates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using type predicates</h3>\n<p>To define a type guard, we simply need to define a function whose return type is a <em>type predicate</em>:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ndeclare function getSmallPet(): Fish | Bird;\n// ---cut---\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n</code></pre>\n<p><code>pet is Fish</code> is our type predicate in this example.\nA predicate takes the form <code>parameterName is Type</code>, where <code>parameterName</code> must be the name of a parameter from the current function signature.</p>\n<p>Any time <code>isFish</code> is called with some variable, TypeScript will <em>narrow</em> that variable to that specific type if the original type is compatible.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ndeclare function getSmallPet(): Fish | Bird;\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n// ---cut---\n// Both calls to 'swim' and 'fly' are now okay.\nlet pet = getSmallPet();\n\nif (isFish(pet)) {\n  pet.swim();\n} else {\n  pet.fly();\n}\n</code></pre>\n<p>Notice that TypeScript not only knows that <code>pet</code> is a <code>Fish</code> in the <code>if</code> branch;\nit also knows that in the <code>else</code> branch, you <em>don’t</em> have a <code>Fish</code>, so you must have a <code>Bird</code>.</p>\n<p>You may use the type guard <code>isFish</code> to filter an array of <code>Fish | Bird</code> and obtain an array of <code>Fish</code>:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2345\ntype Fish = { swim: () => void };\ntype Bird = { fly: () => void };\ndeclare function getSmallPet(): Fish | Bird;\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n// ---cut---\nconst zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];\nconst underWater1: Fish[] = zoo.filter(isFish);\n// or, equivalently\nconst underWater2: Fish[] = zoo.filter&#x3C;Fish>(isFish);\nconst underWater3: Fish[] = zoo.filter&#x3C;Fish>((pet) => isFish(pet));\n</code></pre>\n<h3 id=\"using-the-in-operator\" style=\"position:relative;\"><a href=\"#using-the-in-operator\" aria-label=\"using the in operator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using the <code>in</code> operator</h3>\n<p>The <code>in</code> operator also acts as a narrowing expression for types.</p>\n<p>For a <code>n in x</code> expression, where <code>n</code> is a string literal or string literal type and <code>x</code> is a union type, the “true” branch narrows to types which have an optional or required property <code>n</code>, and the “false” branch narrows to types which have an optional or missing property <code>n</code>.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Fish = { swim: () => void };\ntype Bird = { fly: () => void };\n// ---cut---\nfunction move(pet: Fish | Bird) {\n  if (\"swim\" in pet) {\n    return pet.swim();\n  }\n  return pet.fly();\n}\n</code></pre>\n<h2 id=\"typeof-type-guards\" style=\"position:relative;\"><a href=\"#typeof-type-guards\" aria-label=\"typeof type guards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>typeof</code> type guards</h2>\n<p>Let’s go back and write the code for a version of <code>padLeft</code> which uses union types.\nWe could write it with type predicates as follows:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function isNumber(x: any): x is number {\n  return typeof x === \"number\";\n}\n\nfunction isString(x: any): x is string {\n  return typeof x === \"string\";\n}\n\nfunction padLeft(value: string, padding: string | number) {\n  if (isNumber(padding)) {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  if (isString(padding)) {\n    return padding + value;\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`);\n}\n</code></pre>\n<p>However, having to define a function to figure out if a type is a primitive is kind of a pain.\nLuckily, you don’t need to abstract <code>typeof x === \"number\"</code> into its own function because TypeScript will recognize it as a type guard on its own.\nThat means we could just write these checks inline.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function padLeft(value: string, padding: string | number) {\n  if (typeof padding === \"number\") {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  if (typeof padding === \"string\") {\n    return padding + value;\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`);\n}\n</code></pre>\n<p>These <em><code>typeof</code> type guards</em> are recognized in two different forms: <code>typeof v === \"typename\"</code> and <code>typeof v !== \"typename\"</code>, where <code>\"typename\"</code> can be one of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Description\"><code>typeof</code> operator’s return values</a> (<code>\"undefined\"</code>, <code>\"number\"</code>, <code>\"string\"</code>, <code>\"boolean\"</code>, <code>\"bigint\"</code>, <code>\"symbol\"</code>, <code>\"object\"</code>, or <code>\"function\"</code>).\nWhile TypeScript won’t stop you from comparing to other strings, the language won’t recognize those expressions as type guards.</p>\n<h2 id=\"instanceof-type-guards\" style=\"position:relative;\"><a href=\"#instanceof-type-guards\" aria-label=\"instanceof type guards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>instanceof</code> type guards</h2>\n<p>If you’ve read about <code>typeof</code> type guards and are familiar with the <code>instanceof</code> operator in JavaScript, you probably have some idea of what this section is about.</p>\n<p><em><code>instanceof</code> type guards</em> are a way of narrowing types using their constructor function.\nFor instance, let’s borrow our industrial strength string-padder example from earlier:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">interface Padder {\n  getPaddingString(): string;\n}\n\nclass SpaceRepeatingPadder implements Padder {\n  constructor(private numSpaces: number) {}\n  getPaddingString() {\n    return Array(this.numSpaces + 1).join(\" \");\n  }\n}\n\nclass StringPadder implements Padder {\n  constructor(private value: string) {}\n  getPaddingString() {\n    return this.value;\n  }\n}\n\nfunction getRandomPadder() {\n  return Math.random() &#x3C; 0.5\n    ? new SpaceRepeatingPadder(4)\n    : new StringPadder(\"  \");\n}\n\nlet padder: Padder = getRandomPadder();\n//       ^?\n\nif (padder instanceof SpaceRepeatingPadder) {\n  padder;\n  //   ^?\n}\nif (padder instanceof StringPadder) {\n  padder;\n  //   ^?\n}\n</code></pre>\n<p>The right side of the <code>instanceof</code> needs to be a constructor function, and TypeScript will narrow down to:</p>\n<ol>\n<li>the type of the function’s <code>prototype</code> property if its type is not <code>any</code></li>\n<li>the union of types returned by that type’s construct signatures</li>\n</ol>\n<p>in that order.</p>\n<h2 id=\"nullable-types\" style=\"position:relative;\"><a href=\"#nullable-types\" aria-label=\"nullable types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nullable types</h2>\n<p>TypeScript has two special types, <code>null</code> and <code>undefined</code>, that have the values null and undefined respectively.\nWe mentioned these briefly in <a href=\"/docs/handbook/basic-types.html\">the Basic Types section</a>.</p>\n<p>By default, the type checker considers <code>null</code> and <code>undefined</code> assignable to anything.\nEffectively, <code>null</code> and <code>undefined</code> are valid values of every type.\nThat means it’s not possible to <em>stop</em> them from being assigned to any type, even when you would like to prevent it.\nThe inventor of <code>null</code>, Tony Hoare, calls this his <a href=\"https://wikipedia.org/wiki/Null_pointer#History\">“billion dollar mistake”</a>.</p>\n<p>The <a href=\"/tsconfig#strictNullChecks\"><code>--strictNullChecks</code></a> flag fixes this: when you declare a variable, it doesn’t automatically include <code>null</code> or <code>undefined</code>.\nYou can include them explicitly using a union type:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2322\nlet exampleString = \"foo\";\nexampleString = null;\n\nlet stringOrNull: string | null = \"bar\";\nstringOrNull = null;\n\nstringOrNull = undefined;\n</code></pre>\n<p>Note that TypeScript treats <code>null</code> and <code>undefined</code> differently in order to match JavaScript semantics.\n<code>string | null</code> is a different type than <code>string | undefined</code> and <code>string | undefined | null</code>.</p>\n<p>From TypeScript 3.7 and onwards, you can use <a href=\"/docs/handbook/release-notes/typescript-3-7.html#optional-chaining\">optional chaining</a> to simplify working with nullable types.</p>\n<h3 id=\"optional-parameters-and-properties\" style=\"position:relative;\"><a href=\"#optional-parameters-and-properties\" aria-label=\"optional parameters and properties permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optional parameters and properties</h3>\n<p>With <a href=\"/tsconfig#strictNullChecks\"><code>--strictNullChecks</code></a>, an optional parameter automatically adds <code>| undefined</code>:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2345\nfunction f(x: number, y?: number) {\n  return x + (y ?? 0);\n}\n\nf(1, 2);\nf(1);\nf(1, undefined);\nf(1, null);\n</code></pre>\n<p>The same is true for optional properties:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @strict: false\n// @strictNullChecks: true\n// @errors: 2322\nclass C {\n  a: number;\n  b?: number;\n}\n\nlet c = new C();\n\nc.a = 12;\nc.a = undefined;\nc.b = 13;\nc.b = undefined;\nc.b = null;\n</code></pre>\n<h3 id=\"type-guards-and-type-assertions\" style=\"position:relative;\"><a href=\"#type-guards-and-type-assertions\" aria-label=\"type guards and type assertions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type guards and type assertions</h3>\n<p>Since nullable types are implemented with a union, you need to use a type guard to get rid of the <code>null</code>.\nFortunately, this is the same code you’d write in JavaScript:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function f(stringOrNull: string | null): string {\n  if (stringOrNull === null) {\n    return \"default\";\n  } else {\n    return stringOrNull;\n  }\n}\n</code></pre>\n<p>The <code>null</code> elimination is pretty obvious here, but you can use terser operators too:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function f(stringOrNull: string | null): string {\n  return stringOrNull ?? \"default\";\n}\n</code></pre>\n<p>In cases where the compiler can’t eliminate <code>null</code> or <code>undefined</code>, you can use the type assertion operator to manually remove them.\nThe syntax is postfix <code>!</code>: <code>identifier!</code> removes <code>null</code> and <code>undefined</code> from the type of <code>identifier</code>:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2532\nfunction getUser(id: string): UserAccount | undefined {\n  return {} as any;\n}\n// ---cut---\ninterface UserAccount {\n  id: number;\n  email?: string;\n}\n\nconst user = getUser(\"admin\");\nuser.id;\n\nif (user) {\n  user.email.length;\n}\n\n// Instead if you are sure that these objects or fields exist, the\n// postfix ! lets you short circuit the nullability\nuser!.email!.length;\n</code></pre>\n<h2 id=\"type-aliases\" style=\"position:relative;\"><a href=\"#type-aliases\" aria-label=\"type aliases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Aliases</h2>\n<p>Type aliases create a new name for a type.\nType aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Second = number;\n\nlet timeInSecond: number = 10;\nlet time: Second = 10;\n</code></pre>\n<p>Aliasing doesn’t actually create a new type - it creates a new <em>name</em> to refer to that type.\nAliasing a primitive is not terribly useful, though it can be used as a form of documentation.</p>\n<p>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</p>\n<pre><code class=\"language-ts\">type Container&#x3C;T> = { value: T };\n</code></pre>\n<p>We can also have a type alias refer to itself in a property:</p>\n<pre><code class=\"language-ts\">type Tree&#x3C;T> = {\n  value: T;\n  left?: Tree&#x3C;T>;\n  right?: Tree&#x3C;T>;\n};\n</code></pre>\n<p>Together with <a href=\"/docs/handbook/unions-and-intersections.html\">intersection</a> types, we can make some pretty mind-bending types:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare function getDriversLicenseQueue(): LinkedList&#x3C;Person>;\n// ---cut---\ntype LinkedList&#x3C;Type> = Type &#x26; { next: LinkedList&#x3C;Type> };\n\ninterface Person {\n  name: string;\n}\n\nlet people = getDriversLicenseQueue();\npeople.name;\npeople.next.name;\npeople.next.next.name;\npeople.next.next.next.name;\n//                  ^?\n</code></pre>\n<h2 id=\"interfaces-vs-type-aliases\" style=\"position:relative;\"><a href=\"#interfaces-vs-type-aliases\" aria-label=\"interfaces vs type aliases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interfaces vs. Type Aliases</h2>\n<p>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</p>\n<p>Almost all features of an <code>interface</code> are available in <code>type</code>, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</p>\n<table class='full-width-table'>\n  <tbody>\n    <tr>\n      <th><code>Interface</code></th>\n      <th><code>Type</code></th>\n    </tr>\n    <tr>\n      <td>\n        <p>Extending an interface</p>\n        <code><pre>\ninterface Animal {\n  name: string\n}<br/>\ninterface Bear extends Animal {\n  honey: boolean\n}<br/>\nconst bear = getBear() \nbear.name\nbear.honey\n        </pre></code>\n      </td>\n      <td>\n        <p>Extending a type via intersections</p>\n        <code><pre>\ntype Animal = {\n  name: string\n}<br/>\ntype Bear = Animal & { \n  honey: Boolean \n}<br/>\nconst bear = getBear();\nbear.name;\nbear.honey;\n        </pre></code>\n      </td>\n    </tr>\n    <tr>\n      <td>\n        <p>Adding new fields to an existing interface</p>\n        <code><pre>\ninterface Window {\n  title: string\n}<br/>\ninterface Window {\n  ts: import(\"typescript\")\n}<br/>\nconst src = 'const a = \"Hello World\"';\nwindow.ts.transpileModule(src, {});\n        </pre></code>\n      </td>\n      <td>\n        <p>A type cannot be changed after being created</p>\n        <code><pre>\ntype Window = {\n  title: string\n}<br/>\ntype Window = {\n  ts: import(\"typescript\")\n}<br/>\n// Error: Duplicate identifier 'Window'.<br/>\n        </pre></code>\n      </td>\n    </tr>\n    </tbody>\n</table>\n<p>Because an interface more closely maps how JavaScript objects work <a href=\"https://wikipedia.org/wiki/Open/closed_principle\">by being open to extension</a>, we recommend using an interface over a type alias when possible.</p>\n<p>On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</p>\n<h2 id=\"enum-member-types\" style=\"position:relative;\"><a href=\"#enum-member-types\" aria-label=\"enum member types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Enum Member Types</h2>\n<p>As mentioned in <a href=\"./enums.html#union-enums-and-enum-member-types\">our section on enums</a>, enum members have types when every member is literal-initialized.</p>\n<p>Much of the time when we talk about “singleton types”, we’re referring to both enum member types as well as numeric/string literal types, though many users will use “singleton types” and “literal types” interchangeably.</p>\n<h2 id=\"polymorphic-this-types\" style=\"position:relative;\"><a href=\"#polymorphic-this-types\" aria-label=\"polymorphic this types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Polymorphic <code>this</code> types</h2>\n<p>A polymorphic <code>this</code> type represents a type that is the <em>subtype</em> of the containing class or interface.\nThis is called <em>F</em>-bounded polymorphism, a lot of people know it as the <a href=\"https://en.wikipedia.org/wiki/Fluent_interface\">fluent API</a> pattern.\nThis makes hierarchical fluent interfaces much easier to express, for example.\nTake a simple calculator that returns <code>this</code> after each operation:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">class BasicCalculator {\n  public constructor(protected value: number = 0) {}\n  public currentValue(): number {\n    return this.value;\n  }\n  public add(operand: number): this {\n    this.value += operand;\n    return this;\n  }\n  public multiply(operand: number): this {\n    this.value *= operand;\n    return this;\n  }\n  // ... other operations go here ...\n}\n\nlet v = new BasicCalculator(2).multiply(5).add(1).currentValue();\n</code></pre>\n<p>Since the class uses <code>this</code> types, you can extend it and the new class can use the old methods with no changes.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">class BasicCalculator {\n  public constructor(protected value: number = 0) {}\n  public currentValue(): number {\n    return this.value;\n  }\n  public add(operand: number): this {\n    this.value += operand;\n    return this;\n  }\n  public multiply(operand: number): this {\n    this.value *= operand;\n    return this;\n  }\n  // ... other operations go here ...\n}\n// ---cut---\nclass ScientificCalculator extends BasicCalculator {\n  public constructor(value = 0) {\n    super(value);\n  }\n  public sin() {\n    this.value = Math.sin(this.value);\n    return this;\n  }\n  // ... other operations go here ...\n}\n\nlet v = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();\n</code></pre>\n<p>Without <code>this</code> types, <code>ScientificCalculator</code> would not have been able to extend <code>BasicCalculator</code> and keep the fluent interface.\n<code>multiply</code> would have returned <code>BasicCalculator</code>, which doesn’t have the <code>sin</code> method.\nHowever, with <code>this</code> types, <code>multiply</code> returns <code>this</code>, which is <code>ScientificCalculator</code> here.</p>\n<h2 id=\"index-types\" style=\"position:relative;\"><a href=\"#index-types\" aria-label=\"index types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index types</h2>\n<p>With index types, you can get the compiler to check code that uses dynamic property names.\nFor example, a common JavaScript pattern is to pick a subset of properties from an object:</p>\n<pre><code class=\"language-js\">function pluck(o, propertyNames) {\n  return propertyNames.map((n) => o[n]);\n}\n</code></pre>\n<p>Here’s how you would write and use this function in TypeScript, using the <strong>index type query</strong> and <strong>indexed access</strong> operators:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function pluck&#x3C;T, K extends keyof T>(o: T, propertyNames: K[]): T[K][] {\n  return propertyNames.map((n) => o[n]);\n}\n\ninterface Car {\n  manufacturer: string;\n  model: string;\n  year: number;\n}\n\nlet taxi: Car = {\n  manufacturer: \"Toyota\",\n  model: \"Camry\",\n  year: 2014,\n};\n\n// Manufacturer and model are both of type string,\n// so we can pluck them both into a typed string array\nlet makeAndModel: string[] = pluck(taxi, [\"manufacturer\", \"model\"]);\n\n// If we try to pluck model and year, we get an\n// array of a union type: (string | number)[]\nlet modelYear = pluck(taxi, [\"model\", \"year\"]);\n</code></pre>\n<p>The compiler checks that <code>manufacturer</code> and <code>model</code> are actually properties on <code>Car</code>.\nThe example introduces a couple of new type operators.\nFirst is <code>keyof T</code>, the <strong>index type query operator</strong>.\nFor any type <code>T</code>, <code>keyof T</code> is the union of known, public property names of <code>T</code>.\nFor example:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">interface Car {\n  manufacturer: string;\n  model: string;\n  year: number;\n}\n// ---cut---\nlet carProps: keyof Car;\n//         ^?\n</code></pre>\n<p><code>keyof Car</code> is completely interchangeable with <code>\"manufacturer\" | \"model\" | \"year\"</code>.\nThe difference is that if you add another property to <code>Car</code>, say <code>ownersAddress: string</code>, then <code>keyof Car</code> will automatically update to be <code>\"manufacturer\" | \"model\" | \"year\" | \"ownersAddress\"</code>.\nAnd you can use <code>keyof</code> in generic contexts like <code>pluck</code>, where you can’t possibly know the property names ahead of time.\nThat means the compiler will check that you pass the right set of property names to <code>pluck</code>:</p>\n<pre><code class=\"language-ts\">// error, Type '\"unknown\"' is not assignable to type '\"manufacturer\" | \"model\" | \"year\"'\npluck(taxi, [\"year\", \"unknown\"]);\n</code></pre>\n<p>The second operator is <code>T[K]</code>, the <strong>indexed access operator</strong>.\nHere, the type syntax reflects the expression syntax.\nThat means that <code>taxi[\"manufacturer\"]</code> has the type <code>Car[\"manufacturer\"]</code> — which in our example is just <code>string</code>.\nHowever, just like index type queries, you can use <code>T[K]</code> in a generic context, which is where its real power comes to life.\nYou just have to make sure that the type variable <code>K extends keyof T</code>.\nHere’s another example with a function named <code>getProperty</code>.</p>\n<pre><code class=\"language-ts\">function getProperty&#x3C;T, K extends keyof T>(o: T, propertyName: K): T[K] {\n  return o[propertyName]; // o[propertyName] is of type T[K]\n}\n</code></pre>\n<p>In <code>getProperty</code>, <code>o: T</code> and <code>propertyName: K</code>, so that means <code>o[propertyName]: T[K]</code>.\nOnce you return the <code>T[K]</code> result, the compiler will instantiate the actual type of the key, so the return type of <code>getProperty</code> will vary according to which property you request.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2345\nfunction getProperty&#x3C;T, K extends keyof T>(o: T, propertyName: K): T[K] {\n  return o[propertyName]; // o[propertyName] is of type T[K]\n}\ninterface Car {\n  manufacturer: string;\n  model: string;\n  year: number;\n}\nlet taxi: Car = {\n  manufacturer: \"Toyota\",\n  model: \"Camry\",\n  year: 2014,\n};\n// ---cut---\nlet manufacturer: string = getProperty(taxi, \"manufacturer\");\nlet year: number = getProperty(taxi, \"year\");\n\nlet unknown = getProperty(taxi, \"unknown\");\n</code></pre>\n<h2 id=\"index-types-and-index-signatures\" style=\"position:relative;\"><a href=\"#index-types-and-index-signatures\" aria-label=\"index types and index signatures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index types and index signatures</h2>\n<p><code>keyof</code> and <code>T[K]</code> interact with index signatures. An index signature parameter type must be ‘string’ or ‘number’.\nIf you have a type with a string index signature, <code>keyof T</code> will be <code>string | number</code>\n(and not just <code>string</code>, since in JavaScript you can access an object property either\nby using strings (<code>object[\"42\"]</code>) or numbers (<code>object[42]</code>)).\nAnd <code>T[string]</code> is just the type of the index signature:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">interface Dictionary&#x3C;T> {\n  [key: string]: T;\n}\nlet keys: keyof Dictionary&#x3C;number>;\n//     ^?\nlet value: Dictionary&#x3C;number>[\"foo\"];\n//      ^?\n</code></pre>\n<p>If you have a type with a number index signature, <code>keyof T</code> will just be <code>number</code>.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2339\ninterface Dictionary&#x3C;T> {\n  [key: number]: T;\n}\n\nlet keys: keyof Dictionary&#x3C;number>;\n//     ^?\nlet numberValue: Dictionary&#x3C;number>[42];\n//     ^?\nlet value: Dictionary&#x3C;number>[\"foo\"];\n</code></pre>\n<h2 id=\"mapped-types\" style=\"position:relative;\"><a href=\"#mapped-types\" aria-label=\"mapped types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mapped types</h2>\n<p>A common task is to take an existing type and make each of its properties optional:</p>\n<pre><code class=\"language-ts\">interface PersonSubset {\n  name?: string;\n  age?: number;\n}\n</code></pre>\n<p>Or we might want a readonly version:</p>\n<pre><code class=\"language-ts\">interface PersonReadonly {\n  readonly name: string;\n  readonly age: number;\n}\n</code></pre>\n<p>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types — <strong>mapped types</strong>.\nIn a mapped type, the new type transforms each property in the old type in the same way.\nFor example, you can make all properties optional or of a type <code>readonly</code>.\nHere are a couple of examples:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Partial&#x3C;T> = {\n  [P in keyof T]?: T[P];\n};\n\n// @noErrors\ntype Readonly&#x3C;T> = {\n  readonly [P in keyof T]: T[P];\n};\n</code></pre>\n<p>And to use it:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Person = {\n  name: string;\n  age: number;\n};\n// ---cut---\ntype PersonPartial = Partial&#x3C;Person>;\n//   ^?\ntype ReadonlyPerson = Readonly&#x3C;Person>;\n//   ^?\n</code></pre>\n<p>Note that this syntax describes a type rather than a member.\nIf you want to add members, you can use an intersection type:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2693 1005 1128\n// Use this:\ntype PartialWithNewMember&#x3C;T> = {\n  [P in keyof T]?: T[P];\n} &#x26; { newMember: boolean }\n\n// This is an error!\ntype WrongPartialWithNewMember&#x3C;T> = {\n  [P in keyof T]?: T[P];\n  newMember: boolean;\n}\n</code></pre>\n<p>Let’s take a look at the simplest mapped type and its parts:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Keys = \"option1\" | \"option2\";\ntype Flags = { [K in Keys]: boolean };\n</code></pre>\n<p>The syntax resembles the syntax for index signatures with a <code>for .. in</code> inside.\nThere are three parts:</p>\n<ol>\n<li>The type variable <code>K</code>, which gets bound to each property in turn.</li>\n<li>The string literal union <code>Keys</code>, which contains the names of properties to iterate over.</li>\n<li>The resulting type of the property.</li>\n</ol>\n<p>In this simple example, <code>Keys</code> is a hard-coded list of property names and the property type is always <code>boolean</code>, so this mapped type is equivalent to writing:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Flags = {\n  option1: boolean;\n  option2: boolean;\n};\n</code></pre>\n<p>Real applications, however, look like <code>Readonly</code> or <code>Partial</code> above.\nThey’re based on some existing type, and they transform the properties in some way.\nThat’s where <code>keyof</code> and indexed access types come in:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Person = {\n  name: string;\n  age: number;\n};\n// ---cut---\ntype NullablePerson = { [P in keyof Person]: Person[P] | null };\n//   ^?\ntype PartialPerson = { [P in keyof Person]?: Person[P] };\n//   ^?\n</code></pre>\n<p>But it’s more useful to have a general version.</p>\n<pre><code class=\"language-ts\">type Nullable&#x3C;T> = { [P in keyof T]: T[P] | null };\ntype Partial&#x3C;T> = { [P in keyof T]?: T[P] };\n</code></pre>\n<p>In these examples, the properties list is <code>keyof T</code> and the resulting type is some variant of <code>T[P]</code>.\nThis is a good template for any general use of mapped types.\nThat’s because this kind of transformation is <a href=\"https://wikipedia.org/wiki/Homomorphism\">homomorphic</a>, which means that the mapping applies only to properties of <code>T</code> and no others.\nThe compiler knows that it can copy all the existing property modifiers before adding any new ones.\nFor example, if <code>Person.name</code> was readonly, <code>Partial&#x3C;Person>.name</code> would be readonly and optional.</p>\n<p>Here’s one more example, in which <code>T[P]</code> is wrapped in a <code>Proxy&#x3C;T></code> class:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @noErrors\ntype Proxy&#x3C;T> = {\n  get(): T;\n  set(value: T): void;\n};\n\ntype Proxify&#x3C;T> = {\n  [P in keyof T]: Proxy&#x3C;T[P]>;\n};\n\nfunction proxify&#x3C;T>(o: T): Proxify&#x3C;T> {\n  // ... wrap proxies ...\n}\n\nlet props = { rooms: 4 };\nlet proxyProps = proxify(props);\n//  ^?\n</code></pre>\n<p>Note that <code>Readonly&#x3C;T></code> and <code>Partial&#x3C;T></code> are so useful, they are included in TypeScript’s standard library along with <code>Pick</code> and <code>Record</code>:</p>\n<pre><code class=\"language-ts\">type Pick&#x3C;T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\ntype Record&#x3C;K extends keyof any, T> = {\n  [P in K]: T;\n};\n</code></pre>\n<p><code>Readonly</code>, <code>Partial</code> and <code>Pick</code> are homomorphic whereas <code>Record</code> is not.\nOne clue that <code>Record</code> is not homomorphic is that it doesn’t take an input type to copy properties from:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type ThreeStringProps = Record&#x3C;\"prop1\" | \"prop2\" | \"prop3\", string>;\n</code></pre>\n<p>Non-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.</p>\n<p>Note that <code>keyof any</code> represents the type of any value that can be used as an index to an object. In otherwords, <code>keyof any</code> is currently equal to <code>string | number | symbol</code>.</p>\n<h2 id=\"inference-from-mapped-types\" style=\"position:relative;\"><a href=\"#inference-from-mapped-types\" aria-label=\"inference from mapped types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inference from mapped types</h2>\n<p>Now that you know how to wrap the properties of a type, the next thing you’ll want to do is unwrap them.\nFortunately, that’s pretty easy:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Proxy&#x3C;T> = {\n  get(): T;\n  set(value: T): void;\n};\n\ntype Proxify&#x3C;T> = {\n  [P in keyof T]: Proxy&#x3C;T[P]>;\n};\n\nfunction proxify&#x3C;T>(o: T): Proxify&#x3C;T> {\n  return {} as any;\n}\n\nlet props = { rooms: 4 };\nlet proxyProps = proxify(props);\n// ---cut---\nfunction unproxify&#x3C;T>(t: Proxify&#x3C;T>): T {\n  let result = {} as T;\n  for (const k in t) {\n    result[k] = t[k].get();\n  }\n  return result;\n}\n\nlet originalProps = unproxify(proxyProps);\n//  ^?\n</code></pre>\n<p>Note that this unwrapping inference only works on homomorphic mapped types.\nIf the mapped type is not homomorphic you’ll have to give an explicit type parameter to your unwrapping function.</p>\n<h2 id=\"conditional-types\" style=\"position:relative;\"><a href=\"#conditional-types\" aria-label=\"conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conditional Types</h2>\n<p>A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</p>\n<pre><code class=\"language-ts\">T extends U ? X : Y\n</code></pre>\n<p>The type above means when <code>T</code> is assignable to <code>U</code> the type is <code>X</code>, otherwise the type is <code>Y</code>.</p>\n<p>A conditional type <code>T extends U ? X : Y</code> is either <em>resolved</em> to <code>X</code> or <code>Y</code>, or <em>deferred</em> because the condition depends on one or more type variables.\nWhen <code>T</code> or <code>U</code> contains type variables, whether to resolve to <code>X</code> or <code>Y</code>, or to defer, is determined by whether or not the type system has enough information to conclude that <code>T</code> is always assignable to <code>U</code>.</p>\n<p>As an example of some types that are immediately resolved, we can take a look at the following example:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare function f&#x3C;T extends boolean>(x: T): T extends true ? string : number;\n\n// Type is 'string | number'\nlet x = f(Math.random() &#x3C; 0.5);\n//  ^?\n</code></pre>\n<p>Another example would be the <code>TypeName</code> type alias, which uses nested conditional types:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type TypeName&#x3C;T> = T extends string\n  ? \"string\"\n  : T extends number\n  ? \"number\"\n  : T extends boolean\n  ? \"boolean\"\n  : T extends undefined\n  ? \"undefined\"\n  : T extends Function\n  ? \"function\"\n  : \"object\";\n\ntype T0 = TypeName&#x3C;string>;\n//   ^?\ntype T1 = TypeName&#x3C;\"a\">;\n//   ^?\ntype T2 = TypeName&#x3C;true>;\n//   ^?\ntype T3 = TypeName&#x3C;() => void>;\n//   ^?\ntype T4 = TypeName&#x3C;string[]>;\n//   ^?\n</code></pre>\n<p>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">interface Foo {\n  propA: boolean;\n  propB: boolean;\n}\n\ndeclare function f&#x3C;T>(x: T): T extends Foo ? string : number;\n\nfunction foo&#x3C;U>(x: U) {\n  // Has type 'U extends Foo ? string : number'\n  let a = f(x);\n\n  // This assignment is allowed though!\n  let b: string | number = a;\n}\n</code></pre>\n<p>In the above, the variable <code>a</code> has a conditional type that hasn’t yet chosen a branch.\nWhen another piece of code ends up calling <code>foo</code>, it will substitute in <code>U</code> with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</p>\n<p>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target.\nSo in our example above we were able to assign <code>U extends Foo ? string : number</code> to <code>string | number</code> since no matter what the conditional evaluates to, it’s known to be either <code>string</code> or <code>number</code>.</p>\n<h2 id=\"distributive-conditional-types\" style=\"position:relative;\"><a href=\"#distributive-conditional-types\" aria-label=\"distributive conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Distributive conditional types</h2>\n<p>Conditional types in which the checked type is a naked type parameter are called <em>distributive conditional types</em>.\nDistributive conditional types are automatically distributed over union types during instantiation.\nFor example, an instantiation of <code>T extends U ? X : Y</code> with the type argument <code>A | B | C</code> for <code>T</code> is resolved as <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>.</p>\n<h4 id=\"example\" style=\"position:relative;\"><a href=\"#example\" aria-label=\"example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example</h4>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type TypeName&#x3C;T> = T extends string\n  ? \"string\"\n  : T extends number\n  ? \"number\"\n  : T extends boolean\n  ? \"boolean\"\n  : T extends undefined\n  ? \"undefined\"\n  : T extends Function\n  ? \"function\"\n  : \"object\";\n// ---cut---\ntype T5 = TypeName&#x3C;string | (() => void)>;\n//   ^?\ntype T6 = TypeName&#x3C;string | string[] | undefined>;\n//   ^?\ntype T7 = TypeName&#x3C;string[] | number[]>;\n//   ^?\n</code></pre>\n<p>In instantiations of a distributive conditional type <code>T extends U ? X : Y</code>, references to <code>T</code> within the conditional type are resolved to individual constituents of the union type (i.e. <code>T</code> refers to the individual constituents <em>after</em> the conditional type is distributed over the union type).\nFurthermore, references to <code>T</code> within <code>X</code> have an additional type parameter constraint <code>U</code> (i.e. <code>T</code> is considered assignable to <code>U</code> within <code>X</code>).</p>\n<h4 id=\"example-1\" style=\"position:relative;\"><a href=\"#example-1\" aria-label=\"example 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example</h4>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type BoxedValue&#x3C;T> = { value: T };\ntype BoxedArray&#x3C;T> = { array: T[] };\ntype Boxed&#x3C;T> = T extends any[] ? BoxedArray&#x3C;T[number]> : BoxedValue&#x3C;T>;\n\ntype T1 = Boxed&#x3C;string>;\n//   ^?\ntype T2 = Boxed&#x3C;number[]>;\n//   ^?\ntype T3 = Boxed&#x3C;string | number[]>;\n//   ^?\n</code></pre>\n<p>Notice that <code>T</code> has the additional constraint <code>any[]</code> within the true branch of <code>Boxed&#x3C;T></code> and it is therefore possible to refer to the element type of the array as <code>T[number]</code>. Also, notice how the conditional type is distributed over the union type in the last example.</p>\n<p>The distributive property of conditional types can conveniently be used to <em>filter</em> union types:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2300 2322\n// Remove types from T that are assignable to U\ntype Diff&#x3C;T, U> = T extends U ? never : T;\n// Remove types from T that are not assignable to U\ntype Filter&#x3C;T, U> = T extends U ? T : never;\n\ntype T1 = Diff&#x3C;\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">;\n//   ^?\ntype T2 = Filter&#x3C;\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"a\" | \"c\"\n//   ^?\ntype T3 = Diff&#x3C;string | number | (() => void), Function>; // string | number\n//   ^?\ntype T4 = Filter&#x3C;string | number | (() => void), Function>; // () => void\n//   ^?\n\n// Remove null and undefined from T\ntype NotNullable&#x3C;T> = Diff&#x3C;T, null | undefined>;\n\ntype T5 = NotNullable&#x3C;string | number | undefined>;\n//   ^?\ntype T6 = NotNullable&#x3C;string | string[] | null | undefined>;\n//   ^?\n\nfunction f1&#x3C;T>(x: T, y: NotNullable&#x3C;T>) {\n  x = y;\n  y = x;\n}\n\nfunction f2&#x3C;T extends string | undefined>(x: T, y: NotNullable&#x3C;T>) {\n  x = y;\n  y = x;\n  let s1: string = x;\n  let s2: string = y;\n}\n</code></pre>\n<p>Conditional types are particularly useful when combined with mapped types:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type FunctionPropertyNames&#x3C;T> = {\n  [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\ntype FunctionProperties&#x3C;T> = Pick&#x3C;T, FunctionPropertyNames&#x3C;T>>;\n\ntype NonFunctionPropertyNames&#x3C;T> = {\n  [K in keyof T]: T[K] extends Function ? never : K;\n}[keyof T];\ntype NonFunctionProperties&#x3C;T> = Pick&#x3C;T, NonFunctionPropertyNames&#x3C;T>>;\n\ninterface Part {\n  id: number;\n  name: string;\n  subparts: Part[];\n  updatePart(newName: string): void;\n}\n\ntype T1 = FunctionPropertyNames&#x3C;Part>;\n//   ^?\ntype T2 = NonFunctionPropertyNames&#x3C;Part>;\n//   ^?\ntype T3 = FunctionProperties&#x3C;Part>;\n//   ^?\ntype T4 = NonFunctionProperties&#x3C;Part>;\n//   ^?\n</code></pre>\n<p>Note, conditional types are not permitted to reference themselves recursively. For example the following is an error.</p>\n<h4 id=\"example-2\" style=\"position:relative;\"><a href=\"#example-2\" aria-label=\"example 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example</h4>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2456 2315\ntype ElementType&#x3C;T> = T extends any[] ? ElementType&#x3C;T[number]> : T; // Error\n</code></pre>\n<h2 id=\"type-inference-in-conditional-types\" style=\"position:relative;\"><a href=\"#type-inference-in-conditional-types\" aria-label=\"type inference in conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type inference in conditional types</h2>\n<p>Within the <code>extends</code> clause of a conditional type, it is now possible to have <code>infer</code> declarations that introduce a type variable to be inferred.\nSuch inferred type variables may be referenced in the true branch of the conditional type.\nIt is possible to have multiple <code>infer</code> locations for the same type variable.</p>\n<p>For example, the following extracts the return type of a function type:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @noErrors\ntype ReturnType&#x3C;T> = T extends (...args: any[]) => infer R ? R : any;\n</code></pre>\n<p>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Unpacked&#x3C;T> = T extends (infer U)[]\n  ? U\n  : T extends (...args: any[]) => infer U\n  ? U\n  : T extends Promise&#x3C;infer U>\n  ? U\n  : T;\n\ntype T0 = Unpacked&#x3C;string>;\n//   ^?\ntype T1 = Unpacked&#x3C;string[]>;\n//   ^?\ntype T2 = Unpacked&#x3C;() => string>;\n//   ^?\ntype T3 = Unpacked&#x3C;Promise&#x3C;string>>;\n//   ^?\ntype T4 = Unpacked&#x3C;Promise&#x3C;string>[]>;\n//   ^?\ntype T5 = Unpacked&#x3C;Unpacked&#x3C;Promise&#x3C;string>[]>>;\n//   ^?\n</code></pre>\n<p>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Foo&#x3C;T> = T extends { a: infer U; b: infer U } ? U : never;\n\ntype T1 = Foo&#x3C;{ a: string; b: string }>;\n//   ^?\ntype T2 = Foo&#x3C;{ a: string; b: number }>;\n//   ^?\n</code></pre>\n<p>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Bar&#x3C;T> = T extends { a: (x: infer U) => void; b: (x: infer U) => void }\n  ? U\n  : never;\n\ntype T1 = Bar&#x3C;{ a: (x: string) => void; b: (x: string) => void }>;\n//   ^?\ntype T2 = Bar&#x3C;{ a: (x: string) => void; b: (x: number) => void }>;\n//   ^?\n</code></pre>\n<p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the <em>last</em> signature (which, presumably, is the most permissive catch-all case).\nIt is not possible to perform overload resolution based on a list of argument types.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare function foo(x: string): number;\ndeclare function foo(x: number): string;\ndeclare function foo(x: string | number): string | number;\n\ntype T1 = ReturnType&#x3C;typeof foo>;\n//   ^?\n</code></pre>\n<p>It is not possible to use <code>infer</code> declarations in constraint clauses for regular type parameters:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 1338 2304\ntype ReturnedType&#x3C;T extends (...args: any[]) => infer R> = R;\n</code></pre>\n<p>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @noErrors\ntype AnyFunction = (...args: any[]) => any;\ntype ReturnType&#x3C;T extends AnyFunction> = T extends (...args: any[]) => infer R\n  ? R\n  : any;\n</code></pre>\n<h2 id=\"predefined-conditional-types\" style=\"position:relative;\"><a href=\"#predefined-conditional-types\" aria-label=\"predefined conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Predefined conditional types</h2>\n<p>TypeScript adds several predefined conditional types, you can find the full list and examples in <a href=\"/docs/handbook/utility-types.html\">Utility Types</a>.</p>","headings":[{"value":"Type Guards and Differentiating Types","depth":2},{"value":"User-Defined Type Guards","depth":2},{"value":"Using type predicates","depth":3},{"value":"Using the in operator","depth":3},{"value":"typeof type guards","depth":2},{"value":"instanceof type guards","depth":2},{"value":"Nullable types","depth":2},{"value":"Optional parameters and properties","depth":3},{"value":"Type guards and type assertions","depth":3},{"value":"Type Aliases","depth":2},{"value":"Interfaces vs. Type Aliases","depth":2},{"value":"Enum Member Types","depth":2},{"value":"Polymorphic this types","depth":2},{"value":"Index types","depth":2},{"value":"Index types and index signatures","depth":2},{"value":"Mapped types","depth":2},{"value":"Inference from mapped types","depth":2},{"value":"Conditional Types","depth":2},{"value":"Distributive conditional types","depth":2},{"value":"Example","depth":4},{"value":"Example","depth":4},{"value":"Example","depth":4},{"value":"Type inference in conditional types","depth":2},{"value":"Predefined conditional types","depth":2}],"frontmatter":{"permalink":"/docs/handbook/advanced-types.html","title":"Advanced Types","disable_toc":null,"handbook":null,"oneline":"Advanced concepts around types in TypeScript","preamble":null,"deprecated_by":"/docs/handbook/2/types-from-types.html","deprecation_redirects":["type-guards-and-differentiating-types","/docs/handbook/2/narrowing.html","user-defined-type-guards","/docs/handbook/2/narrowing.html#using-type-predicates","typeof-type-guards","/docs/handbook/2/narrowing.html#typeof-type-guards","instanceof-type-guards","/docs/handbook/2/narrowing.html#instanceof-narrowing","nullable-types","/docs/handbook/2/everyday-types.html#null-and-undefined","type-aliases","/docs/handbook/2/everyday-types.html#type-aliases","interfaces-vs-type-aliases","/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces","enum-member-types","/docs/handbook/enums.html","polymorphic-this-types","/docs/handbook/2/classes.html","index-types","/docs/handbook/2/indexed-access-types.html","index-types-and-index-signatures","/docs/handbook/2/indexed-access-types.html","mapped-types","/docs/handbook/2/mapped-types.html","inference-from-mapped-types","/docs/handbook/2/mapped-types.html","conditional-types","/docs/handbook/2/conditional-types.html","distributive-conditional-types","/docs/handbook/2/conditional-types.html#distributive-conditional-types","type-inference-in-conditional-types","/docs/handbook/2/conditional-types.html#inferring-within-conditional-types","predefined-conditional-types","/docs/handbook/utility-types.html","using-the-in-operator","/docs/handbook/2/narrowing.html#the-in-operator-narrowing"]}},"prev":null,"next":null},"pageContext":{"slug":"/docs/handbook/advanced-types.html","repoPath":"/packages/documentation/copy/en/reference/Advanced Types.md","lang":"en","modifiedTime":"2021-05-31T12:14:15.532Z"}},"staticQueryHashes":[]}