{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/typescript-in-5-minutes-func.html","result":{"data":{"markdownRemark":{"id":"5f1cd882-fe0e-5b85-8026-d988eab25885","excerpt":"TypeScript began its life as an attempt to bring traditional object-oriented types\nto JavaScript so that the programmers at Microsoft could bring\ntraditional…","html":"<p>TypeScript began its life as an attempt to bring traditional object-oriented types\nto JavaScript so that the programmers at Microsoft could bring\ntraditional object-oriented programs to the web. As it has developed, TypeScript’s type\nsystem has evolved to model code written by native JavaScripters. The\nresulting system is powerful, interesting and messy.</p>\n<p>This introduction is designed for working Haskell or ML programmers\nwho want to learn TypeScript. It describes how the type system of\nTypeScript differs from Haskell’s type system. It also describes\nunique features of TypeScript’s type system that arise from its\nmodelling of JavaScript code.</p>\n<p>This introduction does not cover object-oriented programming. In\npractice, object-oriented programs in TypeScript are similar to those\nin other popular languages with OO features.</p>\n<h2 id=\"prerequisites\" style=\"position:relative;\"><a href=\"#prerequisites\" aria-label=\"prerequisites permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prerequisites</h2>\n<p>In this introduction, I assume you know the following:</p>\n<ul>\n<li>How to program in JavaScript, the good parts.</li>\n<li>Type syntax of a C-descended language.</li>\n</ul>\n<p>If you need to learn the good parts of JavaScript, read\n<a href=\"http://shop.oreilly.com/product/9780596517748.do\">JavaScript: The Good Parts</a>.\nYou may be able to skip the book if you know how to write programs in\na call-by-value lexically scoped language with lots of mutability and\nnot much else.\n<a href=\"https://people.csail.mit.edu/jaffer/r4rs.pdf\">R<sup>4</sup>RS Scheme</a> is a good example.</p>\n<p><a href=\"http://www.stroustrup.com/4th.html\">The C++ Programming Language</a> is\na good place to learn about C-style type syntax. Unlike C++,\nTypeScript uses postfix types, like so: <code>x: string</code> instead of <code>string x</code>.</p>\n<h2 id=\"concepts-not-in-haskell\" style=\"position:relative;\"><a href=\"#concepts-not-in-haskell\" aria-label=\"concepts not in haskell permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Concepts not in Haskell</h2>\n<h2 id=\"built-in-types\" style=\"position:relative;\"><a href=\"#built-in-types\" aria-label=\"built in types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Built-in types</h2>\n<p>JavaScript defines 8 built-in types:</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Explanation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Number</code></td>\n<td>a double-precision IEEE 754 floating point.</td>\n</tr>\n<tr>\n<td><code>String</code></td>\n<td>an immutable UTF-16 string.</td>\n</tr>\n<tr>\n<td><code>BigInt</code></td>\n<td>integers in the arbitrary precision format.</td>\n</tr>\n<tr>\n<td><code>Boolean</code></td>\n<td><code>true</code> and <code>false</code>.</td>\n</tr>\n<tr>\n<td><code>Symbol</code></td>\n<td>a unique value usually used as a key.</td>\n</tr>\n<tr>\n<td><code>Null</code></td>\n<td>equivalent to the unit type.</td>\n</tr>\n<tr>\n<td><code>Undefined</code></td>\n<td>also equivalent to the unit type.</td>\n</tr>\n<tr>\n<td><code>Object</code></td>\n<td>similar to records.</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Data_structures\">See the MDN page for more detail</a>.</p>\n<p>TypeScript has corresponding primitive types for the built-in types:</p>\n<ul>\n<li><code>number</code></li>\n<li><code>string</code></li>\n<li><code>bigint</code></li>\n<li><code>boolean</code></li>\n<li><code>symbol</code></li>\n<li><code>null</code></li>\n<li><code>undefined</code></li>\n<li><code>object</code></li>\n</ul>\n<h3 id=\"other-important-typescript-types\" style=\"position:relative;\"><a href=\"#other-important-typescript-types\" aria-label=\"other important typescript types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Other important TypeScript types</h3>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Explanation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>unknown</code></td>\n<td>the top type.</td>\n</tr>\n<tr>\n<td><code>never</code></td>\n<td>the bottom type.</td>\n</tr>\n<tr>\n<td>object literal</td>\n<td>eg <code>{ property: Type }</code></td>\n</tr>\n<tr>\n<td><code>void</code></td>\n<td>a subtype of <code>undefined</code> intended for use as a return type.</td>\n</tr>\n<tr>\n<td><code>T[]</code></td>\n<td>mutable arrays, also written <code>Array&#x3C;T></code></td>\n</tr>\n<tr>\n<td><code>[T, T]</code></td>\n<td>tuples, which are fixed-length but mutable</td>\n</tr>\n<tr>\n<td><code>(t: T) => U</code></td>\n<td>functions</td>\n</tr>\n</tbody>\n</table>\n<p>Notes:</p>\n<ol>\n<li>\n<p>Function syntax includes parameter names. This is pretty hard to get used to!</p>\n<pre><code class=\"language-ts\">let fst: (a: any, b: any) => any = (a, b) => a;\n\n// or more precisely:\n\nlet fst: &#x3C;T, U>(a: T, b: U) => T = (a, b) => a;\n</code></pre>\n</li>\n<li>\n<p>Object literal type syntax closely mirrors object literal value syntax:</p>\n<pre><code class=\"language-ts\">let o: { n: number; xs: object[] } = { n: 1, xs: [] };\n</code></pre>\n</li>\n<li><code>[T, T]</code> is a subtype of <code>T[]</code>. This is different than Haskell, where tuples are not related to lists.</li>\n</ol>\n<h3 id=\"boxed-types\" style=\"position:relative;\"><a href=\"#boxed-types\" aria-label=\"boxed types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Boxed types</h3>\n<p>JavaScript has boxed equivalents of primitive types that contain the\nmethods that programmers associate with those types. TypeScript\nreflects this with, for example, the difference between the primitive\ntype <code>number</code> and the boxed type <code>Number</code>. The boxed types are rarely\nneeded, since their methods return primitives.</p>\n<pre><code class=\"language-ts\">(1).toExponential();\n// equivalent to\nNumber.prototype.toExponential.call(1);\n</code></pre>\n<p>Note that calling a method on a numeric literal requires it to be in\nparentheses to aid the parser.</p>\n<h2 id=\"gradual-typing\" style=\"position:relative;\"><a href=\"#gradual-typing\" aria-label=\"gradual typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gradual typing</h2>\n<p>TypeScript uses the type <code>any</code> whenever it can’t tell what the type of\nan expression should be. Compared to <code>Dynamic</code>, calling <code>any</code> a type\nis an overstatement. It just turns off the type checker\nwherever it appears. For example, you can push any value into an\n<code>any[]</code> without marking the value in any way:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// with \"noImplicitAny\": false in tsconfig.json, anys: any[]\nconst anys = [];\nanys.push(1);\nanys.push(\"oh no\");\nanys.push({ anything: \"goes\" });\n</code></pre>\n<p>And you can use an expression of type <code>any</code> anywhere:</p>\n<pre><code class=\"language-ts\">anys.map(anys[1]); // oh no, \"oh no\" is not a function\n</code></pre>\n<p><code>any</code> is contagious, too — if you initialise a variable with an\nexpression of type <code>any</code>, the variable has type <code>any</code> too.</p>\n<pre><code class=\"language-ts\">let sepsis = anys[0] + anys[1]; // this could mean anything\n</code></pre>\n<p>To get an error when TypeScript produces an <code>any</code>, use\n<code>\"noImplicitAny\": true</code>, or <code>\"strict\": true</code> in <code>tsconfig.json</code>.</p>\n<h2 id=\"structural-typing\" style=\"position:relative;\"><a href=\"#structural-typing\" aria-label=\"structural typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Structural typing</h2>\n<p>Structural typing is a familiar concept to most functional\nprogrammers, although Haskell and most MLs are not\nstructurally typed. Its basic form is pretty simple:</p>\n<pre><code class=\"language-ts\">// @strict: false\nlet o = { x: \"hi\", extra: 1 }; // ok\nlet o2: { x: string } = o; // ok\n</code></pre>\n<p>Here, the object literal <code>{ x: \"hi\", extra: 1 }</code> has a matching\nliteral type <code>{ x: string, extra: number }</code>. That\ntype is assignable to <code>{ x: string }</code> since\nit has all the required properties and those properties have\nassignable types. The extra property doesn’t prevent assignment, it\njust makes it a subtype of <code>{ x: string }</code>.</p>\n<p>Named types just give a name to a type; for assignability purposes\nthere’s no difference between the type alias <code>One</code> and the interface\ntype <code>Two</code> below. They both have a property <code>p: string</code>. (Type aliases\nbehave differently from interfaces with respect to recursive\ndefinitions and type parameters, however.)</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2322\ntype One = { p: string };\ninterface Two {\n  p: string;\n}\nclass Three {\n  p = \"Hello\";\n}\n\nlet x: One = { p: \"hi\" };\nlet two: Two = x;\ntwo = new Three();\n</code></pre>\n<h2 id=\"unions\" style=\"position:relative;\"><a href=\"#unions\" aria-label=\"unions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unions</h2>\n<p>In TypeScript, union types are untagged. In other words, they are not\ndiscriminated unions like <code>data</code> in Haskell. However, you can often\ndiscriminate types in a union using built-in tags or other properties.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function start(\n  arg: string | string[] | (() => string) | { s: string }\n): string {\n  // this is super common in JavaScript\n  if (typeof arg === \"string\") {\n    return commonCase(arg);\n  } else if (Array.isArray(arg)) {\n    return arg.map(commonCase).join(\",\");\n  } else if (typeof arg === \"function\") {\n    return commonCase(arg());\n  } else {\n    return commonCase(arg.s);\n  }\n\n  function commonCase(s: string): string {\n    // finally, just convert a string to another string\n    return s;\n  }\n}\n</code></pre>\n<p><code>string</code>, <code>Array</code> and <code>Function</code> have built-in type predicates,\nconveniently leaving the object type for the <code>else</code> branch. It is\npossible, however, to generate unions that are difficult to\ndifferentiate at runtime. For new code, it’s best to build only\ndiscriminated unions.</p>\n<p>The following types have built-in predicates:</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Predicate</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>string</td>\n<td><code>typeof s === \"string\"</code></td>\n</tr>\n<tr>\n<td>number</td>\n<td><code>typeof n === \"number\"</code></td>\n</tr>\n<tr>\n<td>bigint</td>\n<td><code>typeof m === \"bigint\"</code></td>\n</tr>\n<tr>\n<td>boolean</td>\n<td><code>typeof b === \"boolean\"</code></td>\n</tr>\n<tr>\n<td>symbol</td>\n<td><code>typeof g === \"symbol\"</code></td>\n</tr>\n<tr>\n<td>undefined</td>\n<td><code>typeof undefined === \"undefined\"</code></td>\n</tr>\n<tr>\n<td>function</td>\n<td><code>typeof f === \"function\"</code></td>\n</tr>\n<tr>\n<td>array</td>\n<td><code>Array.isArray(a)</code></td>\n</tr>\n<tr>\n<td>object</td>\n<td><code>typeof o === \"object\"</code></td>\n</tr>\n</tbody>\n</table>\n<p>Note that functions and arrays are objects at runtime, but have their\nown predicates.</p>\n<h3 id=\"intersections\" style=\"position:relative;\"><a href=\"#intersections\" aria-label=\"intersections permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intersections</h3>\n<p>In addition to unions, TypeScript also has intersections:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Combined = { a: number } &#x26; { b: string };\ntype Conflicting = { a: number } &#x26; { a: string };\n</code></pre>\n<p><code>Combined</code> has two properties, <code>a</code> and <code>b</code>, just as if they had been\nwritten as one object literal type. Intersection and union are\nrecursive in case of conflicts, so <code>Conflicting.a: number &#x26; string</code>.</p>\n<h2 id=\"unit-types\" style=\"position:relative;\"><a href=\"#unit-types\" aria-label=\"unit types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unit types</h2>\n<p>Unit types are subtypes of primitive types that contain exactly one\nprimitive value. For example, the string <code>\"foo\"</code> has the type\n<code>\"foo\"</code>. Since JavaScript has no built-in enums, it is common to use a set of\nwell-known strings instead. Unions of string literal types allow\nTypeScript to type this pattern:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare function pad(s: string, n: number, direction: \"left\" | \"right\"): string;\npad(\"hi\", 10, \"left\");\n</code></pre>\n<p>When needed, the compiler <em>widens</em> — converts to a\nsupertype — the unit type to the primitive type, such as <code>\"foo\"</code>\nto <code>string</code>. This happens when using mutability, which can hamper some\nuses of mutable variables:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2345\ndeclare function pad(s: string, n: number, direction: \"left\" | \"right\"): string;\n// ---cut---\nlet s = \"right\";\npad(\"hi\", 10, s); // error: 'string' is not assignable to '\"left\" | \"right\"'\n</code></pre>\n<p>Here’s how the error happens:</p>\n<ul>\n<li><code>\"right\": \"right\"</code></li>\n<li><code>s: string</code> because <code>\"right\"</code> widens to <code>string</code> on assignment to a mutable variable.</li>\n<li><code>string</code> is not assignable to <code>\"left\" | \"right\"</code></li>\n</ul>\n<p>You can work around this with a type annotation for <code>s</code>, but that\nin turn prevents assignments to <code>s</code> of variables that are not of type\n<code>\"left\" | \"right\"</code>.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare function pad(s: string, n: number, direction: \"left\" | \"right\"): string;\n// ---cut---\nlet s: \"left\" | \"right\" = \"right\";\npad(\"hi\", 10, s);\n</code></pre>\n<h2 id=\"concepts-similar-to-haskell\" style=\"position:relative;\"><a href=\"#concepts-similar-to-haskell\" aria-label=\"concepts similar to haskell permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Concepts similar to Haskell</h2>\n<h2 id=\"contextual-typing\" style=\"position:relative;\"><a href=\"#contextual-typing\" aria-label=\"contextual typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Contextual typing</h2>\n<p>TypeScript has some obvious places where it can infer types, like\nvariable declarations:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">let s = \"I'm a string!\";\n</code></pre>\n<p>But it also infers types in a few other places that you may not expect\nif you’ve worked with other C-syntax languages:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare function map&#x3C;T, U>(f: (t: T) => U, ts: T[]): U[];\nlet sns = map((n) => n.toString(), [1, 2, 3]);\n</code></pre>\n<p>Here, <code>n: number</code> in this example also, despite the fact that <code>T</code> and <code>U</code>\nhave not been inferred before the call. In fact, after <code>[1,2,3]</code> has\nbeen used to infer <code>T=number</code>, the return type of <code>n => n.toString()</code>\nis used to infer <code>U=string</code>, causing <code>sns</code> to have the type\n<code>string[]</code>.</p>\n<p>Note that inference will work in any order, but intellisense will only\nwork left-to-right, so TypeScript prefers to declare <code>map</code> with the\narray first:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare function map&#x3C;T, U>(ts: T[], f: (t: T) => U): U[];\n</code></pre>\n<p>Contextual typing also works recursively through object literals, and\non unit types that would otherwise be inferred as <code>string</code> or\n<code>number</code>. And it can infer return types from context:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare function run&#x3C;T>(thunk: (t: T) => void): T;\nlet i: { inference: string } = run((o) => {\n  o.inference = \"INSERT STATE HERE\";\n});\n</code></pre>\n<p>The type of <code>o</code> is determined to be <code>{ inference: string }</code> because</p>\n<ol>\n<li>Declaration initialisers are contextually typed by the\ndeclaration’s type: <code>{ inference: string }</code>.</li>\n<li>The return type of a call uses the contextual type for inferences,\nso the compiler infers that <code>T={ inference: string }</code>.</li>\n<li>Arrow functions use the contextual type to type their parameters,\nso the compiler gives <code>o: { inference: string }</code>.</li>\n</ol>\n<p>And it does so while you are typing, so that after typing <code>o.</code>, you\nget completions for the property <code>inference</code>, along with any other\nproperties you’d have in a real program.\nAltogether, this feature can make TypeScript’s inference look a bit\nlike a unifying type inference engine, but it is not.</p>\n<h2 id=\"type-aliases\" style=\"position:relative;\"><a href=\"#type-aliases\" aria-label=\"type aliases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type aliases</h2>\n<p>Type aliases are mere aliases, just like <code>type</code> in Haskell. The\ncompiler will attempt to use the alias name wherever it was used in\nthe source code, but does not always succeed.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Size = [number, number];\nlet x: Size = [101.1, 999.9];\n</code></pre>\n<p>The closest equivalent to <code>newtype</code> is a <em>tagged intersection</em>:</p>\n<pre><code class=\"language-ts\">type FString = string &#x26; { __compileTimeOnly: any };\n</code></pre>\n<p>An <code>FString</code> is just like a normal string, except that the compiler\nthinks it has a property named <code>__compileTimeOnly</code> that doesn’t\nactually exist. This means that <code>FString</code> can still be assigned to\n<code>string</code>, but not the other way round.</p>\n<h2 id=\"discriminated-unions\" style=\"position:relative;\"><a href=\"#discriminated-unions\" aria-label=\"discriminated unions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Discriminated Unions</h2>\n<p>The closest equivalent to <code>data</code> is a union of types with discriminant\nproperties, normally called discriminated unions in TypeScript:</p>\n<pre><code class=\"language-ts\">type Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n</code></pre>\n<p>Unlike Haskell, the tag, or discriminant, is just a property in each\nobject type. Each variant has an identical property with a different\nunit type. This is still a normal union type; the leading <code>|</code> is\nan optional part of the union type syntax. You can discriminate the\nmembers of the union using normal JavaScript code:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n\nfunction area(s: Shape) {\n  if (s.kind === \"circle\") {\n    return Math.PI * s.radius * s.radius;\n  } else if (s.kind === \"square\") {\n    return s.x * s.x;\n  } else {\n    return (s.x * s.y) / 2;\n  }\n}\n</code></pre>\n<p>Note that the return type of <code>area</code> is inferred to be <code>number</code> because\nTypeScript knows the function is total. If some variant is not\ncovered, the return type of <code>area</code> will be <code>number | undefined</code> instead.</p>\n<p>Also, unlike Haskell, common properties show up in any union, so you\ncan usefully discriminate multiple members of the union:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; x: number }\n  | { kind: \"triangle\"; x: number; y: number };\n// ---cut---\nfunction height(s: Shape) {\n  if (s.kind === \"circle\") {\n    return 2 * s.radius;\n  } else {\n    // s.kind: \"square\" | \"triangle\"\n    return s.x;\n  }\n}\n</code></pre>\n<h2 id=\"type-parameters\" style=\"position:relative;\"><a href=\"#type-parameters\" aria-label=\"type parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Parameters</h2>\n<p>Like most C-descended languages, TypeScript requires declaration of\ntype parameters:</p>\n<pre><code class=\"language-ts\">function liftArray&#x3C;T>(t: T): Array&#x3C;T> {\n  return [t];\n}\n</code></pre>\n<p>There is no case requirement, but type parameters are conventionally\nsingle uppercase letters. Type parameters can also be constrained to a\ntype, which behaves a bit like type class constraints:</p>\n<pre><code class=\"language-ts\">function firstish&#x3C;T extends { length: number }>(t1: T, t2: T): T {\n  return t1.length > t2.length ? t1 : t2;\n}\n</code></pre>\n<p>TypeScript can usually infer type arguments from a call based on the\ntype of the arguments, so type arguments are usually not needed.</p>\n<p>Because TypeScript is structural, it doesn’t need type parameters as\nmuch as nominal systems. Specifically, they are not needed to make a\nfunction polymorphic. Type parameters should only be used to\n<em>propagate</em> type information, such as constraining parameters to be\nthe same type:</p>\n<pre><code class=\"language-ts\">function length&#x3C;T extends ArrayLike&#x3C;unknown>>(t: T): number {}\n\nfunction length(t: ArrayLike&#x3C;unknown>): number {}\n</code></pre>\n<p>In the first <code>length</code>, T is not necessary; notice that it’s only\nreferenced once, so it’s not being used to constrain the type of the\nreturn value or other parameters.</p>\n<h3 id=\"higher-kinded-types\" style=\"position:relative;\"><a href=\"#higher-kinded-types\" aria-label=\"higher kinded types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Higher-kinded types</h3>\n<p>TypeScript does not have higher kinded types, so the following is not legal:</p>\n<pre><code class=\"language-ts\">function length&#x3C;T extends ArrayLike&#x3C;unknown>, U>(m: T&#x3C;U>) {}\n</code></pre>\n<h3 id=\"point-free-programming\" style=\"position:relative;\"><a href=\"#point-free-programming\" aria-label=\"point free programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Point-free programming</h3>\n<p>Point-free programming — heavy use of currying and function\ncomposition — is possible in JavaScript, but can be verbose.\nIn TypeScript, type inference often fails for point-free programs, so\nyou’ll end up specifying type parameters instead of value parameters. The\nresult is so verbose that it’s usually better to avoid point-free\nprogramming.</p>\n<h2 id=\"module-system\" style=\"position:relative;\"><a href=\"#module-system\" aria-label=\"module system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module system</h2>\n<p>JavaScript’s modern module syntax is a bit like Haskell’s, except that\nany file with <code>import</code> or <code>export</code> is implicitly a module:</p>\n<pre><code class=\"language-ts\">import { value, Type } from \"npm-package\";\nimport { other, Types } from \"./local-package\";\nimport * as prefix from \"../lib/third-package\";\n</code></pre>\n<p>You can also import commonjs modules — modules written using node.js’\nmodule system:</p>\n<pre><code class=\"language-ts\">import f = require(\"single-function-package\");\n</code></pre>\n<p>You can export with an export list:</p>\n<pre><code class=\"language-ts\">export { f };\n\nfunction f() {\n  return g();\n}\nfunction g() {} // g is not exported\n</code></pre>\n<p>Or by marking each export individually:</p>\n<pre><code class=\"language-ts\">export function f { return g() }\nfunction g() { }\n</code></pre>\n<p>The latter style is more common but both are allowed, even in the same\nfile.</p>\n<h2 id=\"readonly-and-const\" style=\"position:relative;\"><a href=\"#readonly-and-const\" aria-label=\"readonly and const permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>readonly</code> and <code>const</code></h2>\n<p>In JavaScript, mutability is the default, although it allows variable\ndeclarations with <code>const</code> to declare that the <em>reference</em> is\nimmutable. The referent is still mutable:</p>\n<pre><code class=\"language-js\">const a = [1, 2, 3];\na.push(102); // ):\na[0] = 101; // D:\n</code></pre>\n<p>TypeScript additionally has a <code>readonly</code> modifier for properties.</p>\n<pre><code class=\"language-ts\">interface Rx {\n  readonly x: number;\n}\nlet rx: Rx = { x: 1 };\nrx.x = 12; // error\n</code></pre>\n<p>It also ships with a mapped type <code>Readonly&#x3C;T></code> that makes\nall properties <code>readonly</code>:</p>\n<pre><code class=\"language-ts\">interface X {\n  x: number;\n}\nlet rx: Readonly&#x3C;X> = { x: 1 };\nrx.x = 12; // error\n</code></pre>\n<p>And it has a specific <code>ReadonlyArray&#x3C;T></code> type that removes\nside-affecting methods and prevents writing to indices of the array,\nas well as special syntax for this type:</p>\n<pre><code class=\"language-ts\">let a: ReadonlyArray&#x3C;number> = [1, 2, 3];\nlet b: readonly number[] = [1, 2, 3];\na.push(102); // error\nb[0] = 101; // error\n</code></pre>\n<p>You can also use a const-assertion, which operates on arrays and\nobject literals:</p>\n<pre><code class=\"language-ts\">let a = [1, 2, 3] as const;\na.push(102); // error\na[0] = 101; // error\n</code></pre>\n<p>However, none of these options are the default, so they are not\nconsistently used in TypeScript code.</p>\n<h2 id=\"next-steps\" style=\"position:relative;\"><a href=\"#next-steps\" aria-label=\"next steps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Next Steps</h2>\n<p>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:</p>\n<ul>\n<li>Read the full Handbook <a href=\"/docs/handbook/intro.html\">from start to finish</a> (30m)</li>\n<li>Explore the <a href=\"/play#show-examples\">Playground examples</a></li>\n</ul>","headings":[{"value":"Prerequisites","depth":2},{"value":"Concepts not in Haskell","depth":2},{"value":"Built-in types","depth":2},{"value":"Other important TypeScript types","depth":3},{"value":"Boxed types","depth":3},{"value":"Gradual typing","depth":2},{"value":"Structural typing","depth":2},{"value":"Unions","depth":2},{"value":"Intersections","depth":3},{"value":"Unit types","depth":2},{"value":"Concepts similar to Haskell","depth":2},{"value":"Contextual typing","depth":2},{"value":"Type aliases","depth":2},{"value":"Discriminated Unions","depth":2},{"value":"Type Parameters","depth":2},{"value":"Higher-kinded types","depth":3},{"value":"Point-free programming","depth":3},{"value":"Module system","depth":2},{"value":"readonly and const","depth":2},{"value":"Next Steps","depth":2}],"frontmatter":{"permalink":"/docs/handbook/typescript-in-5-minutes-func.html","title":"TypeScript for Functional Programmers","disable_toc":null,"handbook":null,"oneline":"Learn TypeScript if you have a background in functional programming","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"0-typescript-for-functional-programmers","slug":"/docs/handbook/typescript-in-5-minutes-func.html","repoPath":"/packages/documentation/copy/en/get-started/TS for Functional Programmers.md","lang":"en","modifiedTime":"2021-05-31T12:14:15.528Z"}},"staticQueryHashes":[]}