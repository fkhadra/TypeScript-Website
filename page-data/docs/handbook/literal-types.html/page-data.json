{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/literal-types.html","result":{"data":{"markdownRemark":{"id":"351e7d51-4786-571c-ba5f-9f2320a2a0eb","excerpt":"A literal is a more concrete sub-type of a collective type.\nWhat this means is that \"Hello World\" is a string, but a string is not \"Hello World\" inside the type…","html":"<p>A literal is a more concrete sub-type of a collective type.\nWhat this means is that <code>\"Hello World\"</code> is a <code>string</code>, but a <code>string</code> is not <code>\"Hello World\"</code> inside the type system.</p>\n<p>There are three sets of literal types available in TypeScript today: strings, numbers, and booleans; by using literal types you can allow an exact value which a string, number, or boolean must have.</p>\n<h2 id=\"literal-narrowing\" style=\"position:relative;\"><a href=\"#literal-narrowing\" aria-label=\"literal narrowing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Literal Narrowing</h2>\n<p>When you declare a variable via <code>var</code> or <code>let</code>, you are telling the compiler that there is the chance that this variable will change its contents.\nIn contrast, using <code>const</code> to declare a variable will inform TypeScript that this object will never change.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// We're making a guarantee that this variable\n// helloWorld will never change, by using const.\n\n// So, TypeScript sets the type to be \"Hello World\", not string\nconst helloWorld = \"Hello World\";\n\n// On the other hand, a let can change, and so the compiler declares it a string\nlet hiWorld = \"Hi World\";\n</code></pre>\n<p>The process of going from an infinite number of potential cases (there are an infinite number of possible string values) to a smaller, finite number of potential case (in <code>helloWorld</code>’s case: 1) is called narrowing.</p>\n<h2 id=\"string-literal-types\" style=\"position:relative;\"><a href=\"#string-literal-types\" aria-label=\"string literal types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>String Literal Types</h2>\n<p>In practice string literal types combine nicely with union types, type guards, and type aliases.\nYou can use these features together to get enum-like behavior with strings.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2345\ntype Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\";\n\nclass UIElement {\n  animate(dx: number, dy: number, easing: Easing) {\n    if (easing === \"ease-in\") {\n      // ...\n    } else if (easing === \"ease-out\") {\n    } else if (easing === \"ease-in-out\") {\n    } else {\n      // It's possible that someone could reach this\n      // by ignoring your types though.\n    }\n  }\n}\n\nlet button = new UIElement();\nbutton.animate(0, 0, \"ease-in\");\nbutton.animate(0, 0, \"uneasy\");\n</code></pre>\n<p>You can pass any of the three allowed strings, but any other string will give the error</p>\n<pre><code>Argument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n</code></pre>\n<p>String literal types can be used in the same way to distinguish overloads:</p>\n<pre><code class=\"language-ts\">function createElement(tagName: \"img\"): HTMLImageElement;\nfunction createElement(tagName: \"input\"): HTMLInputElement;\n// ... more overloads ...\nfunction createElement(tagName: string): Element {\n  // ... code goes here ...\n}\n</code></pre>\n<h2 id=\"numeric-literal-types\" style=\"position:relative;\"><a href=\"#numeric-literal-types\" aria-label=\"numeric literal types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Numeric Literal Types</h2>\n<p>TypeScript also has numeric literal types, which act the same as the string literals above.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\n  return (Math.floor(Math.random() * 6) + 1) as 1 | 2 | 3 | 4 | 5 | 6;\n}\n\nconst result = rollDice();\n</code></pre>\n<p>A common case for their use is for describing config values:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">/** Creates a map centered at loc/lat */\ndeclare function setupMap(config: MapConfig): void;\n// ---cut---\ninterface MapConfig {\n  lng: number;\n  lat: number;\n  tileSize: 8 | 16 | 32;\n}\n\nsetupMap({ lng: -73.935242, lat: 40.73061, tileSize: 16 });\n</code></pre>\n<h2 id=\"boolean-literal-types\" style=\"position:relative;\"><a href=\"#boolean-literal-types\" aria-label=\"boolean literal types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Boolean Literal Types</h2>\n<p>TypeScript also has boolean literal types. You might use these to constrain object values whose properties are interrelated.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">interface ValidationSuccess {\n  isValid: true;\n  reason: null;\n}\n\ninterface ValidationFailure {\n  isValid: false;\n  reason: string;\n}\n\ntype ValidationResult = ValidationSuccess | ValidationFailure;\n</code></pre>","headings":[{"value":"Literal Narrowing","depth":2},{"value":"String Literal Types","depth":2},{"value":"Numeric Literal Types","depth":2},{"value":"Boolean Literal Types","depth":2}],"frontmatter":{"permalink":"/docs/handbook/literal-types.html","title":"Literal Types","disable_toc":null,"handbook":"true","oneline":"Using literal types with TypeScript","preamble":null,"deprecated_by":"/docs/handbook/2/everyday-types.html#literal-types","deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"slug":"/docs/handbook/literal-types.html","repoPath":"/packages/documentation/copy/en/handbook-v1/Literal Types.md","lang":"en","modifiedTime":"2021-05-31T12:14:15.528Z"}},"staticQueryHashes":[]}