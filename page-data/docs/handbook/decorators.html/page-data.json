{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/decorators.html","result":{"data":{"markdownRemark":{"id":"abfc3c91-646e-5bd0-b718-d8dbc48f362b","excerpt":"Introduction With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or…","html":"<h2 id=\"introduction\" style=\"position:relative;\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h2>\n<blockquote class='bg-reading'>\n  <p>Further Reading:<br /><a href='https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/'>A Complete Guide to TypeScript Decorators</a></p>\n</blockquote>\n<p>With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members.\nDecorators provide a way to add both annotations and a meta-programming syntax for class declarations and members.\nDecorators are a <a href=\"https://github.com/tc39/proposal-decorators\">stage 2 proposal</a> for JavaScript and are available as an experimental feature of TypeScript.</p>\n<blockquote>\n<p>NOTE  Decorators are an experimental feature that may change in future releases.</p>\n</blockquote>\n<p>To enable experimental support for decorators, you must enable the <code>experimentalDecorators</code> compiler option either on the command line or in your <code>tsconfig.json</code>:</p>\n<p><strong>Command Line</strong>:</p>\n<pre><code class=\"language-shell\">tsc --target ES5 --experimentalDecorators\n</code></pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n</code></pre>\n<h2 id=\"decorators\" style=\"position:relative;\"><a href=\"#decorators\" aria-label=\"decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decorators</h2>\n<p>A <em>Decorator</em> is a special kind of declaration that can be attached to a <a href=\"#class-decorators\">class declaration</a>, <a href=\"#method-decorators\">method</a>, <a href=\"#accessor-decorators\">accessor</a>, <a href=\"#property-decorators\">property</a>, or <a href=\"#parameter-decorators\">parameter</a>.\nDecorators use the form <code>@expression</code>, where <code>expression</code> must evaluate to a function that will be called at runtime with information about the decorated declaration.</p>\n<p>For example, given the decorator <code>@sealed</code> we might write the <code>sealed</code> function as follows:</p>\n<pre><code class=\"language-ts\">function sealed(target) {\n  // do something with 'target' ...\n}\n</code></pre>\n<h2 id=\"decorator-factories\" style=\"position:relative;\"><a href=\"#decorator-factories\" aria-label=\"decorator factories permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decorator Factories</h2>\n<p>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory.\nA <em>Decorator Factory</em> is simply a function that returns the expression that will be called by the decorator at runtime.</p>\n<p>We can write a decorator factory in the following fashion:</p>\n<pre><code class=\"language-ts\">function color(value: string) {\n  // this is the decorator factory, it sets up\n  // the returned decorator function\n  return function (target) {\n    // this is the decorator\n    // do something with 'target' and 'value'...\n  };\n}\n</code></pre>\n<h2 id=\"decorator-composition\" style=\"position:relative;\"><a href=\"#decorator-composition\" aria-label=\"decorator composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decorator Composition</h2>\n<p>Multiple decorators can be applied to a declaration, for example on a single line:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\n// @noErrors\nfunction f() {}\nfunction g() {}\n// ---cut---\n@f @g x\n</code></pre>\n<p>On multiple lines:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\n// @noErrors\nfunction f() {}\nfunction g() {}\n// ---cut---\n@f\n@g\nx\n</code></pre>\n<p>When multiple decorators apply to a single declaration, their evaluation is similar to <a href=\"http://wikipedia.org/wiki/Function_composition\">function composition in mathematics</a>. In this model, when composing functions <em>f</em> and <em>g</em>, the resulting composite (<em>f</em> ∘ <em>g</em>)(<em>x</em>) is equivalent to <em>f</em>(<em>g</em>(<em>x</em>)).</p>\n<p>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</p>\n<ol>\n<li>The expressions for each decorator are evaluated top-to-bottom.</li>\n<li>The results are then called as functions from bottom-to-top.</li>\n</ol>\n<p>If we were to use <a href=\"#decorator-factories\">decorator factories</a>, we can observe this evaluation order with the following example:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction first() {\n  console.log(\"first(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"first(): called\");\n  };\n}\n\nfunction second() {\n  console.log(\"second(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"second(): called\");\n  };\n}\n\nclass ExampleClass {\n  @first()\n  @second()\n  method() {}\n}\n</code></pre>\n<p>Which would print this output to the console:</p>\n<pre><code class=\"language-shell\">first(): factory evaluated\nsecond(): factory evaluated\nsecond(): called\nfirst(): called\n</code></pre>\n<h2 id=\"decorator-evaluation\" style=\"position:relative;\"><a href=\"#decorator-evaluation\" aria-label=\"decorator evaluation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decorator Evaluation</h2>\n<p>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</p>\n<ol>\n<li><em>Parameter Decorators</em>, followed by <em>Method</em>, <em>Accessor</em>, or <em>Property Decorators</em> are applied for each instance member.</li>\n<li><em>Parameter Decorators</em>, followed by <em>Method</em>, <em>Accessor</em>, or <em>Property Decorators</em> are applied for each static member.</li>\n<li><em>Parameter Decorators</em> are applied for the constructor.</li>\n<li><em>Class Decorators</em> are applied for the class.</li>\n</ol>\n<h2 id=\"class-decorators\" style=\"position:relative;\"><a href=\"#class-decorators\" aria-label=\"class decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class Decorators</h2>\n<p>A <em>Class Decorator</em> is declared just before a class declaration.\nThe class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition.\nA class decorator cannot be used in a declaration file, or in any other ambient context (such as on a <code>declare</code> class).</p>\n<p>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</p>\n<p>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</p>\n<blockquote>\n<p>NOTE  Should you choose to return a new constructor function, you must take care to maintain the original prototype.\nThe logic that applies decorators at runtime will <strong>not</strong> do this for you.</p>\n</blockquote>\n<p>The following is an example of a class decorator (<code>@sealed</code>) applied to a <code>BugReport</code> class:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n// ---cut---\n@sealed\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n</code></pre>\n<p>We can define the <code>@sealed</code> decorator using the following function declaration:</p>\n<pre><code class=\"language-ts\">function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n</code></pre>\n<p>When <code>@sealed</code> is executed, it will seal both the constructor and its prototype which would not allow the class to be sub-classed at runtime.</p>\n<p>Next we have an example of how to override the constructor to set new defaults.</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2339\n// @experimentalDecorators\nfunction reportableClassDecorator&#x3C;T extends { new (...args: any[]): {} }>(constructor: T) {\n  return class extends constructor {\n    reportingURL = \"http://www...\";\n  };\n}\n\n@reportableClassDecorator\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n\nconst bug = new BugReport(\"Needs dark mode\");\nconsole.log(bug.title); // Prints \"Needs dark mode\"\nconsole.log(bug.type); // Prints \"report\"\n\n// Note that the decorator _does not_ change the TypeScript type\n// and so the new property `reportingURL` is not known\n// to the type system:\nbug.reportingURL;\n</code></pre>\n<h2 id=\"method-decorators\" style=\"position:relative;\"><a href=\"#method-decorators\" aria-label=\"method decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Method Decorators</h2>\n<p>A <em>Method Decorator</em> is declared just before a method declaration.\nThe decorator is applied to the <em>Property Descriptor</em> for the method, and can be used to observe, modify, or replace a method definition.\nA method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a <code>declare</code> class).</p>\n<p>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</p>\n<ol>\n<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>\n<li>The name of the member.</li>\n<li>The <em>Property Descriptor</em> for the member.</li>\n</ol>\n<blockquote>\n<p>NOTE  The <em>Property Descriptor</em> will be <code>undefined</code> if your script target is less than <code>ES5</code>.</p>\n</blockquote>\n<p>If the method decorator returns a value, it will be used as the <em>Property Descriptor</em> for the method.</p>\n<blockquote>\n<p>NOTE  The return value is ignored if your script target is less than <code>ES5</code>.</p>\n</blockquote>\n<p>The following is an example of a method decorator (<code>@enumerable</code>) applied to a method on the <code>Greeter</code> class:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction enumerable(value: boolean) {\n  return function (target: any,propertyKey: string,descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value;\n  };\n}\n// ---cut---\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n</code></pre>\n<p>We can define the <code>@enumerable</code> decorator using the following function declaration:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value;\n  };\n}\n</code></pre>\n<p>The <code>@enumerable(false)</code> decorator here is a <a href=\"#decorator-factories\">decorator factory</a>.\nWhen the <code>@enumerable(false)</code> decorator is called, it modifies the <code>enumerable</code> property of the property descriptor.</p>\n<h2 id=\"accessor-decorators\" style=\"position:relative;\"><a href=\"#accessor-decorators\" aria-label=\"accessor decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Accessor Decorators</h2>\n<p>An <em>Accessor Decorator</em> is declared just before an accessor declaration.\nThe accessor decorator is applied to the <em>Property Descriptor</em> for the accessor and can be used to observe, modify, or replace an accessor’s definitions.\nAn accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a <code>declare</code> class).</p>\n<blockquote>\n<p>NOTE  TypeScript disallows decorating both the <code>get</code> and <code>set</code> accessor for a single member.\nInstead, all decorators for the member must be applied to the first accessor specified in document order.\nThis is because decorators apply to a <em>Property Descriptor</em>, which combines both the <code>get</code> and <code>set</code> accessor, not each declaration separately.</p>\n</blockquote>\n<p>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</p>\n<ol>\n<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>\n<li>The name of the member.</li>\n<li>The <em>Property Descriptor</em> for the member.</li>\n</ol>\n<blockquote>\n<p>NOTE  The <em>Property Descriptor</em> will be <code>undefined</code> if your script target is less than <code>ES5</code>.</p>\n</blockquote>\n<p>If the accessor decorator returns a value, it will be used as the <em>Property Descriptor</em> for the member.</p>\n<blockquote>\n<p>NOTE  The return value is ignored if your script target is less than <code>ES5</code>.</p>\n</blockquote>\n<p>The following is an example of an accessor decorator (<code>@configurable</code>) applied to a member of the <code>Point</code> class:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction configurable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    descriptor.configurable = value;\n  };\n}\n// ---cut---\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n\n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}\n</code></pre>\n<p>We can define the <code>@configurable</code> decorator using the following function declaration:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\">function configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n</code></pre>\n<h2 id=\"property-decorators\" style=\"position:relative;\"><a href=\"#property-decorators\" aria-label=\"property decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Property Decorators</h2>\n<p>A <em>Property Decorator</em> is declared just before a property declaration.\nA property decorator cannot be used in a declaration file, or in any other ambient context (such as in a <code>declare</code> class).</p>\n<p>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</p>\n<ol>\n<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>\n<li>The name of the member.</li>\n</ol>\n<blockquote>\n<p>NOTE  A <em>Property Descriptor</em> is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript.\nThis is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too.\nAs such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</p>\n</blockquote>\n<p>We can use this information to record metadata about the property, as in the following example:</p>\n<pre><code class=\"language-ts\">class Greeter {\n  @format(\"Hello, %s\")\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  greet() {\n    let formatString = getFormat(this, \"greeting\");\n    return formatString.replace(\"%s\", this.greeting);\n  }\n}\n</code></pre>\n<p>We can then define the <code>@format</code> decorator and <code>getFormat</code> functions using the following function declarations:</p>\n<pre><code class=\"language-ts\">import \"reflect-metadata\";\n\nconst formatMetadataKey = Symbol(\"format\");\n\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n</code></pre>\n<p>The <code>@format(\"Hello, %s\")</code> decorator here is a <a href=\"#decorator-factories\">decorator factory</a>.\nWhen <code>@format(\"Hello, %s\")</code> is called, it adds a metadata entry for the property using the <code>Reflect.metadata</code> function from the <code>reflect-metadata</code> library.\nWhen <code>getFormat</code> is called, it reads the metadata value for the format.</p>\n<blockquote>\n<p>NOTE  This example requires the <code>reflect-metadata</code> library.\nSee <a href=\"#metadata\">Metadata</a> for more information about the <code>reflect-metadata</code> library.</p>\n</blockquote>\n<h2 id=\"parameter-decorators\" style=\"position:relative;\"><a href=\"#parameter-decorators\" aria-label=\"parameter decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parameter Decorators</h2>\n<p>A <em>Parameter Decorator</em> is declared just before a parameter declaration.\nThe parameter decorator is applied to the function for a class constructor or method declaration.\nA parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a <code>declare</code> class).</p>\n<p>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</p>\n<ol>\n<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>\n<li>The name of the member.</li>\n<li>The ordinal index of the parameter in the function’s parameter list.</li>\n</ol>\n<blockquote>\n<p>NOTE  A parameter decorator can only be used to observe that a parameter has been declared on a method.</p>\n</blockquote>\n<p>The return value of the parameter decorator is ignored.</p>\n<p>The following is an example of a parameter decorator (<code>@required</code>) applied to parameter of a member of the <code>BugReport</code> class:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&#x3C;any>) {}\nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {}\n// ---cut---\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n\n  @validate\n  print(@required verbose: boolean) {\n    if (verbose) {\n      return `type: ${this.type}\\ntitle: ${this.title}`;\n    } else {\n     return this.title; \n    }\n  }\n}\n</code></pre>\n<p>We can then define the <code>@required</code> and <code>@validate</code> decorators using the following function declarations:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\n// @emitDecoratorMetadata\nimport \"reflect-metadata\";\nconst requiredMetadataKey = Symbol(\"required\");\n\nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&#x3C;Function>) {\n  let method = descriptor.value!;\n\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n</code></pre>\n<p>The <code>@required</code> decorator adds a metadata entry that marks the parameter as required.\nThe <code>@validate</code> decorator then wraps the existing <code>greet</code> method in a function that validates the arguments before invoking the original method.</p>\n<blockquote>\n<p>NOTE  This example requires the <code>reflect-metadata</code> library.\nSee <a href=\"#metadata\">Metadata</a> for more information about the <code>reflect-metadata</code> library.</p>\n</blockquote>\n<h2 id=\"metadata\" style=\"position:relative;\"><a href=\"#metadata\" aria-label=\"metadata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Metadata</h2>\n<p>Some examples use the <code>reflect-metadata</code> library which adds a polyfill for an <a href=\"https://github.com/rbuckton/ReflectDecorators\">experimental metadata API</a>.\nThis library is not yet part of the ECMAScript (JavaScript) standard.\nHowever, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</p>\n<p>You can install this library via npm:</p>\n<pre><code class=\"language-shell\">npm i reflect-metadata --save\n</code></pre>\n<p>TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators.\nTo enable this experimental support, you must set the <code>emitDecoratorMetadata</code> compiler option either on the command line or in your <code>tsconfig.json</code>:</p>\n<p><strong>Command Line</strong>:</p>\n<pre><code class=\"language-shell\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n</code></pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n</code></pre>\n<p>When enabled, as long as the <code>reflect-metadata</code> library has been imported, additional design-time type information will be exposed at runtime.</p>\n<p>We can see this in action in the following example:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @emitDecoratorMetadata\n// @experimentalDecorators\n// @strictPropertyInitialization: false\nimport \"reflect-metadata\";\n\nclass Point {\n  constructor(public x: number, public y: number) {}\n}\n\nclass Line {\n  private _start: Point;\n  private _end: Point;\n\n  @validate\n  set start(value: Point) {\n    this._start = value;\n  }\n\n  get start() {\n    return this._start;\n  }\n\n  @validate\n  set end(value: Point) {\n    this._end = value;\n  }\n\n  get end() {\n    return this._end;\n  }\n}\n\nfunction validate&#x3C;T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor&#x3C;T>) {\n  let set = descriptor.set!;\n  \n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n\n    if (!(value instanceof type)) {\n      throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);\n    }\n\n    set.call(this, value);\n  };\n}\n\nconst line = new Line()\nline.start = new Point(0, 0)\n\n// @ts-ignore\n// line.end = {}\n\n// Fails at runtime with:\n// > Invalid type, got object not Point\n</code></pre>\n<p>The TypeScript compiler will inject design-time type information using the <code>@Reflect.metadata</code> decorator.\nYou could consider it the equivalent of the following TypeScript:</p>\n<pre><code class=\"language-ts\">class Line {\n  private _start: Point;\n  private _end: Point;\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set start(value: Point) {\n    this._start = value;\n  }\n  get start() {\n    return this._start;\n  }\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set end(value: Point) {\n    this._end = value;\n  }\n  get end() {\n    return this._end;\n  }\n}\n</code></pre>\n<blockquote>\n<p>NOTE  Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</p>\n</blockquote>","headings":[{"value":"Introduction","depth":2},{"value":"Decorators","depth":2},{"value":"Decorator Factories","depth":2},{"value":"Decorator Composition","depth":2},{"value":"Decorator Evaluation","depth":2},{"value":"Class Decorators","depth":2},{"value":"Method Decorators","depth":2},{"value":"Accessor Decorators","depth":2},{"value":"Property Decorators","depth":2},{"value":"Parameter Decorators","depth":2},{"value":"Metadata","depth":2}],"frontmatter":{"permalink":"/docs/handbook/decorators.html","title":"Decorators","disable_toc":null,"handbook":null,"oneline":"TypeScript Decorators overview","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-decorators","slug":"/docs/handbook/decorators.html","repoPath":"/packages/documentation/copy/en/reference/Decorators.md","lang":"en","modifiedTime":"2021-05-31T12:14:15.532Z"}},"staticQueryHashes":[]}