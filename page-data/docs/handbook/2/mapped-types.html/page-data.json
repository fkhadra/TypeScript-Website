{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/2/mapped-types.html","result":{"data":{"markdownRemark":{"id":"0f3e51de-f90f-5c7a-b4a5-414740608560","excerpt":"When you don’t want to repeat yourself, sometimes a type needs to be based on another type. Mapped types build on the syntax for index signatures, which are…","html":"<p>When you don’t want to repeat yourself, sometimes a type needs to be based on another type.</p>\n<p>Mapped types build on the syntax for index signatures, which are used to declare the types of properties which has not been declared ahead of time:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Horse = {};\n// ---cut---\ntype OnlyBoolsAndHorses = {\n  [key: string]: boolean | Horse;\n};\n\nconst conforms: OnlyBoolsAndHorses = {\n  del: true,\n  rodney: false,\n};\n</code></pre>\n<p>A mapped type is a generic type which uses a union created <a href=\"/docs/handbook/2/indexed-access-types.html\">via a <code>keyof</code></a> to iterate through the keys of one type to create another:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type OptionsFlags&#x3C;Type> = {\n  [Property in keyof Type]: boolean;\n};\n</code></pre>\n<p>In this example, <code>OptionsFlags</code> will take all the properties from the type <code>Type</code> and change their values to be a boolean.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type OptionsFlags&#x3C;Type> = {\n  [Property in keyof Type]: boolean;\n};\n// ---cut---\ntype FeatureFlags = {\n  darkMode: () => void;\n  newUserProfile: () => void;\n};\n\ntype FeatureOptions = OptionsFlags&#x3C;FeatureFlags>;\n//   ^?\n</code></pre>\n<h3 id=\"mapping-modifiers\" style=\"position:relative;\"><a href=\"#mapping-modifiers\" aria-label=\"mapping modifiers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mapping Modifiers</h3>\n<p>There are two additional modifiers which can be applied during mapping: <code>readonly</code> and <code>?</code> which affect mutability and optionality respectively.</p>\n<p>You can remove or add these modifiers by prefixing with <code>-</code> or <code>+</code>. If you don’t add a prefix, then <code>+</code> is assumed.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// Removes 'readonly' attributes from a type's properties\ntype CreateMutable&#x3C;Type> = {\n  -readonly [Property in keyof Type]: Type[Property];\n};\n\ntype LockedAccount = {\n  readonly id: string;\n  readonly name: string;\n};\n\ntype UnlockedAccount = CreateMutable&#x3C;LockedAccount>;\n//   ^?\n</code></pre>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// Removes 'optional' attributes from a type's properties\ntype Concrete&#x3C;Type> = {\n  [Property in keyof Type]-?: Type[Property];\n};\n\ntype MaybeUser = {\n  id: string;\n  name?: string;\n  age?: number;\n};\n\ntype User = Concrete&#x3C;MaybeUser>;\n//   ^?\n</code></pre>\n<h2 id=\"key-remapping-via-as\" style=\"position:relative;\"><a href=\"#key-remapping-via-as\" aria-label=\"key remapping via as permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Key Remapping via <code>as</code></h2>\n<p>In TypeScript 4.1 and onwards, you can re-map keys in mapped types with an <code>as</code> clause in a mapped type:</p>\n<pre><code class=\"language-ts\">type MappedTypeWithNewProperties&#x3C;Type> = {\n    [Properties in keyof Type as NewKeyType]: Type[Properties]\n}\n</code></pre>\n<p>You can leverage features like <a href=\"/docs/handbook/2/template-literal-types.html\">template literal types</a> to create new property names from prior ones:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Getters&#x3C;Type> = {\n    [Property in keyof Type as `get${Capitalize&#x3C;string &#x26; Property>}`]: () => Type[Property]\n};\n\ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n\ntype LazyPerson = Getters&#x3C;Person>;\n//   ^?\n</code></pre>\n<p>You can filter out keys by producing <code>never</code> via a conditional type:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// Remove the 'kind' property\ntype RemoveKindField&#x3C;Type> = {\n    [Property in keyof Type as Exclude&#x3C;Property, \"kind\">]: Type[Property]\n};\n\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\ntype KindlessCircle = RemoveKindField&#x3C;Circle>;\n//   ^?\n</code></pre>\n<h3 id=\"further-exploration\" style=\"position:relative;\"><a href=\"#further-exploration\" aria-label=\"further exploration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Further Exploration</h3>\n<p>Mapped types work well with other features in this type manipulation section, for example here is <a href=\"/docs/handbook/2/conditional-types.html\">a mapped type using a conditional type</a> which returns either a <code>true</code> or <code>false</code> depending on whether an object has the property <code>pii</code> set to the literal <code>true</code>:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type ExtractPII&#x3C;Type> = {\n  [Property in keyof Type]: Type[Property] extends { pii: true } ? true : false;\n};\n\ntype DBFields = {\n  id: { format: \"incrementing\" };\n  name: { type: string; pii: true };\n};\n\ntype ObjectsNeedingGDPRDeletion = ExtractPII&#x3C;DBFields>;\n//   ^?\n</code></pre>","headings":[{"value":"Mapping Modifiers","depth":3},{"value":"Key Remapping via as","depth":2},{"value":"Further Exploration","depth":3}],"frontmatter":{"permalink":"/docs/handbook/2/mapped-types.html","title":"Mapped Types","disable_toc":null,"handbook":null,"oneline":"Generating types by re-using an existing type.","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Conditional Types","oneline":"Create types which act like if statements in the type system.","permalink":"/docs/handbook/2/conditional-types.html"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Template Literal Types","oneline":"Generating mapping types which change properties via template literal strings.","permalink":"/docs/handbook/2/template-literal-types.html"}}}},"pageContext":{"id":"1-mapped-types","slug":"/docs/handbook/2/mapped-types.html","repoPath":"/packages/documentation/copy/en/handbook-v2/Type Manipulation/Mapped Types.md","previousID":"5bc2de2e-11f0-5c73-8284-e7cad4f9145b","nextID":"b78ca643-8277-5efe-b4a7-94582e090edd","lang":"en","modifiedTime":"2021-05-31T12:14:15.528Z"}},"staticQueryHashes":[]}