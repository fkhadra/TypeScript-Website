{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/2/conditional-types.html","result":{"data":{"markdownRemark":{"id":"bd98f2c1-58b0-5b94-8f51-36e5fd0773db","excerpt":"At the heart of most useful programs, we have to make decisions based on input.\nJavaScript programs are no different, but given the fact that values can be…","html":"<p>At the heart of most useful programs, we have to make decisions based on input.\nJavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs.\n<em>Conditional types</em> help describe the relation between the types of inputs and outputs.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">interface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n\ntype Example1 = Dog extends Animal ? number : string;\n//   ^?\n\ntype Example2 = RegExp extends Animal ? number : string;\n//   ^?\n</code></pre>\n<p>Conditional types take a form that looks a little like conditional expressions (<code>condition ? trueExpression : falseExpression</code>) in JavaScript:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type SomeType = any;\ntype OtherType = any;\ntype TrueType = any;\ntype FalseType = any;\ntype Stuff =\n  // ---cut---\n  SomeType extends OtherType ? TrueType : FalseType;\n</code></pre>\n<p>When the type on the left of the <code>extends</code> is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).</p>\n<p>From the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not <code>Dog extends Animal</code> and pick <code>number</code> or <code>string</code>!\nBut the power of conditional types comes from using them with generics.</p>\n<p>For example, let’s take the following <code>createLabel</code> function:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">interface IdLabel {\n  id: number /* some fields */;\n}\ninterface NameLabel {\n  name: string /* other fields */;\n}\n\nfunction createLabel(id: number): IdLabel;\nfunction createLabel(name: string): NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel;\nfunction createLabel(nameOrId: string | number): IdLabel | NameLabel {\n  throw \"unimplemented\";\n}\n</code></pre>\n<p>These overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:</p>\n<ol>\n<li>If a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.</li>\n<li>We have to create three overloads: one for each case when we’re <em>sure</em> of the type (one for <code>string</code> and one for <code>number</code>), and one for the most general case (taking a <code>string | number</code>). For every new type <code>createLabel</code> can handle, the number of overloads grows exponentially.</li>\n</ol>\n<p>Instead, we can encode that logic in a conditional type:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">interface IdLabel {\n  id: number /* some fields */;\n}\ninterface NameLabel {\n  name: string /* other fields */;\n}\n// ---cut---\ntype NameOrId&#x3C;T extends number | string> = T extends number\n  ? IdLabel\n  : NameLabel;\n</code></pre>\n<p>We can then use that conditional type to simplify our overloads down to a single function with no overloads.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">interface IdLabel {\n  id: number /* some fields */;\n}\ninterface NameLabel {\n  name: string /* other fields */;\n}\ntype NameOrId&#x3C;T extends number | string> = T extends number\n  ? IdLabel\n  : NameLabel;\n// ---cut---\nfunction createLabel&#x3C;T extends number | string>(idOrName: T): NameOrId&#x3C;T> {\n  throw \"unimplemented\";\n}\n\nlet a = createLabel(\"typescript\");\n//  ^?\n\nlet b = createLabel(2.8);\n//  ^?\n\nlet c = createLabel(Math.random() ? \"hello\" : 42);\n//  ^?\n</code></pre>\n<h3 id=\"conditional-type-constraints\" style=\"position:relative;\"><a href=\"#conditional-type-constraints\" aria-label=\"conditional type constraints permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conditional Type Constraints</h3>\n<p>Often, the checks in a conditional type will provide us with some new information.\nJust like with narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constraint generics by the type we check against.</p>\n<p>For example, let’s take the following:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2536\ntype MessageOf&#x3C;T> = T[\"message\"];\n</code></pre>\n<p>In this example, TypeScript errors because <code>T</code> isn’t known to have a property called <code>message</code>.\nWe could constrain <code>T</code>, and TypeScript would no longer complain:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type MessageOf&#x3C;T extends { message: unknown }> = T[\"message\"];\n\ninterface Email {\n  message: string;\n}\n\ninterface Dog {\n  bark(): void;\n}\n\ntype EmailMessageContents = MessageOf&#x3C;Email>;\n//   ^?\n</code></pre>\n<p>However, what if we wanted <code>MessageOf</code> to take any type, and default to something like <code>never</code> if a <code>message</code> property isn’t available?\nWe can do this by moving the constraint out and introducing a conditional type:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type MessageOf&#x3C;T> = T extends { message: unknown } ? T[\"message\"] : never;\n\ninterface Email {\n  message: string;\n}\n\ninterface Dog {\n  bark(): void;\n}\n\ntype EmailMessageContents = MessageOf&#x3C;Email>;\n//   ^?\n\ntype DogMessageContents = MessageOf&#x3C;Dog>;\n//   ^?\n</code></pre>\n<p>Within the true branch, TypeScript knows that <code>T</code> <em>will</em> have a <code>message</code> property.</p>\n<p>As another example, we could also write a type called <code>Flatten</code> that flattens array types to their element types, but leaves them alone otherwise:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Flatten&#x3C;T> = T extends any[] ? T[number] : T;\n\n// Extracts out the element type.\ntype Str = Flatten&#x3C;string[]>;\n//   ^?\n\n// Leaves the type alone.\ntype Num = Flatten&#x3C;number>;\n//   ^?\n</code></pre>\n<p>When <code>Flatten</code> is given an array type, it uses an indexed access with <code>number</code> to fetch out <code>string[]</code>’s element type.\nOtherwise, it just returns the type it was given.</p>\n<h3 id=\"inferring-within-conditional-types\" style=\"position:relative;\"><a href=\"#inferring-within-conditional-types\" aria-label=\"inferring within conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inferring Within Conditional Types</h3>\n<p>We just found ourselves using conditional types to apply constraints and then extract out types.\nThis ends up being such a common operation that conditional types make it easier.</p>\n<p>Conditional types provide us with a way to infer from types we compare against in the true branch using the <code>infer</code> keyword.\nFor example, we could have inferred the element type in <code>Flatten</code> instead of fetching it out “manually” with an indexed access type:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Flatten&#x3C;Type> = Type extends Array&#x3C;infer Item> ? Item : Type;\n</code></pre>\n<p>Here, we used the <code>infer</code> keyword to declaratively introduce a new generic type variable named <code>Item</code> instead of specifying how to retrieve the element type of <code>T</code> within the true branch.\nThis frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.</p>\n<p>We can write some useful helper type aliases using the <code>infer</code> keyword.\nFor example, for simple cases, we can extract the return type out from function types:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type GetReturnType&#x3C;Type> = Type extends (...args: never[]) => infer Return\n  ? Return\n  : never;\n\ntype Num = GetReturnType&#x3C;() => number>;\n//   ^?\n\ntype Str = GetReturnType&#x3C;(x: string) => string>;\n//   ^?\n\ntype Bools = GetReturnType&#x3C;(a: boolean, b: boolean) => boolean[]>;\n//   ^?\n</code></pre>\n<p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the <em>last</em> signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare function stringOrNum(x: string): number;\ndeclare function stringOrNum(x: number): string;\ndeclare function stringOrNum(x: string | number): string | number;\n\ntype T1 = ReturnType&#x3C;typeof stringOrNum>;\n//   ^?\n</code></pre>\n<h2 id=\"distributive-conditional-types\" style=\"position:relative;\"><a href=\"#distributive-conditional-types\" aria-label=\"distributive conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Distributive Conditional Types</h2>\n<p>When conditional types act on a generic type, they become <em>distributive</em> when given a union type.\nFor example, take the following:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type ToArray&#x3C;Type> = Type extends any ? Type[] : never;\n</code></pre>\n<p>If we plug a union type into <code>ToArray</code>, then the conditional type will be applied to each member of that union.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type ToArray&#x3C;Type> = Type extends any ? Type[] : never;\n\ntype StrArrOrNumArr = ToArray&#x3C;string | number>;\n//   ^?\n</code></pre>\n<p>What happens here is that <code>StrOrNumArray</code> distributes on:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type StrArrOrNumArr =\n  // ---cut---\n  string | number;\n</code></pre>\n<p>and maps over each member type of the union, to what is effectively:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type ToArray&#x3C;Type> = Type extends any ? Type[] : never;\ntype StrArrOrNumArr =\n  // ---cut---\n  ToArray&#x3C;string> | ToArray&#x3C;number>;\n</code></pre>\n<p>which leaves us with:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type StrArrOrNumArr =\n  // ---cut---\n  string[] | number[];\n</code></pre>\n<p>Typically, distributivity is the desired behavior.\nTo avoid that behavior, you can surround each side of the <code>extends</code> keyword with square brackets.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type ToArrayNonDist&#x3C;Type> = [Type] extends [any] ? Type[] : never;\n\n// 'StrOrNumArr' is no longer a union.\ntype StrOrNumArr = ToArrayNonDist&#x3C;string | number>;\n//   ^?\n</code></pre>","headings":[{"value":"Conditional Type Constraints","depth":3},{"value":"Inferring Within Conditional Types","depth":3},{"value":"Distributive Conditional Types","depth":2}],"frontmatter":{"permalink":"/docs/handbook/2/conditional-types.html","title":"Conditional Types","disable_toc":null,"handbook":null,"oneline":"Create types which act like if statements in the type system.","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Indexed Access Types","oneline":"Using Type['a'] syntax to access a subset of a type.","permalink":"/docs/handbook/2/indexed-access-types.html"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Mapped Types","oneline":"Generating types by re-using an existing type.","permalink":"/docs/handbook/2/mapped-types.html"}}}},"pageContext":{"id":"1-conditional-types","slug":"/docs/handbook/2/conditional-types.html","repoPath":"/packages/documentation/copy/en/handbook-v2/Type Manipulation/Conditional Types.md","previousID":"bbf36692-5f42-5b37-8580-7f3c6462bcc4","nextID":"69976ebb-a11c-50cf-87aa-3b44aca7fa20","lang":"en","modifiedTime":"2021-05-31T12:14:15.528Z"}},"staticQueryHashes":[]}