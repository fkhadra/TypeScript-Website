{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/2/indexed-access-types.html","result":{"data":{"markdownRemark":{"id":"28d42fd6-00e1-5de0-b547-bdf906d89dcd","excerpt":"We can use an indexed access type to look up a specific property on another type: The indexing type is itself a type, so we can use unions, keyof, or other…","html":"<p>We can use an <em>indexed access type</em> to look up a specific property on another type:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Person = { age: number; name: string; alive: boolean };\ntype Age = Person[\"age\"];\n//   ^?\n</code></pre>\n<p>The indexing type is itself a type, so we can use unions, <code>keyof</code>, or other types entirely:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Person = { age: number; name: string; alive: boolean };\n// ---cut---\ntype I1 = Person[\"age\" | \"name\"];\n//   ^?\n\ntype I2 = Person[keyof Person];\n//   ^?\n\ntype AliveOrName = \"alive\" | \"name\";\ntype I3 = Person[AliveOrName];\n//   ^?\n</code></pre>\n<p>You’ll even see an error if you try to index a property that doesn’t exist:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2339\ntype Person = { age: number; name: string; alive: boolean };\n// ---cut---\ntype I1 = Person[\"alve\"];\n</code></pre>\n<p>Another example of indexing with an arbitrary type is using <code>number</code> to get the type of an array’s elements.\nWe can combine this with <code>typeof</code> to conveniently capture the element type of an array literal:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">const MyArray = [\n  { name: \"Alice\", age: 15 },\n  { name: \"Bob\", age: 23 },\n  { name: \"Eve\", age: 38 },\n];\n\ntype Person = typeof MyArray[number];\n//   ^?\ntype Age = typeof MyArray[number][\"age\"];\n//   ^?\n// Or\ntype Age2 = Person[\"age\"];\n//   ^?\n</code></pre>\n<p>You can only use types when indexing, meaning you can’t use a <code>const</code> to make a variable reference:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2538 2749\ntype Person = { age: number; name: string; alive: boolean };\n// ---cut---\nconst key = \"age\";\ntype Age = Person[key];\n</code></pre>\n<p>However, you can use a type alias for a similar style of refactor:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type Person = { age: number; name: string; alive: boolean };\n// ---cut---\ntype key = \"age\";\ntype Age = Person[key];\n</code></pre>","headings":[],"frontmatter":{"permalink":"/docs/handbook/2/indexed-access-types.html","title":"Indexed Access Types","disable_toc":null,"handbook":null,"oneline":"Using Type['a'] syntax to access a subset of a type.","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Typeof Type Operator","oneline":"Using the typeof operator in type contexts.","permalink":"/docs/handbook/2/typeof-types.html"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Conditional Types","oneline":"Create types which act like if statements in the type system.","permalink":"/docs/handbook/2/conditional-types.html"}}}},"pageContext":{"id":"1-indexed-access-types","slug":"/docs/handbook/2/indexed-access-types.html","repoPath":"/packages/documentation/copy/en/handbook-v2/Type Manipulation/Indexed Access Types.md","previousID":"91120abe-9a84-521e-a470-a371941ab8d3","nextID":"5bc2de2e-11f0-5c73-8284-e7cad4f9145b","lang":"en","modifiedTime":"2021-05-31T12:14:15.528Z"}},"staticQueryHashes":[]}