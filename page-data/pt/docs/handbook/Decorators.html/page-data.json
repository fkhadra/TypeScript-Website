{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/Decorators.html","result":{"data":{"markdownRemark":{"id":"aeb91629-9704-5d29-86cc-439bf470173f","excerpt":"Introdução Com a introdução das Classes no TypeScript e ES6, agora existem certos cenários que requerem recursos adicionais para dar suporte à anotação ou…","html":"<h2 id=\"introdução\" style=\"position:relative;\"><a href=\"#introdu%C3%A7%C3%A3o\" aria-label=\"introdução permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introdução</h2>\n<p>Com a introdução das Classes no TypeScript e ES6, agora existem certos cenários que requerem recursos adicionais para dar suporte à anotação ou modificação de classes e membros da classe.\nDecoradores fornecem uma maneira de adicionar anotações e uma sintaxe de metaprogramação para declarações de classe e membros.\nDecoradores são uma <a href=\"https://github.com/tc39/proposal-decorators\">proposta de estágio 2</a> para JavaScript e estão disponíveis como um recurso experimental do TypeScript.</p>\n<blockquote>\n<p>NOTA  Decoradores são um recurso experimental que podem mudar em versões futuras.</p>\n</blockquote>\n<p>Para habilitar o suporte experimental para os Decoradores, você deve habilitar a opção do compilador <code>experimentalDecorators</code> na linha de comando ou em seu <code>tsconfig.json</code>:</p>\n<p><strong>Linha de Comando</strong>:</p>\n<pre><code class=\"language-shell\">tsc --target ES5 --experimentalDecorators\n</code></pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n</code></pre>\n<h2 id=\"decoradores\" style=\"position:relative;\"><a href=\"#decoradores\" aria-label=\"decoradores permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decoradores</h2>\n<p>Um <em>Decorador</em> é um tipo especial de declaração que pode ser anexado a uma <a href=\"#decoradores-de-classes\">declaração de classe</a>, <a href=\"#decoradores-de-m%C3%A9todos\">métodos</a>, <a href=\"#decoradores-de-acessos\">acessor</a>, <a href=\"#decoradores-de-propriedades\">propriedades</a>, ou <a href=\"#decoradores-de-par%C3%A2metros\">parâmetros</a>.\nDecoradores usam a forma <code>@expressão</code>, onde <code>expressão</code> deve ser avaliada como uma função que será chamada em tempo de execução com informações sobre a declaração decorada.</p>\n<p>Por exemplo, dado o decorador <code>@selado</code>, podemos escrever a função <code>selado</code> da seguinte forma:</p>\n<pre><code class=\"language-ts\">function selado(alvo) {\n  // executa algo com o alvo...\n}\n</code></pre>\n<blockquote>\n<p>NOTA  Você pode ver um exemplo mais detalhado de um decorator em <a href=\"#decoradores-de-classes\">Decoradores de Classes</a>, abaixo</p>\n</blockquote>\n<h2 id=\"fábrica-de-decoradores\" style=\"position:relative;\"><a href=\"#f%C3%A1brica-de-decoradores\" aria-label=\"fábrica de decoradores permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fábrica de Decoradores</h2>\n<p>Se quisermos personalizar como um decorador é aplicado a uma declaração, podemos escrever uma fábrica de decoradores.\nUma <em>Fábrica de Decoradores</em> é simplesmente uma função que retorna a expressão que será chamada pelo decorador em tempo de execução.</p>\n<p>Podemos escrever uma fábrica de decoradores da seguinte maneira:</p>\n<pre><code class=\"language-ts\">function cor(valor: string) {\n  // isso é uma fábrica de decoradores\n  return function (alvo) {\n    // este é o decorador\n    // executa algo com 'alvo' e 'valor' ...\n  };\n}\n</code></pre>\n<blockquote>\n<p>NOTA  Você pode ver um exemplo mais detalhado de uma fábrica de decoradores em <a href=\"#decoradores-de-m%C3%A9todos\">Decoradores de Métodos</a>, abaixo.</p>\n</blockquote>\n<h2 id=\"composição-de-decoradores\" style=\"position:relative;\"><a href=\"#composi%C3%A7%C3%A3o-de-decoradores\" aria-label=\"composição de decoradores permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composição de Decoradores</h2>\n<p>Vários decoradores podem ser aplicados a uma declaração, como nos exemplos a seguir:</p>\n<ul>\n<li>\n<p>Em uma única linha:</p>\n<pre><code class=\"language-ts\">@f @g x\n</code></pre>\n</li>\n<li>\n<p>Em diversas linhas:</p>\n<pre><code class=\"language-ts\">@f\n@g\nx\n</code></pre>\n</li>\n</ul>\n<p>Quando vários decoradores se aplicam a uma única declaração, sua avaliação é semelhante a\n<a href=\"http://wikipedia.org/wiki/Function_composition\">composição de funções em matemática</a>. Neste modelo, ao compor as funções <em>f</em> e <em>g</em>, o composto resultante (<em>f</em> ∘ <em>g</em>)(<em>x</em>) é equivalente a <em>f</em>(<em>g</em>(<em>x</em>)).</p>\n<p>Assim, as etapas a seguir são executadas ao avaliar vários decoradores em uma única declaração no TypeScript:</p>\n<ol>\n<li>As expressões para cada decorador são avaliadas de cima para baixo.</li>\n<li>Os resultados são chamados como funções de baixo para cima.</li>\n</ol>\n<p>Se fôssemos usar <a href=\"#f%C3%A1brica-de-decoradores\">fábrica de decoradores</a>, podemos observar esta ordem de avaliação com o seguinte exemplo:</p>\n<pre><code class=\"language-ts\">function f() {\n  console.log(\"f(): avaliada\");\n  return function (\n    alvo,\n    chaveDePropriedade: string,\n    descritor: descritorDePropriedade\n  ) {\n    console.log(\"f(): chamada\");\n  };\n}\n\nfunction g() {\n  console.log(\"g(): avaliada\");\n  return function (\n    alvo,\n    chaveDePropriedade: string,\n    descritor: descritorDePropriedade\n  ) {\n    console.log(\"g(): chamada\");\n  };\n}\n\nclass C {\n  @f()\n  @g()\n  method() {}\n}\n</code></pre>\n<p>Que imprimiria esta saída no console:</p>\n<pre><code class=\"language-shell\">f(): avaliada\ng(): avaliada\ng(): chamada\nf(): chamada\n</code></pre>\n<h2 id=\"avaliação-de-decoradores\" style=\"position:relative;\"><a href=\"#avalia%C3%A7%C3%A3o-de-decoradores\" aria-label=\"avaliação de decoradores permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Avaliação de Decoradores</h2>\n<p>Há uma ordem bem definida para como os decoradores aplicados a várias declarações, dentro de uma classe, são aplicados:</p>\n<ol>\n<li><em>Decoradores de Parâmetros</em>, seguido por <em>Mêtodo</em>, <em>Decoradores de Acesso</em> ou <em>Decoradores de Propriedades</em> são aplicados para cada membro da instância.</li>\n<li><em>Decoradores de Parâmetros</em>, seguido por <em>Mêtodo</em>, <em>Decoradores de Acesso</em> ou <em>Decoradores de Propriedades</em> são aplicados para cada membro estático.</li>\n<li><em>Decoradores de Parâmetros</em> são aplicados para o construtor.</li>\n<li><em>Decoradores de classe</em> são aplicados para a classe.</li>\n</ol>\n<h2 id=\"decoradores-de-classes\" style=\"position:relative;\"><a href=\"#decoradores-de-classes\" aria-label=\"decoradores de classes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decoradores de Classes</h2>\n<p>O <em>Decorador de Classe</em> é declarado antes de uma declaração de classe.\nO decorador de classe é aplicado ao construtor da classe e pode ser usado para observar, modificar ou substituir uma definição de classe.\nUm decorador de classe não pode ser usado em um arquivo de declaração, ou em qualquer outro contexto de ambiente (como em uma classe <code>declare</code>).</p>\n<p>A expressão para o decorador de classe será chamada como uma função em tempo de execução, com o construtor da classe decorada como seu único argumento.</p>\n<p>Se o decorador da classe retornar um valor, ele substituirá a declaração da classe pela função construtora fornecida.</p>\n<blockquote>\n<p>NOTA  Se você decidir retornar uma nova função de construtor, deve tomar cuidado para manter o protótipo original.\nA lógica que aplica decoradores em tempo de execução <strong>não</strong> fará isso por você.</p>\n</blockquote>\n<p>A seguir está um exemplo de um decorador de classe (<code>@selada</code>) aplicado a classe <code>Recepcionista</code></p>\n<pre><code class=\"language-ts\">@selada\nclass Recepcionista {\n  recepcionista: string;\n  constructor(mensagem: string) {\n    this.cumprimento = mensagem;\n  }\n  cumprimentar() {\n    return \"Olá, \" + this.cumprimento;\n  }\n}\n</code></pre>\n<p>Podemos definir o decorador <code>@selado</code> usando a seguinte declaração de função:</p>\n<pre><code class=\"language-ts\">function selado(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n</code></pre>\n<p>Quando <code>@selado</code> é executado, ele irá selar o construtor e seu protótipo.</p>\n<p>A seguir, temos um exemplo de como substituir o construtor.</p>\n<pre><code class=\"language-ts\">function decoradorDeClasse&#x3C;T extends { new (...args: any[]): {} }>(\n  constructor: T\n) {\n  return class extends constructor {\n    novaPropriedade = \"nova propriedade\";\n    ola = \"sobrepor\";\n  };\n}\n\n@decoradorDeClasse\nclass Recepcionista {\n  propriedade = \"propriedade\";\n  ola: string;\n  constructor(m: string) {\n    this.ola = m;\n  }\n}\n\nconsole.log(new Recepcionista(\"mundo\"));\n</code></pre>\n<h2 id=\"decoradores-de-métodos\" style=\"position:relative;\"><a href=\"#decoradores-de-m%C3%A9todos\" aria-label=\"decoradores de métodos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decoradores de Métodos</h2>\n<p>Um <em>Decorador de Método</em> é declarado imediatamente antes de uma declaração de método.\nO decorador é aplicado ao <em>Descritor de Propriedade</em> para o método e pode ser usado para observar, modificar ou substituir uma definição de método.\nUm decorador de método não pode ser usado em um arquivo de declaração, em uma sobrecarga ou em qualquer outro contexto de ambiente (como em uma classe <code>declare</code>).</p>\n<p>A expressão para o decorador de método será chamada como uma função em tempo de execução, com os três argumentos a seguir:</p>\n<ol>\n<li>A função construtora da classe para um membro estático ou o protótipo da classe para um membro de instância.</li>\n<li>O nome do membro</li>\n<li>O <em>Descritor de Propriedade</em> para o membro.</li>\n</ol>\n<blockquote>\n<p>NOTA  O <em>Descritor de Propriedade</em> será <code>indefinido</code> se o destino do seu script for menor que <code>ES5</code>.</p>\n</blockquote>\n<p>Se o decorador do método retornar um valor, ele será usado como o <em>Descritor de Propriedade</em> para o método.</p>\n<blockquote>\n<p>NOTA  O valor de retorno é ignorado se o destino do script for menor que <code>ES5</code>.</p>\n</blockquote>\n<p>A seguir está um exemplo de um decorador de método (<code>@enumeravel</code>) aplicado a um método na classe <code>Recepcionista</code>:</p>\n<pre><code class=\"language-ts\">class Recepcionista {\n  recepcionista: string;\n  constructor(mensagem: string) {\n    this.recepcionista = mensagem;\n  }\n\n  @enumeravel(false)  \n  cumprimentar() {\n    return \"Olá, \" + this.recepcionista;\n  }\n}\n</code></pre>\n<p>Podemos definir o decorador <code>@enumeravel</code> usando a seguinte declaração de função:</p>\n<pre><code class=\"language-ts\">function enumeravel(valor: boolean) {\n  return function (\n    alvo: any,\n    chaveDePropriedade: string,\n    descritor: DescritorDePropriedade\n  ) {\n    descritor.enumeravel = valor;\n  };\n}\n</code></pre>\n<p>O decorador <code>@enumeravel(false)</code> aqui é uma <a href=\"#f%C3%A1brica-de-decoradores\">fábrica de decoradores</a>.\nQuando o decorador <code>@enumeravel(false)</code> é chamado, ele modifica a propriedade <code>enumeravel</code> do descritor de propriedade.</p>\n<h2 id=\"decoradores-de-acesso\" style=\"position:relative;\"><a href=\"#decoradores-de-acesso\" aria-label=\"decoradores de acesso permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decoradores de Acesso</h2>\n<p>Um <em>Decorador de Acesso</em> é declarado antes de uma declaração de acesso.\nO Decorador de Acesso é aplicado ao <em>Descritor de Propriedades</em> do acessador e pode ser usado para observar, modificar ou substituir as definições de um acesso.\nUm Decorador de Acesso não pode ser usado em um arquivo de declaração ou em qualquer outro contexto de ambiente (como em uma classe <code>declare</code>).</p>\n<blockquote>\n<p>NOTA  O TypeScript não permite decorar os acessadores <code>get</code> e<code>set</code> para um único membro.\nEm vez disso, todos os decoradores do membro devem ser aplicados ao primeiro acessador especificado na ordem do documento.\nIsso ocorre porque os decoradores se aplicam a um <em>Descritor de Propriedades</em>, que combina os acessadores <code>get</code> e <code>set</code>, não a cada declaração separadamente.</p>\n</blockquote>\n<p>A expressão para o Decorador de Acesso será chamada como uma função em tempo de execução, com os três seguintes argumentos:</p>\n<ol>\n<li>A função construtora da classe para um membro estático ou o protótipo da classe para um membro de instância.</li>\n<li>O nome do membro.</li>\n<li>O <em>Descritor de Propriedade</em> do membro.</li>\n</ol>\n<blockquote>\n<p>NOTA  O <em>Descriptor de Propriedade</em> será <code>undefined</code> se o destino do seu script for menor que <code>ES5</code>.</p>\n</blockquote>\n<p>Se o Decorador de Acesso retornar um valor, ele será usado como o <em>Descritor de Propriedade</em> para o membro.</p>\n<blockquote>\n<p>NOTA  O valor de retorno é ignorado se o destino do script for menor que <code>ES5</code>.</p>\n</blockquote>\n<p>A seguir está um exemplo de um Decorador de Acesso (<code>@configuravel</code>) aplicado a um membro da classe <code>Ponto</code>:</p>\n<pre><code class=\"language-ts\">class Ponto {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  @configuravel(false)\n  get x() {\n    return this._x;\n  }\n\n  @configuravel(false)\n  get y() {\n    return this._y;\n  }\n}\n</code></pre>\n<p>Podemos definir o decorador <code>@configuravel</code> usando a seguinte declaração de função:</p>\n<pre><code class=\"language-ts\">function configuravel(valor: boolean) {\n  return function (\n    alvo: any,\n    chaveDePropriedade: string,\n    descritor: DescritorDePropriedade\n  ) {\n    descritor.configurable = valor;\n  };\n}\n</code></pre>\n<h2 id=\"decoradores-de-propriedades\" style=\"position:relative;\"><a href=\"#decoradores-de-propriedades\" aria-label=\"decoradores de propriedades permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decoradores de Propriedades</h2>\n<p>Um <em>Decorador de Propriedade</em> é declarado antes de uma declaração de propriedade.\nUm decorador de propriedade não pode ser usado em um arquivo de declaração ou em qualquer outro contexto de ambiente (como em uma classe <code>declare</code>).</p>\n<p>A expressão para o Decorador de Propriedade será chamada como uma função em tempo de execução, com os dois argumentos a seguir:</p>\n<ol>\n<li>A função construtora da classe para um membro estático ou o protótipo da classe para um membro de instância.</li>\n<li>O nome do membro.</li>\n</ol>\n<blockquote>\n<p>NOTA  Um <em>Descritor de Propriedade</em> não é fornecido como um argumento para um decorador de propriedade devido a como os decoradores de propriedade são inicializados no TypeScript.\nIsso ocorre porque não existe atualmente nenhum mecanismo para descrever uma propriedade de instância ao definir membros de um protótipo e nenhuma maneira de observar ou modificar o inicializador de uma propriedade. O valor de retorno também é ignorado.\nDessa forma, um decorador de propriedade só pode ser usado para observar que uma propriedade de um nome específico foi declarada para uma classe.</p>\n</blockquote>\n<p>Podemos usar essas informações para registrar metadados sobre a propriedade, como no exemplo a seguir:</p>\n<pre><code class=\"language-ts\">class Recepcionista {\n  @formato(\"Olá, %s\")\n  cumprimento: string;\n\n  constructor(mensagem: string) {\n    this.cumprimento = mensagem;\n  }\n  cumprimentar() {\n    let formatoString = obterFormato(this, \"cumprimento\");\n    return formatoString.replace(\"%s\", this.cumprimento);\n  }\n}\n</code></pre>\n<p>Podemos então definir o decorador <code>@formato</code> e as funções <code>obterFormato</code> usando as seguintes declarações de função:</p>\n<pre><code class=\"language-ts\">import \"reflect-metadata\";\n\nconst formatoMetadataKey = Symbol(\"format\");\n\nfunction formato(formatoString: string) {\n  return Reflect.metadata(formatoMetadataKey, formatoString);\n}\n\nfunction obterFormato(alvo: any, chaveDePropriedade: string) {\n  return Reflect.getMetadata(formatoMetadataKey, alvo, chaveDePropriedade);\n}\n</code></pre>\n<p>O decorador <code>@formato (\" Olá,% s \")</code> aqui é uma <a href=\"#f%C3%A1brica-de-decoradores\">fábrica de decoradores</a>.\nQuando <code>@formato (\" Olá,% s \")</code> é chamado, ele adiciona uma entrada de metadados para a propriedade usando a função <code>Reflect.metadata</code> da biblioteca<code>reflet-metadata</code>.\nQuando <code>obterFormato</code> é chamado, ele lê o valor dos metadados para o formato.</p>\n<blockquote>\n<p>NOTA  Este exemplo requer a biblioteca <code>reflect-metadata</code>.\nVeja <a href=\"#metadados\">Metadados</a> para mais informações sobre a biblioteca <code>reflet-metadata</code>.</p>\n</blockquote>\n<h2 id=\"decoradores-de-parâmetros\" style=\"position:relative;\"><a href=\"#decoradores-de-par%C3%A2metros\" aria-label=\"decoradores de parâmetros permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decoradores de Parâmetros</h2>\n<p>Um <em>Decorador de Parâmetro</em> é declarado antes de uma declaração de parâmetro.\nO decorador de parâmetro é aplicado à função para um construtor de classe ou declaração de método.\nUm decorador de parâmetro não pode ser usado em um arquivo de declaração, uma sobrecarga ou em qualquer outro contexto de ambiente (como em uma classe <code>declare</code>).</p>\n<p>A expressão para o decorador de parâmetro será chamada como uma função em tempo de execução, com os três argumentos a seguir:</p>\n<ol>\n<li>A função construtora da classe para um membro estático ou o protótipo da classe para um membro de instância.</li>\n<li>O nome do membro.</li>\n<li>O índice ordinal do parâmetro na lista de parâmetros da função.</li>\n</ol>\n<blockquote>\n<p>NOTA  Um decorador de parâmetro só pode ser usado para observar que um parâmetro que foi declarado em um método.</p>\n</blockquote>\n<p>O valor de retorno do decorador de parâmetro é ignorado.</p>\n<p>A seguir está um exemplo de um decorador de parâmetro (<code>@obrigatorio</code>) aplicado ao parâmetro de um membro da classe <code>Recepcionista</code>:</p>\n<pre><code class=\"language-ts\">class Recepcionista {\n  cumprimento: string;\n\n  constructor(mensagem: string) {\n    this.cumprimento = mensagem;\n  }\n\n  @validar\n  cumprimentar(@obrigatorio nome: string) {\n    return \"Olá \" + nome + \", \" + this.cumprimento;\n  }\n}\n</code></pre>\n<p>Podemos então definir os decoradores <code>@obrigatorio</code> e<code>@validar</code> usando as seguintes declarações de função:</p>\n<pre><code class=\"language-ts\">import \"reflect-metadata\";\n\nconst chaveDeMetodosNecessaria = Symbol(\"obrigatorio\");\n\nfunction obrigatorio(\n  alvo: Object,\n  chaveDePropriedade: string | symbol,\n  indiceDeParametro: number\n) {\n  let parametrosNecessariosExistentes: number[] =\n    Reflect.getOwnMetadata(chaveDeMetodosNecessaria, alvo, chaveDePropriedade) || [];\n  parametrosNecessariosExistentes.push(indiceDeParametro);\n  Reflect.defineMetadata(\n    chaveDeMetodosNecessaria,\n    parametrosNecessariosExistentes,\n    alvo,\n    chaveDePropriedade\n  );\n}\n\nfunction validar(\n  alvo: any,\n  nomeDaPropriedade: string,\n  descritor: DescritorDePropriedadeTipada&#x3C;Function>\n) {\n  let método = descritor.value;\n  descritor.value = function () {\n    let parametrosObrigatorios: number[] = Reflect.getOwnMetadata(\n      chaveDeMetodosNecessaria,\n      alvo,\n      nomeDaPropriedade\n    );\n    if (parametrosObrigatorios) {\n      for (let indiceDeParametro of parametrosObrigatorios) {\n        if (\n          indiceDeParametro >= arguments.length ||\n          arguments[indiceDeParametro] === undefined\n        ) {\n          throw new Error(\"Argumento obrigatório ausente.\");\n        }\n      }\n    }\n    \n    return method.apply(this, arguments);\n  };\n}\n</code></pre>\n<p>O decorador <code>@obrigatorio</code> adiciona uma entrada de metadados que marca o parâmetro como necessário.\nO decorador <code>@validar</code> então envolve o método<code>cumprimentar</code> existente em uma função que valida os argumentos antes de invocar o método original.</p>\n<blockquote>\n<p>NOTA  Este exemplo requer a biblioteca <code>reflect-metadata</code>.\nVeja <a href=\"#metadados\">Metadados</a> para mais informações sobre a biblioteca <code>reflet-metadata</code>.</p>\n</blockquote>\n<h2 id=\"metadados\" style=\"position:relative;\"><a href=\"#metadados\" aria-label=\"metadados permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Metadados</h2>\n<p>Alguns exemplos usam a biblioteca <code>reflet-metadata</code> que adiciona um polyfill para uma <a href=\"https://github.com/rbuckton/ReflectDecorators\">API de metadados experimental</a>.\nEsta biblioteca ainda não faz parte do padrão ECMAScript (JavaScript).\nNo entanto, assim que decoradores forem oficialmente adotados como parte do padrão ECMAScript, essas extensões serão propostas para adoção.</p>\n<p>Você pode instalar esta biblioteca via npm:</p>\n<pre><code class=\"language-shell\">npm i reflect-metadata --save\n</code></pre>\n<p>O TypeScript inclui suporte experimental para a emissão de certos tipos de metadados para declarações que possuem decoradores.\nPara habilitar este suporte experimental, você deve definir a opção do compilador <code>emitDecoratorMetadata</code> na linha de comando ou em seu<code>tsconfig.json</code>:</p>\n<p><strong>Linha de Comando</strong>:</p>\n<pre><code class=\"language-shell\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n</code></pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n</code></pre>\n<p>Quando habilitado, contanto que a biblioteca <code>reflet-metadata</code> tenha sido importada, informações adicionais de tipo de tempo de design serão expostas no tempo de execução.</p>\n<p>Podemos ver isso em ação no seguinte exemplo:</p>\n<pre><code class=\"language-ts\">import \"reflect-metadata\";\n\nclass Ponto {\n  x: number;\n  y: number;\n}\n\nclass Linha {\n  private _p0: Ponto;\n  private _p1: Ponto;\n\n  @validar\n  set p0(valor: Ponto) {\n    this._p0 = valor;\n  }\n  get p0() {\n    return this._p0;\n  }\n\n  @validar\n  set p1(valor: Ponto) {\n    this._p1 = valor;\n  }\n  get p1() {\n    return this._p1;\n  }\n}\n\nfunction validar&#x3C;T>(\n  alvo: any,\n  chaveDePropriedade: string,\n  descritor: DescritorDePropriedadeTipada&#x3C;T>\n) {\n  let set = descritor.set;\n  descritor.set = function (valor: T) {\n    let type = Reflect.getMetadata(\"design:type\", alvo, chaveDePropriedade);\n    if (!(valor instanceof type)) {\n      throw new TypeError(\"Tipo inválido.\");\n    }\n    set.call(alvo, valor);\n  };\n}\n</code></pre>\n<p>O compilador TypeScript injetará informações de tipo em tempo de design usando o decorador <code>@Reflect.metadata</code>.\nVocê pode considerá-lo o equivalente ao seguinte TypeScript:</p>\n<pre><code class=\"language-ts\">class Linha {\n  private _p0: Ponto;\n  private _p1: Ponto;\n\n  @validar\n  @Reflect.metadata(\"design:type\", Ponto)\n  set p0(valor: Ponto) {\n    this._p0 = valor;\n  }\n  get p0() {\n    return this._p0;\n  }\n\n  @validar\n  @Reflect.metadata(\"design:type\", Ponto)\n  set p1(valor: Ponto) {\n    this._p1 = valor;\n  }\n  get p1() {\n    return this._p1;\n  }\n}\n</code></pre>\n<blockquote>\n<p>NOTA  Os metadados do Decorator são um recurso experimental e podem apresentar alterações importantes em versões futuras.</p>\n</blockquote>","headings":[{"value":"Introdução","depth":2},{"value":"Decoradores","depth":2},{"value":"Fábrica de Decoradores","depth":2},{"value":"Composição de Decoradores","depth":2},{"value":"Avaliação de Decoradores","depth":2},{"value":"Decoradores de Classes","depth":2},{"value":"Decoradores de Métodos","depth":2},{"value":"Decoradores de Acesso","depth":2},{"value":"Decoradores de Propriedades","depth":2},{"value":"Decoradores de Parâmetros","depth":2},{"value":"Metadados","depth":2}],"frontmatter":{"permalink":"/pt/docs/handbook/Decorators.html","title":"Decoradores","disable_toc":null,"handbook":null,"oneline":"Visão geral dos Decoradores no TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-decoradores","slug":"/pt/docs/handbook/Decorators.html","repoPath":"/packages/documentation/copy/pt/reference/Decorators.md","lang":"pt","modifiedTime":"2021-05-31T12:18:20.879Z"}},"staticQueryHashes":[]}