{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/type-compatibility.html","result":{"data":{"markdownRemark":{"id":"9d96e1cc-4cd4-59f7-87a8-71b39fe5bd98","excerpt":"Compatibilidade de tipos no Typescript é baseado em subtipagem estrutural.\nTipagem estrutural é um forma de relacionar tipos baseado exclusivamente em seus…","html":"<p>Compatibilidade de tipos no Typescript é baseado em subtipagem estrutural.\nTipagem estrutural é um forma de relacionar tipos baseado exclusivamente em seus membros.\nIsso vai de encontro com a tipagem nominal.\nConsidere o código a seguir:</p>\n<pre><code class=\"language-ts\">interface Nomeado {\n  nome: string;\n}\n\nclass Pessoa {\n  nome: string;\n}\n\nlet p: Nomeado;\n// OK, por causa da tipagem estrutural\np = new Pessoa();\n</code></pre>\n<p>Em linguagens nominalmente tipadas como C# ou Java, o código equivalente seria um erro porque a classe <code>Pessoa</code> não se descreve explícitamente como sendo um implementador da interface <code>Nomeado</code>.</p>\n<p>O sistema de tipagem estrutural TypeScript foi projetado baseado em como o código Javascript é tipicamente escrito.\nPor que o Javascript faz uso amplo de objetos anônimos como funções de expressões e literais de objetos, é muito mais natural representar os tipos de relacionamentos encontrados em bibliotecas JavaScript com um sistema de tipo estrutural do que um tipo nominal.</p>\n<h2 id=\"uma-nota-sobre-solidez\" style=\"position:relative;\"><a href=\"#uma-nota-sobre-solidez\" aria-label=\"uma nota sobre solidez permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Uma nota sobre Solidez</h2>\n<p>O sistema de tipos TypeScript permite certas operações, que não poderiam ser conhecidas em tempo de compilação, a serem seguras.\nQuando um sistema de tipos tem essa propriedade, fica dito não ser “sólido” (<em>sound</em>). Os locais onde Typescript permite comportamento não sólido foram considerados cuidadosamente, e ao decorrer desse documento iremos explicar onde eles ocorrem e os cenários motivadores por trás deles. </p>\n<h2 id=\"começando\" style=\"position:relative;\"><a href=\"#come%C3%A7ando\" aria-label=\"começando permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Começando</h2>\n<p>A regra básica para tipagem estrutural do TypeScript é que <code>x</code> é compatível com <code>y</code> se <code>y</code> tem ao menos o mesmo numero de membros de <code>x</code>. Por exemplo:</p>\n<pre><code class=\"language-ts\">interface Nomeado {\n  nome: string;  \n}\n\nlet x: Nomeado;\n// o tipo inferido de y é { nome: string; localizacao: string; }\nlet y = { nome: \"Alice\", localizacao: \"Acre\" };\nx = y;\n</code></pre>\n<p>Para verificar quando <code>y</code> pode ser atribuído a <code>x</code>, o compilador checa cada propriedade de <code>x</code> para encontrar uma propriedade compatível em  <code>y</code>.\nNesse caso, <code>y</code> precisa ter um membro chamado <code>nome</code> que é uma string. Tendo feito, então a atribuição é permitida.</p>\n<p>A mesma regra para atribuição é usada ao verificar chamadas dos argumentos da função:</p>\n<pre><code class=\"language-ts\">function cumprimenta(n: Nomeado) {\n  console.log(\"Olá, \" + n.nome);\n}\ncumprimenta(y); // OK\n</code></pre>\n<p>Perceba que <code>y</code> tem uma propriedade <code>localizacao</code> extra, mas isso não cria um erro.\nApenas membros do tipo alvo (<code>Nomeado</code> nesse caso) são considerados ao checar por compatibilidade.</p>\n<p>Esse processo de comparação ocorre recursivamente, explorando o tipo de cada membro e sub-membro.</p>\n<h2 id=\"comparando-duas-funções\" style=\"position:relative;\"><a href=\"#comparando-duas-fun%C3%A7%C3%B5es\" aria-label=\"comparando duas funções permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Comparando duas funções</h2>\n<p>Enquanto comparar tipos primitivos é relativamente simples, a questão de quais tipos de funções deveriam ser consideradas compatíveis é um pouco mais difícil. Vamos começar com um exemplo básico de duas funções que diferem apenas em sua lista de parâmetros:</p>\n<pre><code class=\"language-ts\">let x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // OK\nx = y; // Erro\n</code></pre>\n<p>Para verificar se <code>x</code> é atribuível a <code>y</code>, primeiro olhamos a lista de parâmetros.\nCada parâmetro em <code>x</code> precisa ter um parâmetro correspondente em <code>y</code>com um tipo compatível.\nPerceba que o nome dos parâmetros não são considerados, apenas seus tipos.\nNesse caso, cada parâmetro de <code>x</code> tem um parâmetro correspondente compatível em <code>y</code>, então a atribuição é permitida.</p>\n<p>A segunda atribuição é um erro, porque <code>y</code> tem um segundo parâmetro requerido que <code>x</code> não tem, então a atribuição não é permitida.</p>\n<p>Você pode estar se perguntando por quê permitimos parâmetros ‘descartáveis’ como no exemplo <code>y = x</code>.\nO motivo para essa atribuição ser permitida é que, ignorar parâmetros extras de funções, na verdade, é bem comum no JavaScript.\nPor exemplo, <code>Array#forEach</code> provém tres parâmetros para a função de callback: os elementos do array, seus index e o array.\nMesmo assim, é muito útil prover um callback que usa apenas o primeiro parâmetro:</p>\n<pre><code class=\"language-ts\">let itens = [1, 2, 3];\n\n// Não força esses parâmetros extras\nitens.forEach((item, index, array) => console.log(item));\n\n// Deveria ser OK!\nitens.forEach((item) => console.log(item));\n</code></pre>\n<p>Agora vamos olhar como os tipos retornados são tratados usando duas funções que diferem apenas em seu tipo retornado:</p>\n<pre><code class=\"language-ts\">let x = () => ({ nome: \"Alice\" });\nlet y = () => ({ nome: \"Alice\", localizacao: \"Acre\" });\n\nx = y; // OK\ny = x; // Erro, porque falta a propriedade localizacao em x()\n</code></pre>\n<p>O sistema de tipos força que o retorno da função fonte seja um subtipo do tipo retornado da função alvo.</p>\n<h2 id=\"parâmetro-de-função-bivariado\" style=\"position:relative;\"><a href=\"#par%C3%A2metro-de-fun%C3%A7%C3%A3o-bivariado\" aria-label=\"parâmetro de função bivariado permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parâmetro de Função Bivariado</h2>\n<p>Ao comparar os tipos de parâmetros de funções, a atribuição tem sucesso se o parâmetro fonte é atribuível ao parâmetro alvo, ou vice versa.\nIsso é não sólido pois pode ser dada a uma função chamadora uma função que retorna um tipo mais especializado, mas invoca a função com um tipo menos especializado.\nNa pratica, esse tipo de erro é raro, e permitir esse comportamento viabiliza muitos padrões comuns do JavaScript. Um exemplo breve:</p>\n<pre><code class=\"language-ts\">enum EventType {\n  Mouse,\n  Keyboard,\n}\n\ninterface Event {\n  timestamp: number;\n}\ninterface MouseEvent extends Event {\n  x: number;\n  y: number;\n}\ninterface KeyEvent extends Event {\n  keyCode: number;\n}\n\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n  /* ... */\n}\n\n// Não sólido, mas útil e comum\nlistenEvent(EventType.Mouse, (e: MouseEvent) => console.log(e.x + \",\" + e.y));\n\n// Alternativas indesejáveis na presença de solidez\nlistenEvent(EventType.Mouse, (e: Event) =>\n  console.log((e as MouseEvent).x + \",\" + (e as MouseEvent).y)\n);\nlistenEvent(EventType.Mouse, ((e: MouseEvent) =>\n  console.log(e.x + \",\" + e.y)) as (e: Event) => void);\n\n// Ainda não permitido (erro claro). Segurança de tipos forçada para tipos completamente incompatíveis\nlistenEvent(EventType.Mouse, (e: number) => console.log(e));\n</code></pre>\n<p>Você pode ter o TypeScript lançando erros quando isso acontece pela marcação do compilador <code>strictFunctionTypes</code>.</p>\n<h2 id=\"parâmetros-opcionais-e-parâmetros-rest\" style=\"position:relative;\"><a href=\"#par%C3%A2metros-opcionais-e-par%C3%A2metros-rest\" aria-label=\"parâmetros opcionais e parâmetros rest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parâmetros Opcionais e Parâmetros Rest</h2>\n<p>Ao comparar funções para compatibilidade, parâmetros opcionais e requeridos são intercambiáveis.\nParâmetros opcionais extras do tipo fonte não são um erro e parâmetros opcionais do tipo alvo, sem parâmetros correspondentes no tipo fonte, não são um erro.</p>\n<p>Quando uma função tem um parâmetro do tipo rest, ela é tratada como se tivesse uma série infinita de parâmetros opcionais.</p>\n<p>Isso não sólido pela perspectiva do sistema de tipos, mas pelo ponto de vista do tempo de execução a ideia de um parâmetro opcional é geralmente reforçada, uma vez que é o equivalente a passar <code>undefined</code> naquela posição para a maioria das funções.</p>\n<p>O exemplo motivacional é o padrão comum de uma função que recebe um callback e a chama com alguma previsibilidade (para o programador) mas com numero desconhecido (para o sistema de tipos) de argumentos:</p>\n<pre><code class=\"language-ts\">function chamaDepois(args: any[], callback: (...args: any[]) => void) {\n  /* ... Chama callback com 'args' ... */\n}\n\n// Não sólido - chamaDepois \"poderia\" prover qualquer numero de argumentos\nchamaDepois([1, 2], (x, y) => console.log(x + \", \" + y));\n\n// Confuso (x e y, na verdade, são requeridos ) e indetectáveis\nchamaDepois([1, 2], (x?, y?) => console.log(x + \", \" + y));\n</code></pre>\n<h2 id=\"funções-com-sobrecarga\" style=\"position:relative;\"><a href=\"#fun%C3%A7%C3%B5es-com-sobrecarga\" aria-label=\"funções com sobrecarga permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Funções com sobrecarga</h2>\n<p>Quando uma função tem sobrecarga, cada sobrecarga no tipo fonte deve combinar com uma assinatura compatível no tipo alvo.\nIsso assegura que a função alvo pode ser chamada nas mesmas situações da função fonte.</p>\n<h2 id=\"enums\" style=\"position:relative;\"><a href=\"#enums\" aria-label=\"enums permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Enums</h2>\n<p>Enums são compatíveis com números e números são compatíveis com enums. Valores de Enum de tipos de enum diferentes são considerados incompatíveis. Por Exemplo,</p>\n<pre><code class=\"language-ts\">enum Status {\n  Pronto,\n  Esperando,\n}\nenum Cor {\n  Vermelho,\n  Azul,\n  Verde,\n}\n\nlet status = Status.Pronto;\nstatus = Cor.Verde; // Erro\n</code></pre>\n<h2 id=\"classes\" style=\"position:relative;\"><a href=\"#classes\" aria-label=\"classes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Classes</h2>\n<p>Classes funcionam de forma similar a tipos literais de objetos e interfaces, com uma exceção: Ambos tem um tipo estático e de instancia.\nAo comparar dois objetos de um tipo de classe, apenas membros da instancia são comparados.\nMembros estáticos e construtores não afetam a compatibilidade.</p>\n<pre><code class=\"language-ts\">class Animal {\n  patas: number;\n  constructor(nome: string, numPatas: number) {}\n}\n\nclass Tamanho {\n  patas: number;\n  constructor(numPatas: number) {}\n}\n\nlet a: Animal;\nlet s: Tamanho;\n\na = s; // OK\ns = a; // OK\n</code></pre>\n<h2 id=\"membros-privados-e-protegidos-em-classes\" style=\"position:relative;\"><a href=\"#membros-privados-e-protegidos-em-classes\" aria-label=\"membros privados e protegidos em classes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Membros privados e protegidos em classes</h2>\n<p>Membros privados e protegidos em uma classe afetam sua compatibilidade.\nQuando a compatibilidade de uma instancia de classe é verificada, se o tipo alvo contem um membro privado, então o tipo fonte também precisa conter um membro privado que se originou da mesma classe.\nDe forma semelhante, o mesmo se aplica para uma instancia com um membro protegido.\nIsso permite manter a compatibilidade de atribuição com a sua classe super, mas <em>não</em> com classes de hierarquias de heranças diferentes que, de outra forma, possuem a mesma estrutura.</p>\n<h2 id=\"generics\" style=\"position:relative;\"><a href=\"#generics\" aria-label=\"generics permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generics</h2>\n<p>Porquê TypeScript é um sistema de tipo estrutural, tipo dos parâmetros apenas afetam o tipo resultante quando consumidos como parte do tipo de um membro. Por Exemplo,</p>\n<pre><code class=\"language-ts\">interface Empty&#x3C;T> {}\nlet x: Empty&#x3C;number>;\nlet y: Empty&#x3C;string>;\n\nx = y; // OK, porque y combina com a estrutura de x\n</code></pre>\n<p>No exemplo acima, <code>x</code> e <code>y</code> são compatíveis porque suas estruturas não usam o argumento de tipo de forma diferenciativa.\nModificando esse exemplo adicionando um membro a <code>Empty&#x3C;T></code> mostra como isso funciona: </p>\n<pre><code class=\"language-ts\">interface NaoVazio&#x3C;T> {\n  data: T;\n}\nlet x: NaoVazio&#x3C;number>;\nlet y: NaoVazio&#x3C;string>;\n\nx = y; // Erro, porque x e y não são compatíveis\n</code></pre>\n<p>Dessa forma, um tipo genérico que tem os seus tipos de argumentos especificados age como um tipo não genérico.</p>\n<p>Para tipos genéricos que nao tem seus tipos de argumentos especificados, a compatibilidade é verificada especificando <code>any</code> no lugar de todos os tipos de argumentos não especificados.\nA compatibilidade dos tipos resultantes é então verificada, assim como no caso dos tipos não genéricos.</p>\n<p>Por exemplo,</p>\n<pre><code class=\"language-ts\">let identidade = function &#x3C;T>(x: T): T {\n  // ...\n};\n\nlet reverter = function &#x3C;U>(y: U): U {\n  // ...\n};\n\nidentidade = reverter; // OK, porque (x: any) => any bate com (y: any) => any\n</code></pre>\n<h2 id=\"tópicos-avançados\" style=\"position:relative;\"><a href=\"#t%C3%B3picos-avan%C3%A7ados\" aria-label=\"tópicos avançados permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tópicos avançados</h2>\n<h2 id=\"subtipos-vs-atribuições\" style=\"position:relative;\"><a href=\"#subtipos-vs-atribui%C3%A7%C3%B5es\" aria-label=\"subtipos vs atribuições permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Subtipos vs Atribuições</h2>\n<p>Até aqui, temos usado “compatível”, que não é um termo definido nas especificações da linguagem.\nEm TypeScript, existem dois tipos de compatibilidade: subtipos e atribuições.\nEles diferem apenas no fato de que a atribuição estende a compatibilidade do subtipo com regras para permitir a atribuição de e para <code>enum</code> com valores numéricos correspondentes. </p>\n<p>Diferentes locais na linguagem usam um dos dois tipos de mecanismos de compatibilidade, dependendo da situação.\nPara fins práticos, compatibilidade de tipos é ditada pela compatibilidade de atribuição, mesmo no casos das clausulas <code>implements</code> e <code>extends</code>.</p>","headings":[{"value":"Uma nota sobre Solidez","depth":2},{"value":"Começando","depth":2},{"value":"Comparando duas funções","depth":2},{"value":"Parâmetro de Função Bivariado","depth":2},{"value":"Parâmetros Opcionais e Parâmetros Rest","depth":2},{"value":"Funções com sobrecarga","depth":2},{"value":"Enums","depth":2},{"value":"Classes","depth":2},{"value":"Membros privados e protegidos em classes","depth":2},{"value":"Generics","depth":2},{"value":"Tópicos avançados","depth":2},{"value":"Subtipos vs Atribuições","depth":2}],"frontmatter":{"permalink":"/pt/docs/handbook/type-compatibility.html","title":"Compatibilidade de Tipos","disable_toc":null,"handbook":null,"oneline":"Como checagem de tipos funciona em TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-compatibilidade-de-tipos","slug":"/pt/docs/handbook/type-compatibility.html","repoPath":"/packages/documentation/copy/pt/reference/Type Compatibility.md","lang":"pt","modifiedTime":"2021-05-31T12:18:20.883Z"}},"staticQueryHashes":[]}