{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/namespaces.html","result":{"data":{"markdownRemark":{"id":"56943f89-1033-5c42-8cc0-5d61d395814a","excerpt":"Uma nota sobre Terminologia\nÉ importante notar que no TypeScript 1.5, a nomeclatura mudou.\n“Internal modules” agora são “namespaces”.\n“External modules” agora…","html":"<blockquote>\n<p><strong>Uma nota sobre Terminologia</strong>\nÉ importante notar que no TypeScript 1.5, a nomeclatura mudou.\n“Internal modules” agora são “namespaces”.\n“External modules” agora são simplesmente módulos, para se alinhar com a terminologia do <a href=\"http://www.ecma-international.org/ecma-262/6.0/\">ECMAScript 2015</a>, (Ou seja, <code>module X {</code> agora é equivalente ao <code>namespace X {</code>, Preferivelmente)</p>\n</blockquote>\n<p>Essa postagem descreve várias maneiras de organizar seu código usando namespaces (antigamente “internal modules”) em TypeScript.\nComo mencionamos na nossa nota sobre terminologia, “internal modules” agora são referidos como “namespaces”.\nAdicionalmente, qualquer lugar em que a palavra <code>module</code> seja usada declarando um “internal module”, a palavra <code>namespace</code> pode e deve ser usada.\nIsso evita confundir novos usuários sobrecarregando eles com termos similares.</p>\n<h2 id=\"primeiros-passos\" style=\"position:relative;\"><a href=\"#primeiros-passos\" aria-label=\"primeiros passos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Primeiros passos</h2>\n<p>Vamos começar com um programa que vamos usar como exemplo nessa página.\nNós escrevemos um pequeno conjunto de simples validadores de string, como você talvez escreva para checar se o input do usuário num formulário numa página web ou checar um arquivo com dados fornecido externamente.</p>\n<h2 id=\"validadores-em-um-único-arquivo\" style=\"position:relative;\"><a href=\"#validadores-em-um-%C3%BAnico-arquivo\" aria-label=\"validadores em um único arquivo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Validadores em um único arquivo</h2>\n<pre><code class=\"language-ts\">interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n\nlet lettersRegexp = /^[A-Za-z]+$/;\nlet numberRegexp = /^[0-9]+$/;\n\nclass LettersOnlyValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return lettersRegexp.test(s);\n  }\n}\n\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 &#x26;&#x26; numberRegexp.test(s);\n  }\n}\n\n// Alguns exemplos\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validadores para usar\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\n\n// Mostrar qual string passou por qual validador\nfor (let s of strings) {\n  for (let name in validators) {\n    let isMatch = validators[name].isAcceptable(s);\n    console.log(`'${s}' ${isMatch ? \"matches\" : \"does not match\"} '${name}'.`);\n  }\n}\n</code></pre>\n<h2 id=\"namespacing\" style=\"position:relative;\"><a href=\"#namespacing\" aria-label=\"namespacing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Namespacing</h2>\n<p>Como nós adicionamos mais validadores, nós queremos ter algum tipo de organização no nosso esquema para manter o controle dos nossos tipos e não se preocupar com colisões de nomes com outros objetos.\nAo invés de colocar vários nomes em um namespace global, vamos encapsular nosso objeto em um namespace.</p>\n<p>Nesse exemplo, nós vamos mover todas as entidades relacionadas ao validador em um namespace chamado <code>Validation</code>.\nPorque nós queremos que as interfaces e classes aqui sejam visiveis fora do namespace, então nós adicionaremos eles com o <code>export</code>.\nInversamente, as váriaveis <code>lettersRegexp</code> e <code>numberRegexp</code> são detalhes de implementação, então nós não vamos exportar elas e não ficarão visíveis para código que fica fora do namespace.\nNo teste de código no rodapé do arquivo, nós agora precisamos qualificar os tipos dos nomes quando usamos fora do namespace, e.g <code>Validation LettersOnlyValidator</code>.</p>\n<h2 id=\"validadores-namespaced\" style=\"position:relative;\"><a href=\"#validadores-namespaced\" aria-label=\"validadores namespaced permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Validadores Namespaced</h2>\n<pre><code class=\"language-ts\">namespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n\n  const lettersRegexp = /^[A-Za-z]+$/;\n  const numberRegexp = /^[0-9]+$/;\n\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 &#x26;&#x26; numberRegexp.test(s);\n    }\n  }\n}\n\n// Alguns exemplos\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validadores para usar\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// Mostrar qual string passou por qual validador\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`\n    );\n  }\n}\n</code></pre>\n<h2 id=\"dividindo-entre-arquivos\" style=\"position:relative;\"><a href=\"#dividindo-entre-arquivos\" aria-label=\"dividindo entre arquivos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dividindo entre arquivos</h2>\n<p>Como nossa aplicação cresce, nós vamos dividir o código entre múltiplos arquivos para deixar mais fácil de manter.</p>\n<h2 id=\"múltiplos-namespaces\" style=\"position:relative;\"><a href=\"#m%C3%BAltiplos-namespaces\" aria-label=\"múltiplos namespaces permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Múltiplos namespaces</h2>\n<p>Aqui, nós vamos dividir nosso namespace <code>Validation</code> em vários arquivos.\nApesar dos arquivos estarem separados, eles podem contribuir com o mesmo namespace e podem ser consumidos como se eles fossem definidos em um único lugar.\nPorque existem dependências entre os arquivos, nós vamos adicionar tags de referência para informar o compilador sobre a relação entre os arquivos.\nNosso teste de código não é alterado.</p>\n<h5 id=\"validationts\" style=\"position:relative;\"><a href=\"#validationts\" aria-label=\"validationts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Validation.ts</h5>\n<pre><code class=\"language-ts\">namespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}\n</code></pre>\n<h5 id=\"lettersonlyvalidatorts\" style=\"position:relative;\"><a href=\"#lettersonlyvalidatorts\" aria-label=\"lettersonlyvalidatorts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LettersOnlyValidator.ts</h5>\n<pre><code class=\"language-ts\">/// &#x3C;reference path=\"Validation.ts\" />\nnamespace Validation {\n  const lettersRegexp = /^[A-Za-z]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n}\n</code></pre>\n<h5 id=\"zipcodevalidatorts\" style=\"position:relative;\"><a href=\"#zipcodevalidatorts\" aria-label=\"zipcodevalidatorts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ZipCodeValidator.ts</h5>\n<pre><code class=\"language-ts\">/// &#x3C;reference path=\"Validation.ts\" />\nnamespace Validation {\n  const numberRegexp = /^[0-9]+$/;\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 &#x26;&#x26; numberRegexp.test(s);\n    }\n  }\n}\n</code></pre>\n<h5 id=\"testts\" style=\"position:relative;\"><a href=\"#testts\" aria-label=\"testts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Test.ts</h5>\n<pre><code class=\"language-ts\">/// &#x3C;reference path=\"Validation.ts\" />\n/// &#x3C;reference path=\"LettersOnlyValidator.ts\" />\n/// &#x3C;reference path=\"ZipCodeValidator.ts\" />\n\n// Alguns exemplos\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validadores para usar\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// Mostrar qual string passou por qual validador\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`\n    );\n  }\n}\n</code></pre>\n<p>Uma vez que há múltiplos arquivos envolvidos, nós precisamos nos certificar que todo código compilado seja carregado.\nHá duas maneiras de fazer isso.</p>\n<p>Primeiro, nós podemos usar um output concatenado usando a flag <code>--outFile</code> para compilar todos os arquivos em um único arquivo JavaScript:</p>\n<pre><code class=\"language-Shell\">tsc --outFile sample.js Test.ts\n</code></pre>\n<p>O compilador vai automaticamente ordenar o output do arquivo baseado nas tags de referência presentes nos arquivos. Você pode especificar cada arquivo individualmente:</p>\n<pre><code class=\"language-Shell\">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts\n</code></pre>\n<p>Outra forma, nós podemos usar a compilação por arquivo (padrão) para criar um único arquivo JavaScript para cada arquivo de entrada.\nSe múltiplos arquivos JS são criados, nós vamos precisar usar tags <code>&#x3C;script></code> na nossa página web para carregar cada arquivo criado na ordem apropriada, por exemplo:</p>\n<h5 id=\"mytestpagehtml-excerpt\" style=\"position:relative;\"><a href=\"#mytestpagehtml-excerpt\" aria-label=\"mytestpagehtml excerpt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MyTestPage.html (excerpt)</h5>\n<pre><code class=\"language-html\">&#x3C;script src=\"Validation.js\" type=\"text/javascript\" />\n&#x3C;script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />\n&#x3C;script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />\n&#x3C;script src=\"Test.js\" type=\"text/javascript\" />\n</code></pre>\n<h2 id=\"apelido\" style=\"position:relative;\"><a href=\"#apelido\" aria-label=\"apelido permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Apelido</h2>\n<p>Outra forma de trabalhar com <code>namespaces</code> é usar <code>import q = x.y.z</code> para criar nomes menores para objetos comumente usados.\nPara não ficar confuso com a sintaxe <code>import x = require(\"name\")</code> para carregar módulos, essa sintaxe simplesmente cria um apelido para um simbolo especifico.\nVocê pode usar esses tipos de importação (comumente usado como apelidos) para qualquer tipo de identificador, incluindo objetos criados da importação de múltiplos módulos.</p>\n<pre><code class=\"language-ts\">namespace Shapes {\n  export namespace Polygons {\n    export class Triangle {}\n    export class Square {}\n  }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // Mesmo que 'new Shapes.Polygons.Square()'\n</code></pre>\n<p>Note que não usamos a palavra-chave <code>require</code>; Ao invés disso nós atribuimos diretamente do nome qualificado do simbolo que nós estamos importando.\nIsso é similar ao uso do <code>var</code>, mas também funciona para significados do tipo e namespace do símbolo importado.\nImportante, para valores, <code>import</code> é uma referência distinta do simbolo original, então mudanças para um apelido <code>var</code> não vai ser refletida na variável original.</p>\n<h2 id=\"trabalhando-com-outras-bibliotecas-javascript\" style=\"position:relative;\"><a href=\"#trabalhando-com-outras-bibliotecas-javascript\" aria-label=\"trabalhando com outras bibliotecas javascript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Trabalhando com outras Bibliotecas JavaScript</h2>\n<p>Para descrever o formato das bibliotecas não escritas em TypeScript, nós precisamos declarar a API que a biblioteca expõe.\nPorque a maioria das Bibliotecas JavaScript expõe apenas alguns objetos top-level, namespaces são uma boa forma para representar eles.</p>\n<p>Nós chamamos declarações que não definem uma implementação de “ambiente”.\nNormalmente essas são definidas em arquivos <code>.d.ts</code>.\nSe você tiver familiaridade com C/C++, você pode pensar como se estes fossem os arquivos <code>.h</code>.</p>\n<h2 id=\"namespaces-de-ambiente\" style=\"position:relative;\"><a href=\"#namespaces-de-ambiente\" aria-label=\"namespaces de ambiente permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Namespaces de Ambiente</h2>\n<p>A popular biblioteca D3 define suas funcionalidades em um objeto global chamado <code>d3</code>.\nPorque essa biblioteca é carregada através de uma tag <code>&#x3C;script></code> (Ao invés de um módulo carregador), suas declarações usam namespaces para definir seu formato.\nPara que o compilador TypeScript veja esse formato, nós usamos uma declaração namespace de ambiente.<br>\nPor exemplo, nós podemos começar escrevendo como segue:</p>\n<h5 id=\"d3dts-trecho-simplificado\" style=\"position:relative;\"><a href=\"#d3dts-trecho-simplificado\" aria-label=\"d3dts trecho simplificado permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>D3.d.ts (trecho simplificado)</h5>\n<pre><code class=\"language-ts\">declare namespace D3 {\n  export interface Selectors {\n    select: {\n      (selector: string): Selection;\n      (element: EventTarget): Selection;\n    };\n  }\n\n  export interface Event {\n    x: number;\n    y: number;\n  }\n\n  export interface Base extends Selectors {\n    event: Event;\n  }\n}\n\ndeclare var d3: D3.Base;\n</code></pre>","headings":[{"value":"Primeiros passos","depth":2},{"value":"Validadores em um único arquivo","depth":2},{"value":"Namespacing","depth":2},{"value":"Validadores Namespaced","depth":2},{"value":"Dividindo entre arquivos","depth":2},{"value":"Múltiplos namespaces","depth":2},{"value":"Validation.ts","depth":5},{"value":"LettersOnlyValidator.ts","depth":5},{"value":"ZipCodeValidator.ts","depth":5},{"value":"Test.ts","depth":5},{"value":"MyTestPage.html (excerpt)","depth":5},{"value":"Apelido","depth":2},{"value":"Trabalhando com outras Bibliotecas JavaScript","depth":2},{"value":"Namespaces de Ambiente","depth":2},{"value":"D3.d.ts (trecho simplificado)","depth":5}],"frontmatter":{"permalink":"/pt/docs/handbook/namespaces.html","title":"Namespaces","disable_toc":null,"handbook":null,"oneline":"Como funcionam os Namespaces no TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-namespaces","slug":"/pt/docs/handbook/namespaces.html","repoPath":"/packages/documentation/copy/pt/reference/Namespaces.md","lang":"pt","modifiedTime":"2021-05-31T12:18:20.883Z"}},"staticQueryHashes":[]}