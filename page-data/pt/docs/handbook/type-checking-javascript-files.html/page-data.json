{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/type-checking-javascript-files.html","result":{"data":{"markdownRemark":{"id":"1e30b944-e836-5572-bbc0-a4955d7fa3b4","excerpt":"Aqui estão algumas diferenças notáveis em como a checagem de tipo funciona em arquivos .js comparados com arquivos .ts. Propriedades são inferidas de…","html":"<p>Aqui estão algumas diferenças notáveis em como a checagem de tipo funciona em arquivos <code>.js</code> comparados com arquivos <code>.ts</code>.</p>\n<h2 id=\"propriedades-são-inferidas-de-atribuições-no-corpo-das-classes\" style=\"position:relative;\"><a href=\"#propriedades-s%C3%A3o-inferidas-de-atribui%C3%A7%C3%B5es-no-corpo-das-classes\" aria-label=\"propriedades são inferidas de atribuições no corpo das classes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Propriedades são inferidas de atribuições no corpo das classes</h2>\n<p>ES2015 não tem meios de declaração de propriedades em uma classe. Propriedades são atribuídas dinamicamente, assim como objetos literais.</p>\n<p>Em um arquivo <code>.js</code>, o compilador infere propriedades a partir da atribuição das mesmas dentro de um corpo de uma classe.\nO tipo de uma propriedade é o tipo dado no construtor, a não ser que não seja definido lá ou o tipo no construtor for undefined ou null.\nNeste caso, o tipo é uma união dos tipos de todos os valores que estão do lado direito dessas atribuições.\nPropriedades definidas no construtor são sempre assumidas existentes, enquanto as que foram definidas apenas em métodos, getters ou setters são consideradas opcionais.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @errors: 2322\nclass C {\n  constructor() {\n    this.constructorOnly = 0;\n    this.constructorUnknown = undefined;\n  }\n  method() {\n    this.constructorOnly = false;\n    this.constructorUnknown = \"plunkbat\"; // ok, construtorUnknown é uma string | undefined\n    this.methodOnly = \"ok\"; // ok, mas methodOnly também pode ser undefined\n  }\n  method2() {\n    this.methodOnly = true; // também ok, methodOnly's type é string | boolean | undefined\n  }\n}\n</code></pre>\n<p>Se propriedades nunca forem declaradas no corpo da classe, elas são consideradas desconhecidas (com o tipo unknown).\nSe sua classe tem propriedades que são apenas lidas, adicione e então anote uma declaraçao no construtor com JSDoc para especificação de tipo.\nVocê não precisa nem atribuir um valor a ela se for inicializada posteriormente.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @errors: 2322\nclass C {\n  constructor() {\n    /** @type {number | undefined} */\n    this.prop = undefined;\n    /** @type {number | undefined} */\n    this.count;\n  }\n}\n\nlet c = new C();\nc.prop = 0; // OK\nc.count = \"string\";\n</code></pre>\n<h2 id=\"funções-construtoras-são-equivalentes-a-classes\" style=\"position:relative;\"><a href=\"#fun%C3%A7%C3%B5es-construtoras-s%C3%A3o-equivalentes-a-classes\" aria-label=\"funções construtoras são equivalentes a classes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Funções construtoras são equivalentes a classes</h2>\n<p>Antes do ES2015, Javascript usava funções construtoras ao invés de classes.\nO compilador suporta esse padrão e entende que funções construtoras são equivalentes a Classes do ES2015.\nAs regras de inferência de propriedades funcionam exatamente da mesma forma.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @errors: 2683 2322\nfunction C() {\n  this.constructorOnly = 0;\n  this.constructorUnknown = undefined;\n}\nC.prototype.method = function () {\n  this.constructorOnly = false;\n  this.constructorUnknown = \"plunkbat\"; // OK, o tipo é string | undefined\n};\n</code></pre>\n<h2 id=\"commonjs-modules-são-suportados\" style=\"position:relative;\"><a href=\"#commonjs-modules-s%C3%A3o-suportados\" aria-label=\"commonjs modules são suportados permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CommonJS modules são suportados</h2>\n<p>Em um arquivo <code>.js</code>, TypeScript entende o formato de módulo CommonJS.\nAtribuiçoes a <code>exports</code> e <code>modules.exports</code> são reconhecidas como declarações de exportação.\nSimilarmente, chamadas de função <code>require</code> são reconhecidas como importações de módulos. Por exemplo:</p>\n<pre><code class=\"language-js\">// o mesmo que `import module \"fs\"`\nconst fs = require(\"fs\");\n\n// o mesmo que `export funcion readFile`\nmodule.exports.readFile = function (f) {\n  return fs.readFileSync(f);\n};\n</code></pre>\n<p>O suporte de módulo em Javascript é muito mais flexível sinteticamente que o suporte de módulo de TypeScript.\nMuitas das combinações de atribuições e declarações são suportadas.</p>\n<h2 id=\"classes-funções-e-object-literals-são-namespaces\" style=\"position:relative;\"><a href=\"#classes-fun%C3%A7%C3%B5es-e-object-literals-s%C3%A3o-namespaces\" aria-label=\"classes funções e object literals são namespaces permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Classes, funções, e object literals são namespaces</h2>\n<p>Classes sao namespaces em arquivos <code>.js</code>.\nIsso pode ser usado para aninhar classes, por exemplo:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">class C {}\nC.D = class {};\n</code></pre>\n<p>E para código pre-ES2015, pode ser usado para simular métodos estáticos:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">function Outer() {\n  this.y = 2;\n}\n\nOuter.Inner = function () {\n  this.yy = 2;\n};\n\nOuter.innter();\n</code></pre>\n<p>Também pode ser usado para criar namespaces simples:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">var ns = {};\nns.C = class {};\nns.func = function () {};\n\nns;\n</code></pre>\n<p>Outras variantes são permitidas também:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// IIFE\nvar ns = (function (n) {\n  return n || {};\n})();\nns.CONST = 1;\n\n// defaulting to global\nvar assign =\n  assign ||\n  function () {\n    // code goes here\n  };\nassign.extra = 1;\n</code></pre>\n<h2 id=\"objetos-literais-são-abertos\" style=\"position:relative;\"><a href=\"#objetos-literais-s%C3%A3o-abertos\" aria-label=\"objetos literais são abertos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Objetos literais são abertos</h2>\n<p>Em um arquivo <code>.ts</code>, um objeto literal que inicializa uma declaração de variável dá o seu tipo para a declaração.\nNenhum membro novo que não foi especificado na declaração pode ser adicionado.\nEssas regras são relaxadas em um arquivo <code>.js</code>; objetos literais tem um tipo aberto (uma assinatura de índice) que permite adicionar e procurar propriedades que não foram adicionadas originalmente.\nPor exemplo:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">var obj = { a: 1 };\nobj.b = 2; // Permitido\n</code></pre>\n<p>Objetos literais se comportam como se tivessem uma assinatura de índice <code>[x:string]: any</code> que permite que sejam tratados como maps abertos ao invés de objetos fechados.</p>\n<p>Assim como outros comportamentos especiais do JS, esse comportamento pode ser mudado adicionando um tipo JSDoc para a variável. Por exemplo:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @errors: 2339\n/** @type {{a: number}} */\nvar obj = { a: 1 };\nobj.b = 2;\n</code></pre>\n<h2 id=\"inicializadores-null-undefined-e-arrays-vazios-são-do-tipo-any-ou-any\" style=\"position:relative;\"><a href=\"#inicializadores-null-undefined-e-arrays-vazios-s%C3%A3o-do-tipo-any-ou-any\" aria-label=\"inicializadores null undefined e arrays vazios são do tipo any ou any permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inicializadores null, undefined e arrays vazios são do tipo any ou any[]</h2>\n<p>Qualquer variável, parâmetro ou propriedade que é inicializado com null ou undefined terão tipo any, mesmo que a checagem estrita de null esteja habilitada.\nQualquer variável, parâmetro ou propriedade que é inicializada com [] terá tipo any[], mesmo que a checagem estrita de null esteja habiltada.\nA única exceção é para propriedades que tem múltiplos inicializadores como descrito acima.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">function Foo(i = null) {\n  if (!i) i = 1;\n  var j = undefined;\n  j = 2;\n  this.l = [];\n}\n\nvar foo = new Foo();\nfoo.l.push(foo.i);\nfoo.l.push(\"end\");\n</code></pre>\n<h2 id=\"parâmetros-de-funções-são-opcionais-por-padrão\" style=\"position:relative;\"><a href=\"#par%C3%A2metros-de-fun%C3%A7%C3%B5es-s%C3%A3o-opcionais-por-padr%C3%A3o\" aria-label=\"parâmetros de funções são opcionais por padrão permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parâmetros de funções são opcionais por padrão</h2>\n<p>Uma vez que não há uma forma de especificar opcionalidade em parâmetros de funções em Javascript pre-ES2015, todas os parâmetros de funções são considerados opcionais.\nChamadas com menos argumentos que a quantidade declarada na função são permitidas.</p>\n<p>É importante notar que é um erro chamar funções com mais argumentos do que declarados.</p>\n<p>Por exemplo:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @strict: false\n// @errors: 7006 7006 2554\nfunction bar(a, b) {\n  console.log(a + \" \" + b);\n}\n\nbar(1); // OK, segundo argumento considerado opcional\nbar(1, 2);\nbar(1, 2, 3); // Erro, argumentos em excesso\n</code></pre>\n<p>Funções anotadas com JSDoc são excluídas dessa regra.\nUse a sintaxe de parâmetro opcional JSDoc (<code>[</code> <code>]</code>) para expressar opcionalidade. e.g.:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @param {string} [somebody] - O nome de alguém.\n */\nfunction sayHello(somebody) {\n  if (!somebody) {\n    somebody = \"John Doe\";\n  }\n  console.log(\"Hello \" + somebody);\n}\n\nsayHello();\n</code></pre>\n<h2 id=\"declarações-de-parâmetros-var-args-são-inferidos-do-uso-de-arguments\" style=\"position:relative;\"><a href=\"#declara%C3%A7%C3%B5es-de-par%C3%A2metros-var-args-s%C3%A3o-inferidos-do-uso-de-arguments\" aria-label=\"declarações de parâmetros var args são inferidos do uso de arguments permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Declarações de parâmetros var-args são inferidos do uso de <code>arguments</code></h2>\n<p>Uma função que tem uma referência à referência <code>arguments</code> é considerada tendo parâmetros var-arg (i.e. <code>(...arg: any[]) => any</code>). Use a sintaxe de var-arg JSDoc para especificar o tipo destes argumentos.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/** @param {...number} args */\nfunction sum(/* numbers */) {\n  var total = 0;\n  for (var i = 0; i &#x3C; arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\n</code></pre>\n<h2 id=\"tipos-de-parâmetros-não-especificados-tem-como-padrão-any\" style=\"position:relative;\"><a href=\"#tipos-de-par%C3%A2metros-n%C3%A3o-especificados-tem-como-padr%C3%A3o-any\" aria-label=\"tipos de parâmetros não especificados tem como padrão any permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tipos de parâmetros não especificados tem como padrão <code>any</code></h2>\n<p>Uma vez que não há sintaxe natual para especificar tipos de parâmetros genéricos em Javascript, um tipo de parâmetro não especificado tem como padrão <code>any</code>.</p>\n<h3 id=\"em-uma-cláusula-extends\" style=\"position:relative;\"><a href=\"#em-uma-cl%C3%A1usula-extends\" aria-label=\"em uma cláusula extends permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Em uma cláusula extends</h3>\n<p>Por exemplo, <code>React.Component</code> é definido para ter dois parâmetros específicos, <code>Props</code> e <code>State</code>.\nEm um arquivo <code>.js</code>, não há forma legal de especificar esses parâmetros na cláusula extends. Por padrão o tipo dos argumentos será <code>any</code>:</p>\n<pre><code class=\"language-js\">import { Component } from \"react\";\n\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Permitido, já que this.props tem o tipo any\n  }\n}\n</code></pre>\n<p>Use o JSDoc <code>@arguments</code> para especificar os tipos explicitamente. Por exemplo:</p>\n<pre><code class=\"language-js\">import { Component } from \"react\";\n\n/**\n * @augments {Component&#x3C;{a: number}, State>}\n */\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Erro: b não existe em {a: number}\n  }\n}\n</code></pre>\n<h3 id=\"em-referências-jsdoc\" style=\"position:relative;\"><a href=\"#em-refer%C3%AAncias-jsdoc\" aria-label=\"em referências jsdoc permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Em referências JSDoc</h3>\n<p>Um tipo de argumento não especificado em JSDoc tem como padrão any</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/** @type{Array} */\nvar x = [];\n\nx.push(1); // OK\nx.push(\"string\"); // OK, x é do tipo Array&#x3C;any>\n\n/** @type{Array.&#x3C;number>} */\nvar y = [];\n\ny.push(1); // OK\ny.push(\"string\"); // Erro, string não é atribuível a number\n</code></pre>\n<h3 id=\"em-chamadas-de-função\" style=\"position:relative;\"><a href=\"#em-chamadas-de-fun%C3%A7%C3%A3o\" aria-label=\"em chamadas de função permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Em chamadas de função</h3>\n<p>Uma chamada para uma função genérica usa os argumentos para inferir o tipo dos parâmetros. As vezes este processo falha ao inferir qualquer tipo, principalmente por causa da falta de fontes de inferência; nesses casos, o tipo dos parâmetros será <code>any</code>. Por exemplo:</p>\n<pre><code class=\"language-js\">var p = new Promise((resolve, reject) => {\n  reject();\n});\n\np; // Promise&#x3C;any>;\n</code></pre>\n<p>Para aprender todas as features disponíveis em JSDoc, veja <a href=\"/docs/handbook/jsdoc-supported-types.html\">a referência</a></p>","headings":[{"value":"Propriedades são inferidas de atribuições no corpo das classes","depth":2},{"value":"Funções construtoras são equivalentes a classes","depth":2},{"value":"CommonJS modules são suportados","depth":2},{"value":"Classes, funções, e object literals são namespaces","depth":2},{"value":"Objetos literais são abertos","depth":2},{"value":"Inicializadores null, undefined e arrays vazios são do tipo any ou any[]","depth":2},{"value":"Parâmetros de funções são opcionais por padrão","depth":2},{"value":"Declarações de parâmetros var-args são inferidos do uso de arguments","depth":2},{"value":"Tipos de parâmetros não especificados tem como padrão any","depth":2},{"value":"Em uma cláusula extends","depth":3},{"value":"Em referências JSDoc","depth":3},{"value":"Em chamadas de função","depth":3}],"frontmatter":{"permalink":"/pt/docs/handbook/type-checking-javascript-files.html","title":"Checando tipos de arquivos JavaScript","disable_toc":null,"handbook":null,"oneline":"Como adicionar checagem de tipos a arquivos JavaScript usando Typescript","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Projetos JS utilizando TypeScript","oneline":"Como adicionar verificação de tipo a arquivos JavaScript usando TypeScript","permalink":"/pt/docs/handbook/intro-to-js-ts.html"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Referência JSDoc","oneline":"Quais JSDoc Javascript baseado em Typescript suporta?","permalink":"/pt/docs/handbook/jsdoc-supported-types.html"}}}},"pageContext":{"id":"6-checando-tipos-de-arquivos-javascript","slug":"/pt/docs/handbook/type-checking-javascript-files.html","repoPath":"/packages/documentation/copy/pt/javascript/Type Checking JavaScript Files.md","previousID":"670bf195-5c99-5c93-8fd0-c5d938d41c60","nextID":"3c6ddc7c-8f1f-506c-97e2-1469496966e6","lang":"pt","modifiedTime":"2021-05-31T12:18:20.879Z"}},"staticQueryHashes":[]}