{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/mixins.html","result":{"data":{"markdownRemark":{"id":"d58bcd02-eff5-57ac-89d5-3035f0e17068","excerpt":"Junto com as hierarquias OO tradicionais, outra maneira popular de construir classes a partir de componentes reutilizáveis ​​é construí-los combinando classes…","html":"<p>Junto com as hierarquias OO tradicionais, outra maneira popular de construir classes a partir de componentes reutilizáveis ​​é construí-los combinando classes parciais mais simples.\nVocê pode estar familiarizado com a ideia de mixins ou traits para linguagens como Scala, e o padrão também alcançou alguma popularidade na comunidade JavaScript.</p>\n<h2 id=\"como-funciona-um-mixin\" style=\"position:relative;\"><a href=\"#como-funciona-um-mixin\" aria-label=\"como funciona um mixin permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Como funciona um Mixin?</h2>\n<p>O padrão depende do uso de Genéricos com herança de classe para estender uma classe base.\nO melhor suporte mixin do TypeScript é feito por meio do padrão de expressão de classe.\nVocê pode ler mais sobre como esse padrão funciona em <a href=\"https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/\">JavaScript aqui</a>.</p>\n<p>Para começar, precisaremos de uma classe que terá o mixin aplicado em cima de:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">class Sprite {\n  nome = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(nome: string) {\n    this.nome = nome;\n  }\n}\n</code></pre>\n<p>Então você precisa de um tipo e uma função de fábrica que retorne uma expressão de classe estendendo a classe base.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// Para começar, precisamos de um tipo que usaremos para estender\n// outras classes de. A principal responsabilidade é declarar\n// que o tipo que está sendo passado é uma classe.\n\ntype Construtor = new (...args: any[]) => {};\n\n// Este mixin adiciona uma propriedade de escala, com getters e setters\n// para alterá-lo com uma propriedade privada encapsulada:\n\nfunction Escala&#x3C;TBase extends Construtor>(Base: TBase) {\n  return class Dimensionamento extends Base {\n    // Mixins não podem declarar propriedades privadas/protegidas\n    // entretanto, você pode usar campos privados ES2020\n    _escala = 1;\n\n    setEscala(escala: number) {\n      this._escala = escala;\n    }\n\n    get escala(): number {\n      return this._escala;\n    }\n  };\n}\n</code></pre>\n<p>Com tudo isso configurado, você pode criar uma classe que representa a classe base com mixins aplicados:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">class Sprite {\n  nome = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(nome: string) {\n    this.nome = nome;\n  }\n}\ntype Construtor = new (...args: any[]) => {};\nfunction Escala&#x3C;TBase extends Construtor>(Base: TBase) {\n  return class Dimensionamento extends Base {\n    // Mixins não podem declarar propriedades privadas/protegidas\n    // entretanto, você pode usar campos privados ES2020\n    _escala = 1;\n\n    setEscala(escala: number) {\n      this._escala = escala;\n    }\n\n    get escala(): number {\n      return this._escala;\n    }\n  };\n}\n// ---cortar---\n// Componha uma nova classe da classe Sprite,\n// com o aplicador Mixin Escala:\nconst SpriteOitoBits = Escala(Sprite);\n\nconst abanoSprite = new SpriteOitoBits(\"Passaro\");\nabanoSprite.setEscala(0.8);\nconsole.log(abanoSprite.escala);\n</code></pre>\n<h2 id=\"mixins-restritos\" style=\"position:relative;\"><a href=\"#mixins-restritos\" aria-label=\"mixins restritos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mixins restritos</h2>\n<p>Na forma acima, o mixin não tem nenhum conhecimento básico da classe, o que pode dificultar a criação do design que você deseja.</p>\n<p>Para modelar isso, modificamos o tipo de construtor original para aceitar um argumento genérico.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// Este era nosso construtor anterior:\ntype Construtor = new (...args: any[]) => {};\n// Agora usamos uma versão genérica que pode aplicar uma restrição em\n// a classe a qual este mixin é aplicado\ntype GConstrutor&#x3C;T = {}> = new (...args: any[]) => T;\n</code></pre>\n<p>Isso permite a criação de classes que funcionam apenas com classes de base restritas:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type GConstrutor&#x3C;T = {}> = new (...args: any[]) => T;\nclass Sprite {\n  nome = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(nome: string) {\n    this.nome = nome;\n  }\n}\n// ---corte---\ntype Posicionavel = GConstrutor&#x3C;{ setPos: (x: number, y: number) => void }>;\ntype Spritable = GConstrutor&#x3C;typeof Sprite>;\ntype Loggable = GConstrutor&#x3C;{ impressao: () => void }>;\n</code></pre>\n<p>Então você pode criar mixins que só funcionam quando você tem uma base particular para construir:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">type GConstrutor&#x3C;T = {}> = new (...args: any[]) => T;\nclass Sprite {\n  nome = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(nome: string) {\n    this.nome = nome;\n  }\n}\ntype Posicionavel = GConstrutor&#x3C;{ setPos: (x: number, y: number) => void }>;\ntype Spritable = GConstrutor&#x3C;typeof Sprite>;\ntype Loggable = GConstrutor&#x3C;{ impressao: () => void }>;\n// ---cortar---\n\nfunction Saltavel&#x3C;TBase extends Posicionavel>(Base: TBase) {\n  return class Saltavel extends Base {\n    saltar() {\n      // Este mixin só funcionará se for passado uma base\n      // classe que tem setPos definido por causa da\n      // Restrição posicionável.\n      this.setPos(0, 20);\n    }\n  };\n}\n</code></pre>\n<h2 id=\"padrão-alternativo\" style=\"position:relative;\"><a href=\"#padr%C3%A3o-alternativo\" aria-label=\"padrão alternativo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Padrão Alternativo</h2>\n<p>As versões anteriores deste documento recomendavam uma maneira de escrever mixins em que você criava o tempo de execução e as hierarquias de tipo separadamente e depois os mesclava no final:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @strict: false\n// Cada mixin é uma classe ES tradicional\nclass Saltavel {\n  saltar() {}\n}\n\nclass Abaixavel {\n  abaixar() {}\n}\n\n// Incluindo a base\nclass Sprite {\n  x = 0;\n  y = 0;\n}\n\n// Então você cria uma interface que mescla\n// os mixins esperados com o mesmo nome de sua base\ninterface Sprite extends Saltavel, Abaixavel {}\n// Aplique os mixins na classe base via\n// JS em tempo de execução\naplicarMixins(Sprite, [Saltavel, Abaixavel]);\n\nlet jogador = new Sprite();\njogador.saltar();\nconsole.log(jogador.x, jogador.y);\n\n// Isso pode estar em qualquer lugar em sua base de código:\nfunction aplicarMixins(derivadoCtor: any, construtores: any[]) {\n  construtores.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((nome) => {\n      Object.defineProperty(\n        derivadoCtor.prototype,\n        nome,\n        Object.getOwnPropertyDescriptor(baseCtor.prototype, nome) ||\n          Object.create(null)\n      );\n    });\n  });\n}\n</code></pre>\n<p>Esse padrão depende menos do compilador e mais da sua base de código para garantir que o tempo de execução e o sistema de tipos sejam mantidos corretamente em sincronia.</p>\n<h2 id=\"restrições\" style=\"position:relative;\"><a href=\"#restri%C3%A7%C3%B5es\" aria-label=\"restrições permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Restrições</h2>\n<p>O padrão mixin é suportado nativamente dentro do compilador TypeScript por análise de fluxo de código.\nExistem alguns casos em que você pode atingir as bordas do suporte nativo.</p>\n<h4 id=\"decoradores-e-mixins-4881\" style=\"position:relative;\"><a href=\"#decoradores-e-mixins-4881\" aria-label=\"decoradores e mixins 4881 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Decoradores e Mixins <a href=\"https://github.com/microsoft/TypeScript/issues/4881\"><code>#4881</code></a></h4>\n<p>Você não pode usar decoradores para fornecer mixins por meio de análise de fluxo de código:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\n// @errors: 2339\n// Uma função decoradora que replica o padrão mixin:\nconst Pausavel = (alvo: typeof Jogador) => {\n  return class Pausavel extends alvo {\n    deveCongelar = false;\n  };\n};\n\n@Pausavel\nclass Jogador {\n  x = 0;\n  y = 0;\n}\n\n// A classe Jogador não tem o tipo de decorador mesclado:\nconst jogador = new Jogador();\njogador.deveCongelar;\n\n// Se o aspecto do tempo de execução pode ser replicado manualmente via\n// composição de tipo ou fusão de interface.\ntype JogadorCongelado = typeof Jogador &#x26; { deveCongelar: boolean };\n\nconst jogadorDois = (new Jogador() as unknown) as JogadorCongelado;\njogadorDois.deveCongelar;\n</code></pre>\n<h4 id=\"mixins-de-propriedade-estática-17829\" style=\"position:relative;\"><a href=\"#mixins-de-propriedade-est%C3%A1tica-17829\" aria-label=\"mixins de propriedade estática 17829 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mixins de propriedade estática <a href=\"https://github.com/microsoft/TypeScript/issues/17829\"><code>#17829</code></a></h4>\n<p>Mais uma pegadinha do que uma restrição.\nO padrão de expressão de classe cria singletons, portanto, não podem ser mapeados no sistema de tipos para suportar diferentes tipos de variáveis.</p>\n<p>Você pode contornar isso usando funções para retornar suas classes que diferem com base em um genérico:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function base&#x3C;T>() {\n  class Base {\n    static prop: T;\n  }\n  return Base;\n}\n\nfunction derivado&#x3C;T>() {\n  class Derivado extends base&#x3C;T>() {\n    static outraProp: T;\n  }\n  return Derivado;\n}\n\nclass Spec extends derivado&#x3C;string>() {}\n\nSpec.prop; // string\nSpec.outraProp; // string\n</code></pre>","headings":[{"value":"Como funciona um Mixin?","depth":2},{"value":"Mixins restritos","depth":2},{"value":"Padrão Alternativo","depth":2},{"value":"Restrições","depth":2},{"value":"Decoradores e Mixins #4881","depth":4},{"value":"Mixins de propriedade estática #17829","depth":4}],"frontmatter":{"permalink":"/pt/docs/handbook/mixins.html","title":"Mixins","disable_toc":null,"handbook":null,"oneline":"Usando o padrão Mixin com TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-mixins","slug":"/pt/docs/handbook/mixins.html","repoPath":"/packages/documentation/copy/pt/reference/Mixins.md","lang":"pt","modifiedTime":"2021-05-31T12:18:20.879Z"}},"staticQueryHashes":[]}