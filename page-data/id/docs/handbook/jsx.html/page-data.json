{"componentChunkName":"component---src-templates-documentation-tsx","path":"/id/docs/handbook/jsx.html","result":{"data":{"markdownRemark":{"id":"0822e4cd-4703-5992-b1fe-7984b9f1a67e","excerpt":"JSX adalah sebuah sintaks tertanam, yang seperti XML.\nIni dimaksudkan untuk diubah menjadi JavaScript yang valid, meskipun semantik dari transformasi itu khususâ€¦","html":"<p><a href=\"https://facebook.github.io/jsx/\">JSX</a> adalah sebuah sintaks tertanam, yang seperti XML.\nIni dimaksudkan untuk diubah menjadi JavaScript yang <em>valid</em>, meskipun semantik dari transformasi itu khusus untuk implementasi.\nJSX menjadi populer dengan kerangka kerja <a href=\"https://reactjs.org/\">React</a>, tetapi sejak itu juga melihat implementasi lain.\nTypeScript mendukung <em>embeding</em>, pemeriksaan tipe, dan mengkompilasi JSX secara langsung ke JavaScript.</p>\n<h2 id=\"dasar-penggunaan\" style=\"position:relative;\"><a href=\"#dasar-penggunaan\" aria-label=\"dasar penggunaan permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dasar Penggunaan</h2>\n<p>Untuk menggunakan JSX, Anda harus melakukan dua hal berikut:</p>\n<ol>\n<li>Penamaan berkas dengan ekstensi <code>.tsx</code></li>\n<li>Mengaktifkan opsi <code>jsx</code></li>\n</ol>\n<p>TypeScript memiliki tiga jenis mode JSX: <code>preserve</code>, <code>react</code>, dan <code>react-native</code>.\nMode tersebut hanya berlaku untuk <em>stage</em>, sedangkan untuk pemeriksaan tipe, hal itu tidak berlaku.\nMode <code>preserve</code> akan mempertahankan JSX sebagai bagian dari <em>output</em> untuk selanjutnya digunakan oleh langkah transformasi lain (mis. <a href=\"https://babeljs.io/\">Babel</a>).\nSelain itu, <em>output</em>-nya akan memiliki ekstensi berkas <code>.jsx</code>.\nMode <code>react</code> akan mengeluarkan<code>React.createElement</code>, tidak perlu melalui transformasi JSX sebelum digunakan, dan outputnya akan memiliki ekstensi berkas <code>.js</code>.\nMode <code>react-native</code> sama dengan <code>pertahankan</code> yang mempertahankan semua JSX, tetapi hasilnya justru akan memiliki ekstensi berkas <code>.js</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Mode</th>\n<th>Input</th>\n<th>Output</th>\n<th>Berkas Output Extension</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>preserve</code></td>\n<td><code>&#x3C;div /></code></td>\n<td><code>&#x3C;div /></code></td>\n<td><code>.jsx</code></td>\n</tr>\n<tr>\n<td><code>react</code></td>\n<td><code>&#x3C;div /></code></td>\n<td><code>React.createElement(\"div\")</code></td>\n<td><code>.js</code></td>\n</tr>\n<tr>\n<td><code>react-native</code></td>\n<td><code>&#x3C;div /></code></td>\n<td><code>&#x3C;div /></code></td>\n<td><code>.js</code></td>\n</tr>\n</tbody>\n</table>\n<p>Anda dapat menetapkan mode ini menggunakan <em>flag</em> baris perintah <code>--jsx</code> atau opsi yang sesuai di berkas <a href=\"/docs/handbook/tsconfig-json.html\">tsconfig.json</a> Anda.</p>\n<blockquote>\n<p>*Catatan: Anda dapat menentukan fungsi <em>factory</em> JSX yang akan digunakan saat menargetkan react JSX <em>emit</em> dengan opsi <code>--jsxFactory</code> (nilai bawaan ke <code>React.createElement</code>)</p>\n</blockquote>\n<h2 id=\"opeartor-as\" style=\"position:relative;\"><a href=\"#opeartor-as\" aria-label=\"opeartor as permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Opeartor <code>as</code></h2>\n<p>Ingat bagaimana menulis penegasan tipe:</p>\n<pre><code class=\"language-ts\">var foo = &#x3C;foo>bar;\n</code></pre>\n<p>Ini menegaskan variabel <code>bar</code> memiliki tipe <code>foo</code>.\nSejak TypeScript juga menggunakan kurung siku untuk penegasan tipe, mengkombinasikannya dengan sintaks JSX akan menimbulkan kesulitan tertentu. Hasilnya, TypeScript tidak membolehkan penggunaan kurung siku untuk penegasan tipe pada berkas <code>.tsx</code>.</p>\n<p>Karena sintaks diatas tidak bisa digunakan pada berkas <code>.tsx</code>, maka alternatif untuk penegasan tipe dapat menggunakan operator <code>as</code>.\nContohnya dapat dengan mudah ditulis ulang dengan operator <code>as</code>.</p>\n<pre><code class=\"language-ts\">var foo = bar as foo;\n</code></pre>\n<p>Operator <code>as</code> tersedia dikedua jenis berkas, <code>.ts</code> dan <code>.tsx</code>, dan memiliki perlakuan yang sama seperti penegasan tipe menggunakan kurung siku.</p>\n<h2 id=\"pemeriksaan-tipe\" style=\"position:relative;\"><a href=\"#pemeriksaan-tipe\" aria-label=\"pemeriksaan tipe permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pemeriksaan Tipe</h2>\n<p>Urutan yang harus dimengerti mengenai pemeriksaan tipe di JSX, yaitu pertama Anda harus memahami perbedaan antara elemen intrinsik dan elemen berbasiskan nilai. Terdapat sebuah ekspresi <code>&#x3C;expr /></code> dan <code>expr</code> yang mungkin mengacu pada suatu hal yang intrinsik pada suatu lingkungan (misalnya <code>div</code> atau <code>span</code> dalam lingkungan DOM) atau pada komponen custom yang telah Anda buat.\nIni penting karena dua alasan berikut:</p>\n<ol>\n<li>Untuk React, elemen intrinsik dianggap sebagai string (<code>React.createElement(\"div\")</code>), sedangkan komponen yang Anda buat bukan (<code>React.createElement(MyComponent)</code>).</li>\n<li>Type dari atribut yang dilewatkan ke elemen JSX seharusnya terlihat berbeda.\nAtribut elemen intrinsik seharusnya diketahui <em>secara intrinsik</em> sedangkan komponen akan seperti ingin untuk menentukan kumpulan atribut mereka sendiri.</li>\n</ol>\n<p>TypeScript menggunakan <a href=\"http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components\">beberapa convention yang dengan React</a> untuk membedakannya.\nElemen intrinsik selalu dimulai dengan huruf kecil, dan elemen berbasiskan nilai selalu dimulai dengan huruf besar.</p>\n<h2 id=\"elemen-intrinsik\" style=\"position:relative;\"><a href=\"#elemen-intrinsik\" aria-label=\"elemen intrinsik permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Elemen intrinsik</h2>\n<p>Elemen intrinsik dicari pada <em>interface</em> khusus, yaitu <code>JSX.IntrinsicElements</code>.\nStandarnya, jika <em>interface</em> ini tidak ditentukan, maka apapun yang terjadi dan elemen intrinsik tidak akan diperiksa tipenya.\nNamun, jika <em>interface</em> ini ada, maka nama elemen intrinsik akan dicari sebagai properti di <em>interface</em> <code>JSX.IntrinsicElements</code>.\nContohnya:</p>\n<pre><code class=\"language-ts\">declare namespace JSX {\n  interface IntrinsicElements {\n    foo: any;\n  }\n}\n\n&#x3C;foo />; // ok\n&#x3C;bar />; // galat\n</code></pre>\n<p>Pada contoh diatas, <code>&#x3C;foo /></code> akan berjalan dengan baik, tapi <code>&#x3C;bar /></code> akan menghasilkan galat, karena <code>&#x3C;bar /></code> tidak ditentukan pada <em>interface</em> <code>JSX.IntrinsicElements</code>.</p>\n<blockquote>\n<p>Catatan: Anda juga bisa menentukan <em>indexer</em> untuk mendapatkan seluruh elemen bertipe string didalam <code>JSX.IntrinsicElements</code>, seperti berikut:</p>\n</blockquote>\n<pre><code class=\"language-ts\">declare namespace JSX {\n  interface IntrinsicElements {\n    [elemName: string]: any;\n  }\n}\n</code></pre>\n<h2 id=\"elemen-berbasiskan-nilai\" style=\"position:relative;\"><a href=\"#elemen-berbasiskan-nilai\" aria-label=\"elemen berbasiskan nilai permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Elemen Berbasiskan Nilai</h2>\n<p>Elemen berbasiskan nilai akan dicari oleh <em>identifier</em> yang ada pada sebuah <em>scope</em>.</p>\n<pre><code class=\"language-ts\">import MyComponent from \"./myComponent\";\n\n&#x3C;MyComponent />; // ok\n&#x3C;SomeOtherComponent />; // galat\n</code></pre>\n<p>Terdapat dua cara untuk mendefinisikan sebuah elemen berbasiskan nilai, yaitu:</p>\n<ol>\n<li><em>Function Component</em> (FC)</li>\n<li><em>Class Component</em></li>\n</ol>\n<p>Karena kedua jenis elemen berbasis nilai ini tidak dapat dibedakan satu sama lain dalam ekspresi JSX, maka pertama TS akan mencoba menyelesaikan ekspresi tersebut sebagai <em>Function Component</em> menggunakan <em>overloading</em>. Jika proses berhasil, maka TS selesai menyelesaikan ekspresi ke deklarasinya. Jika gagal untuk menyelesaikan sebagai <em>Function Component</em>, maka TS kemudian akan mencoba untuk menyelesaikannya sebagai <em>Class Component</em>. Jika gagal, TS akan melaporkan kesalahan.</p>\n<h3 id=\"function-component\" style=\"position:relative;\"><a href=\"#function-component\" aria-label=\"function component permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Function Component</em></h3>\n<p>Seperti namanya, komponen ini didefinisikan menggunakan fungsi JavaScript dimana argumen pertamanya adalah sebuah <code>props</code> objek.\nTS memberlakukan bahwa tipe kembaliannya harus dapat diberikan ke <code>JSX.Element</code>.</p>\n<pre><code class=\"language-ts\">interface FooProp {\n  name: string;\n  X: number;\n  Y: number;\n}\n\ndeclare function AnotherComponent(prop: {name: string});\nfunction ComponentFoo(prop: FooProp) {\n  return &#x3C;AnotherComponent name={prop.name} />;\n}\n\nconst Button = (prop: {value: string}, context: { color: string }) => &#x3C;button>\n</code></pre>\n<p>Karena <em>Function Component</em> adalah fungsi JavaScript, maka fungsi overload dapat digunakan di sini:</p>\n<pre><code class=\"language-ts\">interface ClickableProps {\n  children: JSX.Element[] | JSX.Element\n}\n\ninterface HomeProps extends ClickableProps {\n  home: JSX.Element;\n}\n\ninterface SideProps extends ClickableProps {\n  side: JSX.Element | string;\n}\n\nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SideProps): JSX.Element {\n  ...\n}\n</code></pre>\n<blockquote>\n<p>Catatan: <em>Function Component</em> sebelumnya dikenal sebagai <em>Stateless Function Component</em> (SFC). Karena <em>Function Component</em> tidak dapat lagi dianggap <em>stateless</em> di versi terbaru react, jenis <code>SFC</code> dan aliasnya<code>StatelessComponent</code> tidak digunakan lagi.</p>\n</blockquote>\n<h3 id=\"class-component\" style=\"position:relative;\"><a href=\"#class-component\" aria-label=\"class component permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Class Component</em></h3>\n<p>Ini memungkinkan untuk mendefinisikan tipe dari <em>class component</em>.\nNamun, untuk melakukannya, yang terbaik adalah memahami dua istilah baru berikut: <em>type class elemen</em> dan <em>type instance elemen</em>.</p>\n<p>Jika terdapat <code>&#x3C;Expr /></code>, maka <em>type class elemennya</em> adalah <code>Expr</code>.\nJadi pada contoh diatas, jika <code>MyComponent</code> adalah <em>class</em> ES6, maka tipe <em>class</em>-nya adalah konstruktor dan <em>static</em> dari <em>class</em> tersebut.\nJika <code>MyComponent</code> adalah factory function, maka tipe <em>class</em>-nya adalah fungsi itu sendiri.</p>\n<p>Setelah tipe class dibuat, tipe <em>instance</em> ditentukan oleh gabungan tipe kembalian dari konstruksi tipe <em>class</em> atau <em>call signature</em> (mana saja yang ada).\nJadi sekali lagi, dalam kasus kelas ES6, jenis instans adalah jenis instans kelas itu, dan dalam kasus <em>factory function</em>, itu akan menjadi jenis nilai yang dikembalikan dari fungsi tersebut.</p>\n<pre><code class=\"language-ts\">class MyComponent {\n  render() {}\n}\n\n// menggunakan konstruksi signature\nvar myComponent = new MyComponent();\n\n// tipe class elemen => MyComponent\n// tipe instance elemen => { render: () => void }\n\nfunction MyFactoryFunction() {\n  return {\n    render: () => {},\n  };\n}\n\n// menggunakan call signature\nvar myComponent = MyFactoryFunction();\n\n// tipe class elemen => FactoryFunction\n// tipe instance elemen => { render: () => void }\n</code></pre>\n<p>Tipe elemen <em>instance</em> itu menarik, karena ini harus dapat di-<em>assign</em> ke <code>JSX.ElementClass</code> atau hasilnya akan galat.\nStandarnya <code>JSX.ElementClass</code> adalah <code>{}</code>, tetapi ini bisa ditambah untuk membatasi penggunaan JSX hanya untuk jenis yang sesuai dengan interface yang tepat.</p>\n<pre><code class=\"language-ts\">declare namespace JSX {\n  interface ElementClass {\n    render: any;\n  }\n}\n\nclass MyComponent {\n  render() {}\n}\nfunction MyFactoryFunction() {\n  return { render: () => {} };\n}\n\n&#x3C;MyComponent />; // ok\n&#x3C;MyFactoryFunction />; // ok\n\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n  return {};\n}\n\n&#x3C;NotAValidComponent />; // galat\n&#x3C;NotAValidFactoryFunction />; // galat\n</code></pre>\n<h2 id=\"pemeriksaan-tipe-atribut\" style=\"position:relative;\"><a href=\"#pemeriksaan-tipe-atribut\" aria-label=\"pemeriksaan tipe atribut permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pemeriksaan Tipe Atribut</h2>\n<p>Langkah pertama untuk memeriksa tipe atribut adalah menentukan tipe atribut elemen.\nIni sedikit berbeda antara elemen intrinsik dan berbasis nilai.</p>\n<p>Untuk elemen intrinsik, ini adalah tipe dari properti pada <code>JSX.IntrinsicElements</code></p>\n<pre><code class=\"language-ts\">declare namespace JSX {\n  interface IntrinsicElements {\n    foo: { bar?: boolean };\n  }\n}\n\n// tipe atribut elemen untuk 'foo' is '{bar?: boolean}'\n&#x3C;foo bar />;\n</code></pre>\n<p>Untuk elemen berbasis nilai, ini sedikit lebih kompleks.\nIni ditentukan oleh tipe dari properti pada <em>type elemen instance</em> yang telah ditentukan.\nProperti mana yang digunakan untuk ditentukan oleh <code>JSX.ElementAttributesProperty</code>.\nIni harus dideklarasikan dengan satu properti.\nNama properti itu kemudian digunakan.\nMulai TypeScript 2.8, jika <code>JSX.ElementAttributesProperty</code> tidak disediakan, jenis parameter pertama dari konstruktor elemen kelas atau pemanggilan <em>Function Component</em> akan digunakan sebagai gantinya.</p>\n<pre><code class=\"language-ts\">declare namespace JSX {\n  interface ElementAttributesProperty {\n    props; // menentukan nama properti yang akan digunakan\n  }\n}\n\nclass MyComponent {\n  // menentukan properti pada tipe instance elemen\n  props: {\n    foo?: string;\n  };\n}\n\n// tipe atribut elemen untuk 'MyComponent' adalah '{foo?: string}'\n&#x3C;MyComponent foo=\"bar\" />;\n</code></pre>\n<p>Tipe atribut elemen digunakan untuk memeriksa atribut di JSX.\nProperti opsional dan wajib telah didukung.</p>\n<pre><code class=\"language-ts\">declare namespace JSX {\n  interface IntrinsicElements {\n    foo: { requiredProp: string; optionalProp?: number };\n  }\n}\n\n&#x3C;foo requiredProp=\"bar\" />; // ok\n&#x3C;foo requiredProp=\"bar\" optionalProp={0} />; // ok\n&#x3C;foo />; // galat, tidak ada requiredProp\n&#x3C;foo requiredProp={0} />; // galat, requiredProp seharusnya bertipe string\n&#x3C;foo requiredProp=\"bar\" unknownProp />; // galat, unknownProp tidak ada\n&#x3C;foo requiredProp=\"bar\" some-unknown-prop />; // ok, karena 'some-unknown-prop' bukan identifier yang valid\n</code></pre>\n<blockquote>\n<p>Catatan: Jika nama atribut bukan <em>identifier</em> JS yang valid (seperti atribut <code>data- *</code>), itu tidak dianggap sebagai kesalahan jika tidak ditemukan dalam tipe atribut elemen.</p>\n</blockquote>\n<p>Selain itu, antarmuka <code>JSX.IntrinsicAttributes</code> dapat digunakan untuk menentukan properti tambahan yang digunakan oleh <em>framework</em> JSX yang umumnya tidak digunakan oleh props atau argumen komponen - misalnya <code>key</code> di React. Mengkhususkan lebih lanjut, tipe generik <code>JSX.IntrinsicClassAttributes&#x3C;T></code> juga dapat digunakan untuk menetapkan tipe atribut tambahan yang sama hanya untuk <em>class component</em> (dan bukan <em>function component</em>). Dalam tipe ini, parameter generik sesuai dengan tipe <em>instance class</em>. Di React, ini digunakan untuk mengizinkan atribut <code>ref</code> dengan tipe <code>Ref &#x3C;T></code>. Secara umum, semua properti pada interface ini harus bersifat opsional, kecuali Anda bermaksud agar pengguna <em>framework</em> JSX Anda perlu menyediakan beberapa atribut pada setiap tag.</p>\n<p><em>Spread operator</em> juga bekerja:</p>\n<pre><code class=\"language-ts\">var props = { requiredProp: \"bar\" };\n&#x3C;foo {...props} />; // ok\n\nvar badProps = {};\n&#x3C;foo {...badProps} />; // galat\n</code></pre>\n<h2 id=\"pemeriksaan-children-type\" style=\"position:relative;\"><a href=\"#pemeriksaan-children-type\" aria-label=\"pemeriksaan children type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pemeriksaan <em>Children Type</em></h2>\n<p>Di TypeScript 2.3, TS mengenalkan pemeriksaan tipe pada <em>children</em>. <em>Children</em> adalah properti khusus di <em>type atribut elemen</em> dimana <em>child</em> <em>JSXExpression</em> diambil untuk dimasukkan ke atribut.\nMirip dengan bagaimana menggunakan <code>JSX.ElementAttributesProperty</code> untuk menentukan nama dari <em>props</em>, TS menggunakan <code>JSX</code>.\n<code>JSX.ElementChildrenAttribute</code> harus dideklarasikan dengan properti tunggal.</p>\n<pre><code class=\"language-ts\">declare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {}; // menentukan nama children untuk digunakan\n  }\n}\n</code></pre>\n<pre><code class=\"language-ts\">&#x3C;div>\n  &#x3C;h1>Hello&#x3C;/h1>\n&#x3C;/div>;\n\n&#x3C;div>\n  &#x3C;h1>Hello&#x3C;/h1>\n  World\n&#x3C;/div>;\n\nconst CustomComp = (props) => &#x3C;div>{props.children}&#x3C;/div>\n&#x3C;CustomComp>\n  &#x3C;div>Hello World&#x3C;/div>\n  {\"This is just a JS expression...\" + 1000}\n&#x3C;/CustomComp>\n</code></pre>\n<p>Anda bisa menentukan tipe dari <em>children</em> seperti atribut lainnya. Ini akan mengganti tipe standarnya, misalnya <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react\">React typings</a> jika Anda menggunakannya.</p>\n<pre><code class=\"language-ts\">interface PropsType {\n  children: JSX.Element\n  name: string\n}\n\nclass Component extends React.Component&#x3C;PropsType, {}> {\n  render() {\n    return (\n      &#x3C;h2>\n        {this.props.children}\n      &#x3C;/h2>\n    )\n  }\n}\n\n// OK\n&#x3C;Component name=\"foo\">\n  &#x3C;h1>Hello World&#x3C;/h1>\n&#x3C;/Component>\n\n// Error: children adalah tipe JSX.Element, bukan array dari JSX.Element.\n&#x3C;Component name=\"bar\">\n  &#x3C;h1>Hello World&#x3C;/h1>\n  &#x3C;h2>Hello World&#x3C;/h2>\n&#x3C;/Component>\n\n// Error: children adalah tipe JSX.Element, bukan array dari JSX.Element maupun string.\n&#x3C;Component name=\"baz\">\n  &#x3C;h1>Hello&#x3C;/h1>\n  World\n&#x3C;/Component>\n</code></pre>\n<h2 id=\"tipe-hasil-jsx\" style=\"position:relative;\"><a href=\"#tipe-hasil-jsx\" aria-label=\"tipe hasil jsx permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tipe hasil JSX</h2>\n<p>Secara standar, hasil dari ekspresi JSX bertipe <code>any</code>.\nAnda bisa menyesuaikan tipe dengan menentukan <em>interface</em> <code>JSX.Element</code>.\nNamun, tidak mungkin untuk mengambil informasi tipe tentang elemen, atribut atau turunan dari JSX dari <em>interface</em> ini.\nItu adalah <em>black box</em>.</p>\n<h2 id=\"menyematkan-ekspresi\" style=\"position:relative;\"><a href=\"#menyematkan-ekspresi\" aria-label=\"menyematkan ekspresi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Menyematkan Ekspresi</h2>\n<p>JSX memungkinkan Anda untuk menyematkan ekspresi di antara tag dengan mengapit ekspresi dengan kurung kurawal (<code>{}</code>).</p>\n<pre><code class=\"language-ts\">var a = (\n  &#x3C;div>\n    {[\"foo\", \"bar\"].map((i) => (\n      &#x3C;span>{i / 2}&#x3C;/span>\n    ))}\n  &#x3C;/div>\n);\n</code></pre>\n<p>Kode di atas akan menghasilkan kesalahan karena Anda tidak dapat membagi <em>string</em> dengan angka.\n<em>Output</em>-nya, saat menggunakan opsi <code>preserve</code>, terlihat seperti:</p>\n<pre><code class=\"language-ts\">var a = (\n  &#x3C;div>\n    {[\"foo\", \"bar\"].map(function (i) {\n      return &#x3C;span>{i / 2}&#x3C;/span>;\n    })}\n  &#x3C;/div>\n);\n</code></pre>\n<h2 id=\"integrasi-react\" style=\"position:relative;\"><a href=\"#integrasi-react\" aria-label=\"integrasi react permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Integrasi React</h2>\n<p>Untuk menggunakan JSX dengan React, Anda harus menggunakan <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react\">React typings</a>. Typings ini mendefinisikan <em>namespace</em> <code>JSX</code> dengan tepat untuk digunakan dengan React.</p>\n<pre><code class=\"language-ts\">/// &#x3C;reference path=\"react.d.ts\" />\n\ninterface Props {\n  foo: string;\n}\n\nclass MyComponent extends React.Component&#x3C;Props, {}> {\n  render() {\n    return &#x3C;span>{this.props.foo}&#x3C;/span>;\n  }\n}\n\n&#x3C;MyComponent foo=\"bar\" />; // ok\n&#x3C;MyComponent foo={0} />; // galat\n</code></pre>\n<h2 id=\"factory-function\" style=\"position:relative;\"><a href=\"#factory-function\" aria-label=\"factory function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Factory Function</h2>\n<p>Factory function yang digunakan oleh opsi kompilator <code>jsx: react</code> dapat dikonfigurasi. Ini dapat disetel menggunakan opsi baris perintah <code>jsxFactory</code>, atau komentar <code>@jsx</code> sebaris untuk menyetelnya pada basis per berkas. Misalnya, jika Anda menyetel <code>jsxFactory</code> ke <code>createElement</code>, <code>&#x3C;div /></code> akan melakukannya sebagai <code>createElement(\"div\")</code> bukan <code>React.createElement(\"div\")</code>.</p>\n<p>Versi pragma komentar dapat digunakan seperti itu (dalam TypeScript 2.8):</p>\n<pre><code class=\"language-ts\">import preact = require(\"preact\");\n/* @jsx preact.h */\nconst x = &#x3C;div />;\n</code></pre>\n<p>akan menjadi:</p>\n<pre><code class=\"language-ts\">const preact = require(\"preact\");\nconst x = preact.h(\"div\", null);\n</code></pre>\n<p><em>Factory</em> yang dipilih juga akan mempengaruhi di mana <em>namespace</em> <code>JSX</code> dicari (untuk informasi pemeriksaan tipe) sebelum kembali ke <em>global</em>. Jika <em>factory</em> ditentukan sebagai <code>React.createElement</code> (standar), kompilator akan memeriksa <code>React.JSX</code> sebelum memeriksa <code>JSX</code> <em>global</em>. Jika <em>factory</em> ditentukan sebagai <code>h</code>, maka ia akan memeriksa <code>h.JSX</code> sebelum <code>JSX</code> <em>global</em>.</p>","headings":[{"value":"Dasar Penggunaan","depth":2},{"value":"Opeartor as","depth":2},{"value":"Pemeriksaan Tipe","depth":2},{"value":"Elemen intrinsik","depth":2},{"value":"Elemen Berbasiskan Nilai","depth":2},{"value":"Function Component","depth":3},{"value":"Class Component","depth":3},{"value":"Pemeriksaan Tipe Atribut","depth":2},{"value":"Pemeriksaan Children Type","depth":2},{"value":"Tipe hasil JSX","depth":2},{"value":"Menyematkan Ekspresi","depth":2},{"value":"Integrasi React","depth":2},{"value":"Factory Function","depth":2}],"frontmatter":{"permalink":"/id/docs/handbook/jsx.html","title":"JSX","disable_toc":null,"handbook":null,"oneline":"Menggunakan JSX dengan TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-jsx","slug":"/id/docs/handbook/jsx.html","repoPath":"/packages/documentation/copy/id/reference/JSX.md","lang":"id","modifiedTime":"2021-05-31T12:18:20.863Z"}},"staticQueryHashes":[]}