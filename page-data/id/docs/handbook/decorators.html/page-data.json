{"componentChunkName":"component---src-templates-documentation-tsx","path":"/id/docs/handbook/decorators.html","result":{"data":{"markdownRemark":{"id":"778c0d25-4f4a-5480-89b9-da9ee46c2a29","excerpt":"Pengenalan Dengan pengenalan Kelas-kelas yang ada di TypeScript dan ES6, sekarang ada skenario tertentu yang memerlukan fitur tambahan untuk mendukung anotasi…","html":"<h2 id=\"pengenalan\" style=\"position:relative;\"><a href=\"#pengenalan\" aria-label=\"pengenalan permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pengenalan</h2>\n<p>Dengan pengenalan Kelas-kelas yang ada di TypeScript dan ES6, sekarang ada skenario tertentu yang memerlukan fitur tambahan untuk mendukung anotasi atau modifikasi kelas dan anggota kelas.\n<em>Decorators</em> menyediakan cara untuk menambahkan anotasi-anotasi dan sebuah sintaks pemrogragaman meta untuk deklarasi kelas dan anggota kelas.\n<em>Decorators</em> ada pada <a href=\"https://github.com/tc39/proposal-decorators\">stage 2 proposal</a> untuk JavaScript dan juga tersedia pada TypeScript sebagai fitur eksperimental.</p>\n<blockquote>\n<p>CATATAN  <em>Decorators</em> adalah fitur eksperimental yang mungkin dapat berubah ketika dirilis nanti.</p>\n</blockquote>\n<p>Untuk mengaktifkan <em>Decorators</em> eksperimental, anda harus menambahkan opsi <code>experimentalDecorators</code> ke baris perintah atau ke berkas <code>tsconfig.json</code>.</p>\n<p><strong><em>Command Line</em></strong>:</p>\n<pre><code class=\"language-shell\">tsc --target ES5 --experimentalDecorators\n</code></pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n</code></pre>\n<h2 id=\"decorator\" style=\"position:relative;\"><a href=\"#decorator\" aria-label=\"decorator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Decorator</em></h2>\n<p><em>Decorator</em> adalah jenis deklarasi khusus yang dapat dilampirkan ke <a href=\"#class-decorators\">deklarasi kelas</a>, <a href=\"#method-decorators\">method</a>, <a href=\"#accessor-decorators\">accessor</a>, <a href=\"#property-decorators\">property</a>, atau <a href=\"#parameter-decorators\">parameter</a>.\n<em>Decorators</em> menggunakan bentuk <code>@expression</code>, dimana <code>expression</code> harus mengevaluasi fungsi yang akan dipanggil saat proses dengan informasi tentang deklarasi yang didekorasi.</p>\n<p>Sebagai contoh, ada decorator <code>@sealed</code> yang mungkin kita akan menuliskan fungsi <code>sealed</code> sebagai berikut:</p>\n<pre><code class=\"language-ts\">function sealed(target) {\n  // lakukan sesuatu dengan 'target' ...\n}\n</code></pre>\n<blockquote>\n<p>CATATAN  Anda dapat melihat contoh lengkapnya di <a href=\"#class-decorators\">Decorator Kelas</a>.</p>\n</blockquote>\n<h2 id=\"decorator-factories\" style=\"position:relative;\"><a href=\"#decorator-factories\" aria-label=\"decorator factories permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Decorator Factories</em></h2>\n<p>Jika kita ingin menyesuaikan penerapan <em>decorator</em> pada sebuah deklarasi, kita dapat menuliskan sebuah <em>decorator factory</em>. <em>Decorator Factory</em> adalah sebuah fungsi yang mengembalikan ekspresi yang akan dipanggil oleh <em>decorator</em> ketika proses.</p>\n<p>Kita dapat menuliskan <em>decorator factory</em> seperti berikut:</p>\n<pre><code class=\"language-ts\">function color(value: string) {\n  // ini adalah decorator factory\n  return function (target) {\n    // ini adalah decorator\n    // lakukan sesuatu dengan 'target' dan 'value'...\n  };\n}\n</code></pre>\n<blockquote>\n<p>CATATAN  Anda dapat melihat contoh lengkap dari penggunaan <em>decorator factory</em> di <a href=\"#method-decorators\"><em>Method Decorators</em></a></p>\n</blockquote>\n<h2 id=\"komposisi-decorator\" style=\"position:relative;\"><a href=\"#komposisi-decorator\" aria-label=\"komposisi decorator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Komposisi <em>Decorator</em></h2>\n<p>Lebih dari satu <em>decorator</em> dapat diterapkan pada sebuah deklarasi, seperti contoh berikut:</p>\n<ul>\n<li>\n<p>Penerapan dengan satu baris:</p>\n<pre><code class=\"language-ts\">@f @g x\n</code></pre>\n</li>\n<li>\n<p>Penerapan lebih dari satu baris:</p>\n<pre><code class=\"language-ts\">@f\n@g\nx\n</code></pre>\n</li>\n</ul>\n<p>Ketika lebih dari satu <em>decorator</em> diterapkan ke sebuah deklarasi, evaluasi yang dilakukan mirip seperti <a href=\"http://wikipedia.org/wiki/Function_composition\">fungsi komposisi pada matematika</a>. Pada model ini, ketika mengkomposisikan fungsi <em>f</em> dan <em>g</em>, maka akan menjadi (<em>f</em> ∘ <em>g</em>)(<em>x</em>) yang sama dengan <em>f</em>(<em>g</em>(<em>x</em>)).</p>\n<p>Dengan demikian, langkah-langkah berikut dilakukan saat mengevaluasi beberapa <em>decorator</em> pada satu deklarasi di TypeScript:</p>\n<ol>\n<li>Ekspresi untuk setiap <em>decorator</em> dievaluasi dari atas ke bawah.</li>\n<li>Hasilnya kemudian disebut sebagai fungsi dari bawah ke atas.</li>\n</ol>\n<p>JIka kita menggunakan <a href=\"#decorator-factories\"><em>decorator factories</em></a>, kita dapat mengamati urutan evaluasi ini dengan contoh berikut:</p>\n<pre><code class=\"language-ts\">function f() {\n  console.log(\"f(): evaluated\");\n  return function (\n    target,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    console.log(\"f(): called\");\n  };\n}\n\nfunction g() {\n  console.log(\"g(): evaluated\");\n  return function (\n    target,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    console.log(\"g(): called\");\n  };\n}\n\nclass C {\n  @f()\n  @g()\n  method() {}\n}\n</code></pre>\n<p>Yang akan mencetak keluaran ini ke <em>console</em>:</p>\n<pre><code class=\"language-shell\">f(): evaluated\ng(): evaluated\ng(): called\nf(): called\n</code></pre>\n<h2 id=\"evaluasi-decorator\" style=\"position:relative;\"><a href=\"#evaluasi-decorator\" aria-label=\"evaluasi decorator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Evaluasi <em>Decorator</em></h2>\n<p>Ada urutan yang jelas tentang bagaimana <em>decorator</em> diterapkan ke berbagai deklarasi yang ada di dalam kelas:</p>\n<ol>\n<li><em>Parameter Decorators</em>, diikuti oleh <em>Method</em>, <em>Accessor</em>, atau <em>Property Decorators</em> diterapkan untuk setiap anggota instance.</li>\n<li><em>Parameter Decorators</em>, diikuti oleh <em>Method</em>, <em>Accessor</em>, atau <em>Property Decorators</em> diterapkan untuk setiap anggota statis.</li>\n<li><em>Parameter Dekorator</em> diterapkan untuk konstruktor.</li>\n<li><em>Class Decorators</em> diterapkan untuk kelas.</li>\n</ol>\n<h2 id=\"decorator-kelas\" style=\"position:relative;\"><a href=\"#decorator-kelas\" aria-label=\"decorator kelas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Decorator</em> Kelas</h2>\n<p><em>Class Decorator</em> dideklarasikan tepat sebelum deklarasi kelas.\n<em>Decorator</em> kelas diterapkan ke konstruktor kelas dan dapat digunakan untuk mengamati, memodifikasi, atau mengganti definisi kelas.\n<em>Decorator</em> kelas tidak dapat digunakan dalam berkas deklarasi, atau dalam konteks ambien lainnya (seperti pada kelas <code>deklarasi</code>).</p>\n<p>Ekspresi untuk <em>decorator</em> kelas akan dipanggil sebagai fungsi pada waktu proses, dengan konstruktor kelas yang didekorasi sebagai satu-satunya argumennya.</p>\n<p>Jika <em>decorator</em> kelas mengembalikan nilai, deklarasi kelas akan diganti dengan fungsi konstruktor yang disediakan.</p>\n<blockquote>\n<p>CATATAN  Jika Anda memilih untuk mengembalikan fungsi konstruktor baru, Anda harus berhati-hati dalam mempertahankan prototipe asli.\nLogika yang menerapkan dekorator pada waktu proses <strong>tidak akan</strong> melakukannya untukmu.</p>\n</blockquote>\n<p>Berikut ini adalah contoh <em>decorator</em> kelas (<code>@sealed</code>) yang diterapkan ke kelas <em><code>Greeter</code></em>:</p>\n<pre><code class=\"language-ts\">@sealed\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n</code></pre>\n<p>Kita dapat mendefinisikan <em>decorator</em> <code>@sealed</code> menggunakan deklarasi fungsi berikut:</p>\n<pre><code class=\"language-ts\">function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n</code></pre>\n<p>Ketika <code>@sealed</code> dijalankan, itu akan menyegel konstruktor dan prototipenya.</p>\n<p>Selanjutnya kita memiliki contoh bagaimana menimpa konstruktor.</p>\n<pre><code class=\"language-ts\">function classDecorator&#x3C;T extends { new (...args: any[]): {} }>(\n  constructor: T\n) {\n  return class extends constructor {\n    newProperty = \"new property\";\n    hello = \"override\";\n  };\n}\n\n@classDecorator\nclass Greeter {\n  property = \"property\";\n  hello: string;\n  constructor(m: string) {\n    this.hello = m;\n  }\n}\n\nconsole.log(new Greeter(\"world\"));\n</code></pre>\n<h2 id=\"method-decorators\" style=\"position:relative;\"><a href=\"#method-decorators\" aria-label=\"method decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Method Decorators</h2>\n<p><em>Method Decorator</em> dideklarasikan tepat sebelum deklarasi <em>method</em>.\nDekorator diterapkan ke <em>Property Descriptor</em> untuk method, yang dapat digunakan untuk mengamati, memodifikasi, atau mengganti definisi <em>method</em>.\n<em>Method Decorator</em> tidak dapat digunakan dalam berkas deklarasi, saat kelebihan beban, atau dalam konteks ambien lainnya (seperti dalam kelas <code>declare</code>).</p>\n<p>Ekspresi untuk <em>method decorator</em> akan dipanggil sebagai fungsi pada waktu proses, dengan tiga argumen berikut:</p>\n<ol>\n<li>Bisa memiliki fungsi konstruktor kelas untuk anggota statis, atau prototipe kelas untuk anggota <em>instance</em>.</li>\n<li>Nama anggota.</li>\n<li>The <em>Property Descriptor</em> untuk anggota.</li>\n</ol>\n<blockquote>\n<p>CATATAN  <em>Property Descriptor</em> akan menjadi <code>undefined</code> jika target skripmu dibawah <code>ES5</code>.</p>\n</blockquote>\n<p>Jika <em>method decorator</em> mengembalikan sebuah nilai, maka akan digunakan sebagai <em>Property Descriptor</em> untuk method.</p>\n<blockquote>\n<p>CATATAN  Nilai yang dikembalikan akan dibiarkan, jika target kodemu dibawah <code>ES5</code>.</p>\n</blockquote>\n<p>Berikut adalah contoh penerapan <em>method decorator</em> (<code>@enumerable</code>) ke method yang ada pada kelas <em><code>Greeter</code></em>:</p>\n<pre><code class=\"language-ts\">class Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n</code></pre>\n<p>Kita dapat mendefinisikan <em>decorator</em> <code>@enumerable</code> menggunakan fungsi deklarasi berikut:</p>\n<pre><code class=\"language-ts\">function enumerable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    descriptor.enumerable = value;\n  };\n}\n</code></pre>\n<p><em>Decorator</em> <code>@enumerable(false)</code> disini adalah sebuah <a href=\"#decorator-factories\"><em>decorator factory</em></a>.\nKetika <em>decorator</em> <code>@enumerable(false)</code> dipanggil, ia akan merubah <em><code>enumerable</code></em> properti dari properti <em>descriptor</em>.</p>\n<h2 id=\"decorator-aksesor\" style=\"position:relative;\"><a href=\"#decorator-aksesor\" aria-label=\"decorator aksesor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Decorator</em> Aksesor</h2>\n<p>Sebuah <em>Accessor Decorator</em> dideklarasikan tepat sebelum sebuah deklarasi aksesor.\n<em>Decorator</em> aksesor diterapkan ke <em>Property Descriptor</em> untuk aksesor dan dapat digunakan untuk mengamati, memodifikasi, atau mengganti definisi aksesor.\n<em>Decorator</em> aksesor tidak dapat digunakan dalam deklarasi berkas, atau dalam konteks ambien lainnya (seperti dalam kelas <code>declare</code>).</p>\n<blockquote>\n<p>CATATAN  TypeScript melarang penerapan <em>decorator</em> ke aksesor <code>get</code> dan <code>set</code> untuk <em>single</em> member.\nSebaliknya, semua <em>decorator</em> untuk anggota harus diterapkan ke pengakses pertama yang ditentukan dalam urutan dokumen.\nIni karena <em>decorator</em> berlaku untuk <em>Property Descriptor</em>, yang menggabungkan aksesor <code>get</code> dan <code>set</code>, bukan setiap deklarasi secara terpisah.</p>\n</blockquote>\n<p>Ekspresi untuk <em>decorator</em> pengakses akan dipanggil sebagai fungsi pada waktu proses, dengan tiga argumen berikut:</p>\n<ol>\n<li>Bisa memiliki fungsi konstruktor kelas untuk anggota statis, atau prototipe kelas untuk anggota <em>instance</em>.</li>\n<li>Nama anggota.</li>\n<li>The <em>Property Descriptor</em> untuk anggota.</li>\n</ol>\n<blockquote>\n<p>CATATAN  <em>Property Descriptor</em> akan menjadi <code>undefined</code>, jika target skripmu dibawah <code>ES5</code>.</p>\n</blockquote>\n<p>Jika aksesor <em>decorator</em> mengembalikan sebuah nilai, ia akan digunakan sebagai <em>Property Descriptor</em> untuk anggota.</p>\n<blockquote>\n<p>CATATAN  Nilai yang dikembalikan akan dibiarkan, jika target skripmu dibawah <code>ES5</code>.</p>\n</blockquote>\n<p>Berikut ada contoh penerapan aksesor <em>decorator</em> (<code>@configurable</code>) ke anggota kelas <em><code>Point</code></em>:</p>\n<pre><code class=\"language-ts\">class Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n\n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}\n</code></pre>\n<p>Kita dapat mendefinisikan <em>decorator</em> <code>@configurable</code> menggunakan deklarasi fungsi berikut:</p>\n<pre><code class=\"language-ts\">function configurable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    descriptor.configurable = value;\n  };\n}\n</code></pre>\n<h2 id=\"property-decorators\" style=\"position:relative;\"><a href=\"#property-decorators\" aria-label=\"property decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Property Decorators</em></h2>\n<p>Sebuah <em>Property Decorator</em> dideklarasikan tepat sebelum deklarasi properti.\n<em>Property Decorator</em> tidak dapat digunakan dalam deklarasi berkas, atau dalam konteks ambien lainnya (seperti dalam kelas <code>declare</code>).</p>\n<p>Ekspresi untuk properti decorator akan dipanggil sebagai fungsi pada waktu proses, dengan dua argumen berikut:</p>\n<ol>\n<li>Dapat berupa fungsi konstruktor kelas untuk anggota statis, atau prototipe kelas untuk anggota <em>instance</em>.</li>\n<li>Nama anggota.</li>\n</ol>\n<blockquote>\n<p>CATATAN  <em>Property Descriptior</em> tidak menyediakan sebuah argumen untuk properti <em>decorator</em> karena bergantung tentang bagaimana properti <em>decorator</em> diinisialisasi pada TypeScript.\nIni karena, saat ini tidak ada mekanisme untuk mendeskripsikan sebuah <em>instance</em> properti ketika mendefinisikan anggota dari sebuah prototipe, dan tidak ada cara untuk mengamati atau memodifikasi <em>initializer</em> untuk properti. Dan nilai kembalian juga akan dibiarkan.\nSehingga, sebuah properti <em>decorator</em> hanya bisa digunakan untuk mengamati properti dengan nama yang spesifik, yang telah dideklarasikan pada sebuah kelas.</p>\n</blockquote>\n<p>Kita dapat menggunakan informasi tersebut untuk memantau properti metadata, seperti pada contoh berikut:</p>\n<pre><code class=\"language-ts\">class Greeter {\n  @format(\"Hello, %s\")\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet() {\n    let formatString = getFormat(this, \"greeting\");\n    return formatString.replace(\"%s\", this.greeting);\n  }\n}\n</code></pre>\n<p>Kemudian, kita dapat mendefinisikan <em>decorator</em> <code>@format</code> dan fungsi <code>getFormat</code> dengan menggunakan deklarasi fungsi berikut:</p>\n<pre><code class=\"language-ts\">import \"reflect-metadata\";\n\nconst formatMetadataKey = Symbol(\"format\");\n\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n</code></pre>\n<p><em>Decorator</em> <code>@format(\"Hello, %s\")</code> disini adalah sebuah <a href=\"#decorator-factories\">decorator factory</a>.\nKetika <code>@format(\"Hello, %s\")</code> dipanggil, ia akan menambahkan properti metadata menggunakan fungsi <code>Reflect.metadata</code> dari pustaka <code>reflect-metadata</code>.\nKetika <code>getFormat</code> dipanggil, ia akan membaca format dari nilai <em>metadata</em>-nya.</p>\n<blockquote>\n<p>CATATAN  Contoh ini membutuhkan pustaka <code>reflect-metadata</code>.\nLihat <a href=\"#metadata\">Metadata</a> untuk informasi lebih lanjut mengenai pustaka <code>reflect-metadata</code>.</p>\n</blockquote>\n<h2 id=\"parameter-decorators\" style=\"position:relative;\"><a href=\"#parameter-decorators\" aria-label=\"parameter decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Parameter Decorators</em></h2>\n<p><em>Parameter Decorator</em> dideklarasikan tepat sebelum a parameter dideklarasikan.\n<em>Parameter decorator</em> diterapkan ke fungsi konstruktor pada kelas atau saat deklarasi <em>method</em>.\n<em>Parameter decorator</em> tidak dapat digunakan dalam deklarasi berkas, overload, atau dalam konteks ambien lainnya (seperti dalam kelas <code>declare</code>).</p>\n<p>Ekspresi untuk <em>parameter decorator</em> akan dipanggil sebagai fungsi pada waktu proses, dengan tiga argumen berikut:</p>\n<ol>\n<li>Dapat berupa fungsi konstruktor kelas untuk anggota statis, atau prototipe kelas untuk anggota <em>instance</em>.</li>\n<li>Nama anggota.</li>\n<li>Indeks ordinal dari parameter dalam daftar parameter fungsi.</li>\n</ol>\n<blockquote>\n<p>CATATAN  Sebuah <em>parameter decorator</em> hanya bisa digunakan untuk mengamati sebuah parameter yang telah dideklarasikan pada sebuah method.</p>\n</blockquote>\n<p>Nilai kembalian dari <em>parameter decorator</em> akan dibiarkan.</p>\n<p>Berikut adalah contoh penggunaan <em>parameter decorator</em> (<code>@required</code>) pada anggota kelas <code>Greeter</code>:</p>\n<pre><code class=\"language-ts\">class Greeter {\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @validate\n  greet(@required name: string) {\n    return \"Hello \" + name + \", \" + this.greeting;\n  }\n}\n</code></pre>\n<p>Kemudian, kita dapat mendefinisikan <em>decorator</em> <code>@required</code> dan <code>@validate</code> menggunakan deklarasi fungsi berikut:</p>\n<pre><code class=\"language-ts\">import \"reflect-metadata\";\n\nconst requiredMetadataKey = Symbol(\"required\");\n\nfunction required(\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex: number\n) {\n  let existingRequiredParameters: number[] =\n    Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata(\n    requiredMetadataKey,\n    existingRequiredParameters,\n    target,\n    propertyKey\n  );\n}\n\nfunction validate(\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor&#x3C;Function>\n) {\n  let method = descriptor.value;\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(\n      requiredMetadataKey,\n      target,\n      propertyName\n    );\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (\n          parameterIndex >= arguments.length ||\n          arguments[parameterIndex] === undefined\n        ) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n</code></pre>\n<p><em>Decorator</em> <code>@required</code> menambahkan entri metadata yang menandakan bahwa parameter tersebut diperlukan.\n<em>Decorator</em> <code>@validate</code> kemudian akan memvalidasi semua argumen yang ada, sebelum <em>method</em>-nya dijalankan.</p>\n<blockquote>\n<p>CATATAN  Contoh ini memerlukan pustaka <code>reflect-metadata</code>\nLihat <a href=\"#metadata\">Metadata</a> untuk informasi lebih lanjut mengenai pustaka <code>reflect-metadata</code>.</p>\n</blockquote>\n<h2 id=\"metadata\" style=\"position:relative;\"><a href=\"#metadata\" aria-label=\"metadata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>Metadata</em></h2>\n<p>Beberapa contoh menggunakan pustaka <code>reflect-metadata</code> yang menambahkan <em>polyfill</em> untuk <a href=\"https://github.com/rbuckton/ReflectDecorators\">API metadata eksperimental</a>.\nPustaka ini belum menjadi bagian dari standar ECMAScript (JavaScript).\nNamun, ketika decorator secara resmi diadopsi sebagai bagian dari standar ECMAScript, ekstensi ini akan diusulkan untuk diadopsi.</p>\n<p>Anda dapat memasang pustaka ini melalui npm:</p>\n<pre><code class=\"language-shell\">npm i reflect-metadata --save\n</code></pre>\n<p>TypeScript menyertakan dukungan eksperimental untuk menghadirkan jenis <em>metadata</em> tertentu untuk deklarasi yang memiliki <em>decorator</em>.\nUntuk mengaktifkan dukungan eksperimental ini, Anda harus mengatur opsi kompilator <code>emitDecoratorMetadata</code> baik pada baris perintah atau di <code>tsconfig.json</code> Anda:</p>\n<p><strong><em>Command Line</em></strong>:</p>\n<pre><code class=\"language-shell\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n</code></pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n</code></pre>\n<p>Ketika diaktifkan, selama pustaka <code>reflect-metadata</code> di-<em>import</em>, informasi jenis <em>design-time</em> tambahan akan diekspos saat <em>runtime</em>.</p>\n<p>Kita dapat melihat action pada contoh berikut:</p>\n<pre><code class=\"language-ts\">import \"reflect-metadata\";\n\nclass Point {\n  x: number;\n  y: number;\n}\n\nclass Line {\n  private _p0: Point;\n  private _p1: Point;\n\n  @validate\n  set p0(value: Point) {\n    this._p0 = value;\n  }\n  get p0() {\n    return this._p0;\n  }\n\n  @validate\n  set p1(value: Point) {\n    this._p1 = value;\n  }\n  get p1() {\n    return this._p1;\n  }\n}\n\nfunction validate&#x3C;T>(\n  target: any,\n  propertyKey: string,\n  descriptor: TypedPropertyDescriptor&#x3C;T>\n) {\n  let set = descriptor.set;\n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n    if (!(value instanceof type)) {\n      throw new TypeError(\"Invalid type.\");\n    }\n    set.call(target, value);\n  };\n}\n</code></pre>\n<p>Kompilator TypeScript akan memasukkan informasi jenis <em>design-time</em> menggunakan <em>decorator</em> <code>@Reflect.metadata</code>.\nAnda dapat menganggapnya setara dengan TypeScript berikut:</p>\n<pre><code class=\"language-ts\">class Line {\n  private _p0: Point;\n  private _p1: Point;\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set p0(value: Point) {\n    this._p0 = value;\n  }\n  get p0() {\n    return this._p0;\n  }\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set p1(value: Point) {\n    this._p1 = value;\n  }\n  get p1() {\n    return this._p1;\n  }\n}\n</code></pre>\n<blockquote>\n<p>CATATAN  <em>Decorator</em> metadata adalah fitur <em>experimental</em> dan mungkin dapat menyebabkan gangguan pada rilis di masa mendatang.</p>\n</blockquote>","headings":[{"value":"Pengenalan","depth":2},{"value":"Decorator","depth":2},{"value":"Decorator Factories","depth":2},{"value":"Komposisi Decorator","depth":2},{"value":"Evaluasi Decorator","depth":2},{"value":"Decorator Kelas","depth":2},{"value":"Method Decorators","depth":2},{"value":"Decorator Aksesor","depth":2},{"value":"Property Decorators","depth":2},{"value":"Parameter Decorators","depth":2},{"value":"Metadata","depth":2}],"frontmatter":{"permalink":"/id/docs/handbook/decorators.html","title":"Decorators","disable_toc":null,"handbook":null,"oneline":"Ringkasan Dekorator TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-decorators","slug":"/id/docs/handbook/decorators.html","repoPath":"/packages/documentation/copy/id/reference/Decorators.md","lang":"id","modifiedTime":"2021-05-31T12:18:20.863Z"}},"staticQueryHashes":[]}