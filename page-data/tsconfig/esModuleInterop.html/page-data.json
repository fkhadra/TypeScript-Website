{"componentChunkName":"component---src-templates-tsconfig-option-one-page-tsx","path":"/tsconfig/esModuleInterop.html","result":{"pageContext":{"title":"esModuleInterop","lang":"en","html":"<p>By default (with <code>esModuleInterop</code> false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules. In doing this, there are two parts in particular which turned out to be flawed assumptions:</p>\n<ul>\n<li>a namespace import like <code>import * as moment from \"moment\"</code> acts the same as <code>const moment = require(\"moment\")</code></li>\n<li>a default import like <code>import moment from \"moment\"</code> acts the same as <code>const moment = require(\"moment\").default</code></li>\n</ul>\n<p>This mis-match causes these two issues:</p>\n<ul>\n<li>the ES6 modules spec states that a namespace import (<code>import * as x</code>) can only be an object, by having TypeScript\ntreating it the same as <code>= require(\"x\")</code> then TypeScript allowed for the import to be treated as a function and be callable. This breaks the spec’s recommendations.</li>\n<li>while accurate to the ES6 modules spec, most libraries with CommonJS/AMD/UMD modules didn’t conform as strictly as TypeScript’s implementation.</li>\n</ul>\n<p>Turning on <code>esModuleInterop</code> will fix both of these problems in the code transpiled by TypeScript. The first changes the behavior in the compiler,the second is fixed by two new helper functions which provide a shim to ensure compatibility in the emitted JavaScript:</p>\n<pre><code class=\"language-ts\">import * as fs from \"fs\";\nimport _ from \"lodash\";\n\nfs.readFileSync(\"file.txt\", \"utf8\");\n_.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n</code></pre>\n<p>With <code>esModuleInterop</code> disabled:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @noErrors\n// @showEmit\n// @esModuleInterop: false\n// @module: commonjs\nimport * as fs from \"fs\";\nimport _ from \"lodash\";\n\nfs.readFileSync(\"file.txt\", \"utf8\");\n_.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n</code></pre>\n<p>With <code>esModuleInterop</code> set to <code>true</code>:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @noErrors\n// @showEmit\n// @esModuleInterop\n// @module: commonjs\nimport * as fs from \"fs\";\nimport _ from \"lodash\";\n\nfs.readFileSync(\"file.txt\", \"utf8\");\n_.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n</code></pre>\n<p><em>Note</em>: The namespace import <code>import * as fs from \"fs\"</code> only accounts for properties which <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\">are owned</a> (basically properties set on the object and not via the prototype chain) on the imported object. If the module you’re importing defines its API using inherited properties, you need to use the default import form (<code>import fs from \"fs\"</code>), or disable <code>esModuleInterop</code>.</p>\n<p><em>Note</em>: You can make JS emit terser by enabling <a href=\"#importHelpers\"><code>importHelpers</code></a>:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @noErrors\n// @showEmit\n// @esModuleInterop\n// @importHelpers\n// @module: commonjs\nimport * as fs from \"fs\";\nimport _ from \"lodash\";\n\nfs.readFileSync(\"file.txt\", \"utf8\");\n_.chunk([\"a\", \"b\", \"c\", \"d\"], 2);\n</code></pre>\n<p>Enabling <code>esModuleInterop</code> will also enable <a href=\"#allowSyntheticDefaultImports\"><code>allowSyntheticDefaultImports</code></a>.</p>","redirectHref":"/tsconfig#esModuleInterop"}},"staticQueryHashes":[]}