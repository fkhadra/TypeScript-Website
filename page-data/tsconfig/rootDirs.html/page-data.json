{"componentChunkName":"component---src-templates-tsconfig-option-one-page-tsx","path":"/tsconfig/rootDirs.html","result":{"pageContext":{"title":"rootDirs","lang":"en","html":"<p>Using <code>rootDirs</code>, you can inform the compiler that there are many “virtual” directories acting as a single root.\nThis allows the compiler to resolve relative module imports within these “virtual” directories, as if they were merged in to one directory.</p>\n<p>For example:</p>\n<pre><code> src\n └── views\n     └── view1.ts (can import \"./template1\", \"./view2`)\n     └── view2.ts (can import \"./template1\", \"./view1`)\n\n generated\n └── templates\n         └── views\n             └── template1.ts (can import \"./view1\", \"./view2\")\n</code></pre>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/views\", \"generated/templates/views\"]\n  }\n}\n</code></pre>\n<p>This does not affect how TypeScript emits JavaScript, it only emulates the assumption that they will be able to\nwork via those relative paths at runtime.</p>\n<p><code>rootDirs</code> can be used to provide a separate “type layer” to files that are not TypeScript or JavaScript by providing a home for generated <code>.d.ts</code> files in another folder. This is technique is useful for bundled applications where you use <code>import</code> of files that aren’t necessarily code:</p>\n<pre><code class=\"language-sh\"> src\n └── index.ts\n └── css\n     └── main.css\n     └── navigation.css\n\n generated\n └── css\n     └── main.css.d.ts\n     └── navigation.css.d.ts\n</code></pre>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src\", \"generated\"]\n  }\n}\n</code></pre>\n<p>This technique lets you generate types ahead of time for the non-code source files. Imports then work naturally based off the source file’s location.\nFor example <code>./src/index.ts</code> can import the file <code>./src/css/main.css</code> and TypeScript will be aware of the bundler’s behavior for that filetype via the corresponding generated declaration file.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @filename: main.css.d.ts\nexport const appClass = \"mainClassF3EC2\";\n// ---cut---\n// @filename: index.ts\nimport { appClass } from \"./main.css\";\n</code></pre>","redirectHref":"/tsconfig#rootDirs"}},"staticQueryHashes":[]}