{"componentChunkName":"component---src-templates-tsconfig-option-one-page-tsx","path":"/tsconfig/allowSyntheticDefaultImports.html","result":{"pageContext":{"title":"allowSyntheticDefaultImports","lang":"en","html":"<p>When set to true, <code>allowSyntheticDefaultImports</code> allows you to write an import like:</p>\n<pre><code class=\"language-ts\">import React from \"react\";\n</code></pre>\n<p>instead of:</p>\n<pre><code class=\"language-ts\">import * as React from \"react\";\n</code></pre>\n<p>When the module <strong>does not</strong> explicitly specify a default export.</p>\n<p>For example, without <code>allowSyntheticDefaultImports</code> as true:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 1259 1192\n// @checkJs\n// @allowJs\n// @esModuleInterop: false\n// @filename: utilFunctions.js\n// @noImplicitAny: false\nconst getStringLength = (str) => str.length;\n\nmodule.exports = {\n  getStringLength,\n};\n\n// @filename: index.ts\nimport utils from \"./utilFunctions\";\n\nconst count = utils.getStringLength(\"Check JS\");\n</code></pre>\n<p>This code raises an error because there isn’t a <code>default</code> object which you can import. Even though it feels like it should.\nFor convenience, transpilers like Babel will automatically create a default if one isn’t created. Making the module look a bit more like:</p>\n<pre><code class=\"language-js\">// @filename: utilFunctions.js\nconst getStringLength = (str) => str.length;\nconst allFunctions = {\n  getStringLength,\n};\n\nmodule.exports = allFunctions;\nmodule.exports.default = allFunctions;\n</code></pre>\n<p>This flag does not affect the JavaScript emitted by TypeScript, it only for the type checking.\nThis option brings the behavior of TypeScript in-line with Babel, where extra code is emitted to make using a default export of a module more ergonomic.</p>","redirectHref":"/tsconfig#allowSyntheticDefaultImports"}},"staticQueryHashes":[]}