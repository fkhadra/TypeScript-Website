{"componentChunkName":"component---src-templates-documentation-tsx","path":"/ja/docs/handbook/jsdoc-supported-types.html","result":{"data":{"markdownRemark":{"id":"1a6fdeff-7d42-5c52-9fa3-b212ee34bddf","excerpt":"以下のリストは、JavaScriptファイルの型情報を提供する\nJSDocアノテーションにおいて、現在サポートされている構文の概要です。 以下に明示的にリストに入っていないタグ(@asyncなど)はまだサポートされていないことに注意してください。 @type @param (or @arg or @argument…","html":"<p>以下のリストは、JavaScriptファイルの型情報を提供する\nJSDocアノテーションにおいて、現在サポートされている構文の概要です。</p>\n<p>以下に明示的にリストに入っていないタグ(<code>@async</code>など)はまだサポートされていないことに注意してください。</p>\n<ul>\n<li><code>@type</code></li>\n<li><code>@param</code> (or <code>@arg</code> or <code>@argument</code>)</li>\n<li><code>@returns</code> (or <code>@return</code>)</li>\n<li><code>@typedef</code></li>\n<li><code>@callback</code></li>\n<li><code>@template</code></li>\n<li><code>@class</code> (or <code>@constructor</code>)</li>\n<li><code>@this</code></li>\n<li><code>@extends</code> (or <code>@augments</code>)</li>\n<li><code>@enum</code></li>\n</ul>\n<h4 id=\"class拡張\" style=\"position:relative;\"><a href=\"#class%E6%8B%A1%E5%BC%B5\" aria-label=\"class拡張 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>class</code>拡張</h4>\n<ul>\n<li><a href=\"#jsdoc-property-modifiers\">プロパティ修飾子</a> <code>@public</code>、<code>@private</code>、<code>@protected</code>、<code>@readonly</code></li>\n</ul>\n<p>タグの意味は通常、<a href=\"https://jsdoc.app\">jsdoc.app</a>で与えられたものと同じか、あるいはそのスーパーセットです。\n以下のコードでは、それぞれのタグの違いを説明し、使用例を示します。</p>\n<p><strong>注意:</strong> <a href=\"/play?useJavaScript=truee=4#example/jsdoc-support\">JSDocサポートを探るプレイグラウンド</a>を使用できます</p>\n<h2 id=\"type\" style=\"position:relative;\"><a href=\"#type\" aria-label=\"type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>@type</code></h2>\n<p>“@type”タグを使用すれば、型名(プリミティブ、TypeScript宣言やJSDocの”@typedef”タグで定義されたもの)を参照することができます。\nほとんどのJSDoc型と、<a href=\"/docs/handbook/basic-types.html\"><code>string</code>のような最も基本的なもの</a>から<a href=\"/docs/handbook/advanced-types.html\">Conditional Typesのような高度なもの</a>まで、あらゆるTypeScriptの型を使うことができます。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @type {string}\n */\nvar s;\n\n/** @type {Window} */\nvar win;\n\n/** @type {PromiseLike&#x3C;string>} */\nvar promisedString;\n\n// DOMプロパティを使ってHTML要素を指定することができます。\n/** @type {HTMLElement} */\nvar myElement = document.querySelector(selector);\nelement.dataset.myData = \"\";\n</code></pre>\n<p><code>@type</code>ではUnion型も指定できます — 例えば、次の型は文字列か真偽値のどちらかになります。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @type {(string | boolean)}\n */\nvar sb;\n</code></pre>\n<p>Union型の場合は、丸括弧は任意であることに注意してください。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @type {string | boolean}\n */\nvar sb;\n</code></pre>\n<p>様々な構文を使って配列の型を指定することができます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/** @type {number[]} */\nvar ns;\n/** @type {Array.&#x3C;number>} */\nvar nds;\n/** @type {Array&#x3C;number>} */\nvar nas;\n</code></pre>\n<p>オブジェクトリテラル型を指定することもできます。\n例えば、‘a’ (文字列) と ‘b’ (数値) をプロパティとして持つオブジェクトは次のような構文を使って指定します:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/** @type {{ a: string, b: number }} */\nvar var9;\n</code></pre>\n<p>JSDocの標準構文かTypeScriptの構文を使えば、文字列と数値のインデックスシグネチャを使ってマップや配列のようなオブジェクトを指定することができます。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * 任意の`string`プロパティを`number`にマッピングするマップライクなオブジェクト\n *\n * @type {Object.&#x3C;string, number>}\n */\nvar stringToNumber;\n\n/** @type {Object.&#x3C;number, object>} */\nvar arrayLike;\n</code></pre>\n<p>前述の2つの型は、TypeScriptの型である<code>{ [x: string]: number }</code>および<code>{ [x: number]: any }</code>と等価です。コンパイラは両方の構文を理解します。</p>\n<p>関数は、TypeScriptとClosureのどちらの構文を使っても指定することができます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/** @type {function(string, boolean): number} Closure構文 */\nvar sbn;\n/** @type {(s: string, b: boolean) => number} TypeScript構文 */\nvar sbn2;\n</code></pre>\n<p>あるいは、型が特定されていない<code>Function</code>型を使うこともできます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/** @type {Function} */\nvar fn7;\n/** @type {function} */\nvar fn6;\n</code></pre>\n<p>Closureの他の型でも動作します:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @type {*} - 'any'型になります\n */\nvar star;\n/**\n * @type {?} - 不明な型('any'と同じ)\n */\nvar question;\n</code></pre>\n<h3 id=\"キャスト\" style=\"position:relative;\"><a href=\"#%E3%82%AD%E3%83%A3%E3%82%B9%E3%83%88\" aria-label=\"キャスト permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>キャスト</h3>\n<p>TypeScriptはClosureからキャスト構文を借用しています。\nこれにより、丸括弧で囲まれた式の前に<code>@type</code>タグを追加することで、型を他の型にキャストすることができます。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @type {number | string}\n */\nvar numberOrString = Math.random() &#x3C; 0.5 ? \"hello\" : 100;\nvar typeAssertedNumber = /** @type {number} */ (numberOrString);\n</code></pre>\n<h3 id=\"インポート型\" style=\"position:relative;\"><a href=\"#%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E5%9E%8B\" aria-label=\"インポート型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>インポート型</h3>\n<p>インポート型を使用して他のファイルから宣言をインポートすることもできます。\nこの構文はTypeScript固有のものであり、JSDocの標準とは異なります:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @filename: types.d.ts\nexport type Pet = {\n  name: string,\n};\n\n// @filename: main.js\n/**\n * @param p { import(\"./types\").Pet }\n */\nfunction walk(p) {\n  console.log(`Walking ${p.name}...`);\n}\n</code></pre>\n<p>インポート型は型エイリアス宣言でも使用できます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @filename: types.d.ts\nexport type Pet = {\n  name: string,\n};\n// @filename: main.js\n// ---cut---\n/**\n * @typedef { import(\"./types\").Pet } Pet\n */\n\n/**\n * @type {Pet}\n */\nvar myPet;\nmyPet.name;\n</code></pre>\n<p>型がわからない場合や型が大きくて型を付けるのが面倒な場合に、インポート型を使ってモジュールから値の型を取得することができます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @filename: accounts.d.ts\nexport const userAccount = {\n  name: \"Name\",\n  address: \"An address\",\n  postalCode: \"\",\n  country: \"\",\n  planet: \"\",\n  system: \"\",\n  galaxy: \"\",\n  universe: \"\",\n};\n// @filename: main.js\n// ---cut---\n/**\n * @type {typeof import(\"./accounts\").userAccount }\n */\nvar x = require(\"./accounts\").userAccount;\n</code></pre>\n<h2 id=\"paramとreturns\" style=\"position:relative;\"><a href=\"#param%E3%81%A8returns\" aria-label=\"paramとreturns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>@param</code>と<code>@returns</code></h2>\n<p><code>@param</code>は<code>@type</code>と同じ型の構文を使用しますが、パラメータ名を追加します。\nまた、パラメータ名を角括弧で囲むことで、パラメータを任意のものとして宣言することもできます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// パラメータは様々な構文形式で宣言することができます\n/**\n * @param {string}  p1 - 文字列パラメータ\n * @param {string=} p2 - 任意のパラメータ(Closure構文)\n * @param {string} [p3] - 任意のパラメータ(JSDoc構文).\n * @param {string} [p4=\"test\"] - デフォルト値を持つ任意のパラメータ\n * @return {string} 結果\n */\nfunction stringsStringStrings(p1, p2, p3, p4) {\n  // TODO\n}\n</code></pre>\n<p>関数の戻り値の型についても同様です:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @return {PromiseLike&#x3C;string>}\n */\nfunction ps() {}\n\n/**\n * @returns {{ a: string, b: number }} - '@returns'と同じく'@return'を使うことができます\n */\nfunction ab() {}\n</code></pre>\n<h2 id=\"typedef、callbackおよびparam\" style=\"position:relative;\"><a href=\"#typedef%E3%80%81callback%E3%81%8A%E3%82%88%E3%81%B3param\" aria-label=\"typedef、callbackおよびparam permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>@typedef</code>、<code>@callback</code>および<code>@param</code></h2>\n<p>複雑な型を定義するために<code>@typedef</code>を使うことができます。\n<code>@param</code>を使った同様の構文でも動作します。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @typedef {Object} SpecialType - 'SpecialType'という名前の新しい型を作成\n * @property {string} prop1 - SpecialTypeの文字列プロパティ\n * @property {number} prop2 - SpecialTypeの数値プロパティ\n * @property {number=} prop3 - SpecialTypeの任意の数値プロパティ\n * @prop {number} [prop4] - SpecialTypeの任意の数値プロパティ\n * @prop {number} [prop5=42] - SpecialTypeのデフォルト値を持つ任意の数値プロパティ\n */\n\n/** @type {SpecialType} */\nvar specialTypeObject;\nspecialTypeObject.prop3;\n</code></pre>\n<p>最初の行には、<code>object</code>あるいは<code>Object</code>のどちらかを使うことができます。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @typedef {object} SpecialType1 - 'SpecialType'という名前の新しい型を作成\n * @property {string} prop1 - SpecialTypeの文字列プロパティ\n * @property {number} prop2 - SpecialTypeの数値プロパティ\n * @property {number=} prop3 - SpecialTypeの任意の数値プロパティ\n */\n\n/** @type {SpecialType1} */\nvar specialTypeObject1;\n</code></pre>\n<p><code>@param</code>を使えば、同様の構文で一回限りの型を指定することができます。\nネストされたプロパティ名の前には、パラメータ名をつけなければならないことに注意してください:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @param {Object} options - 形状は上記のSpecialTypeと同じ\n * @param {string} options.prop1\n * @param {number} options.prop2\n * @param {number=} options.prop3\n * @param {number} [options.prop4]\n * @param {number} [options.prop5=42]\n */\nfunction special(options) {\n  return (options.prop4 || 1001) + options.prop5;\n}\n</code></pre>\n<p><code>@callback</code>は<code>@typedef</code>に似ていますが、オブジェクト型ではなく関数型を指定します:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @callback Predicate\n * @param {string} data\n * @param {number} [index]\n * @returns {boolean}\n */\n\n/** @type {Predicate} */\nconst ok = (s) => !(s.length % 2);\n</code></pre>\n<p>もちろん、これらの型はすべてTypeScriptの構文を使って一行の<code>@typedef</code>で宣言することができます:</p>\n<pre><code class=\"language-js\">/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */\n/** @typedef {(data: string, index?: number) => boolean} Predicate */\n</code></pre>\n<h2 id=\"template\" style=\"position:relative;\"><a href=\"#template\" aria-label=\"template permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>@template</code></h2>\n<p>ジェネリクス関数は<code>@template</code>タグを使って宣言することができます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @template T\n * @param {T} x - 戻り値に流用するジェネリクスパラメータ\n * @return {T}\n */\nfunction id(x) {\n  return x;\n}\n\nconst a = id(\"string\");\nconst b = id(123);\nconst c = id({});\n</code></pre>\n<p>複数の型パラメータを宣言するには、コンマか複数のタグを使用します:</p>\n<pre><code class=\"language-js\">/**\n * @template T,U,V\n * @template W,X\n */\n</code></pre>\n<p>型パラメータ名の前に、型制約を指定することもできます。\nリストにある最初の型パラメータだけが、制約を受けます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @template {string} K - Kは文字列または文字列リテラルでなければなりません\n * @template {{ serious(): string }} Seriousalizable - seriousメソッドを持っていなければなりません\n * @param {K} key\n * @param {Seriousalizable} object\n */\nfunction seriousalize(key, object) {\n  // ????\n}\n</code></pre>\n<p>ジェネリクスのクラスや型の宣言はサポートされていません。</p>\n<h2 id=\"クラス\" style=\"position:relative;\"><a href=\"#%E3%82%AF%E3%83%A9%E3%82%B9\" aria-label=\"クラス permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>クラス</h2>\n<p>クラスはES6のクラスとして宣言することができます。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">class C {\n  /**\n   * @param {number} data\n   */\n  constructor(data) {\n    // プロパティの型は推測されます\n    this.name = \"foo\";\n\n    // あるいは、明示的に設定することもできます\n    /** @type {string | null} */\n    this.title = null;\n\n    // また、他のところで設定されている場合は、単に型注釈をつけることもできます\n    /** @type {number} */\n    this.size;\n\n    this.initialize(data); // initializerは文字列を受け取るので、エラーになるべきです\n  }\n  /**\n   * @param {string} s\n   */\n  initialize = function (s) {\n    this.size = s.length;\n  };\n}\n\nvar c = new C(0);\n\n// Cはnewを使用した場合のみ呼び出されるべきですが、\n// JavaScriptでは、以下は許可されており、\n// これは'any'型とみなされます。\nvar result = C(1);\n</code></pre>\n<p>次の節で説明するように、コンストラクタ関数として宣言することもできます:</p>\n<h2 id=\"constructor\" style=\"position:relative;\"><a href=\"#constructor\" aria-label=\"constructor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>@constructor</code></h2>\n<p>コンパイラはthisプロパティの代入に基づいてコンストラクタ関数を推測しますが、<code>@constructor</code>タグを追加すればより厳密なチェックとより良い提案を受けることができます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @errors: 2345 2348\n/**\n * @constructor\n * @param {number} data\n */\nfunction C(data) {\n  // プロパティの型は推測されます\n  this.name = \"foo\";\n\n  // あるいは、明示的に設定することもできます\n  /** @type {string | null} */\n  this.title = null;\n\n  // また、他のところで設定されている場合は、単に型注釈をつけることもできます\n  /** @type {number} */\n  this.size;\n\n  this.initialize(data);\n}\n/**\n * @param {string} s\n */\nC.prototype.initialize = function (s) {\n  this.size = s.length;\n};\n\nvar c = new C(0);\nc.size;\n\nvar result = C(1);\n</code></pre>\n<blockquote>\n<p>注意: エラーメッセージが表示されるのは、<a href=\"/docs/handbook/tsconfig-json.html\">JSConfig</a>と<a href=\"/tsconfig#checkJs\"><code>checkJs</code></a>が有効化されているJSコードベースのみです。</p>\n</blockquote>\n<p><code>@constructor</code>では、<code>this</code>はコンストラクタ関数<code>C</code>の内部でチェックされるので、数値を渡すと<code>initialize</code>メソッドへの提案とエラーが表示されます。また、コンストラクタの代わりに<code>C</code>を呼び出すと、エディタが警告を表示することもあります。</p>\n<p>残念ながら、これは呼び出しも可能なコンストラクタ関数では、<code>@constructor</code>を使用できないことを意味します。</p>\n<h2 id=\"this\" style=\"position:relative;\"><a href=\"#this\" aria-label=\"this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>@this</code></h2>\n<p>コンパイラは通常、<code>this</code>が用いられるコンテクストから<code>this</code>の型を推測することができます。推測できない場合、<code>@this</code>を使って明示的に<code>this</code>の型を指定することができます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @this {HTMLElement}\n * @param {*} e\n */\nfunction callbackForLater(e) {\n  this.clientHeight = parseInt(e); // 大丈夫なはず！\n}\n</code></pre>\n<h2 id=\"extends\" style=\"position:relative;\"><a href=\"#extends\" aria-label=\"extends permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>@extends</code></h2>\n<p>JavaScriptクラスがジェネリクスの基底クラスを拡張するとき、型パラメータが何であるべきかを指定するところがありません。<code>@extends</code>タグはそのような型パラメータを指定する方法を提供しています:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @template T\n * @extends {Set&#x3C;T>}\n */\nclass SortableSet extends Set {\n  // ...\n}\n</code></pre>\n<p><code>@extends</code>は、クラスに対してのみ動作することに注意してください。現在、コンストラクタ関数がクラスを拡張する方法はありません。</p>\n<h2 id=\"enum\" style=\"position:relative;\"><a href=\"#enum\" aria-label=\"enum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>@enum</code></h2>\n<p><code>@enum</code>タグを使うと、すべてのメンバが指定された型であるオブジェクトリテラルを作成することができます。JavaScriptのたいていのオブジェクトリテラルとは異なり、明示されていないメンバは使用できません。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/** @enum {number} */\nconst JSDocState = {\n  BeginningOfLine: 0,\n  SawAsterisk: 1,\n  SavingComments: 2,\n};\n\nJSDocState.SawAsterisk;\n</code></pre>\n<p>注意すべき点は、<code>@enum</code>はTypeScriptの<code>enum</code>とは大きく異なっており、とてもシンプルです。一方で、TypeScriptの<code>enum</code>とは違って、<code>@enum</code>は任意の型を持つことができます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/** @enum {function(number): number} */\nconst MathFuncs = {\n  add1: (n) => n + 1,\n  id: (n) => -n,\n  sub1: (n) => n - 1,\n};\n\nMathFuncs.add1;\n</code></pre>\n<h2 id=\"その他の例\" style=\"position:relative;\"><a href=\"#%E3%81%9D%E3%81%AE%E4%BB%96%E3%81%AE%E4%BE%8B\" aria-label=\"その他の例 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>その他の例</h2>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">class Foo {}\n// ---cut---\nvar someObj = {\n  /**\n   * @param {string} param1 - プロパティの割り当てに関する仕様は、\n   */\n  x: function (param1) {},\n};\n\n/**\n * 変数の代入や\n * @return {Window}\n */\nlet someFunc = function () {};\n\n/**\n * クラスメソッド、\n * @param {string} greeting 使用する挨拶\n */\nFoo.prototype.sayHi = (greeting) => console.log(\"Hi!\");\n\n/**\n * アロー関数式でも同様に動作します\n * @param {number} x - 乗数\n */\nlet myArrow = (x) => x * x;\n\n/**\n * つまり、JSXのステートレス関数コンポーネントでも動作するということです\n * @param {{a: string, b: number}} test - いくつかのパラメータ\n */\nvar sfc = (test) => &#x3C;div>{test.a.charAt(0)}&#x3C;/div>;\n\n/**\n * パラメータには、Closure構文を使用して、クラスのコンストラクタを使用することができます。\n *\n * @param {{new(...args: any[]): object}} C - 登録するクラス\n */\nfunction registerClass(C) {}\n\n/**\n * @param {...string} p1 - 文字列の'レストパラメータ'(配列)引数 ('any'として扱われます)\n */\nfunction fn10(p1) {}\n\n/**\n * @param {...string} p1 - 文字列の'レストパラメータ'(配列)引数 ('any'として扱われます)\n */\nfunction fn9(p1) {\n  return p1.join();\n}\n</code></pre>\n<h2 id=\"サポートされていないことが知られているパターン\" style=\"position:relative;\"><a href=\"#%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%81%8C%E7%9F%A5%E3%82%89%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3\" aria-label=\"サポートされていないことが知られているパターン permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>サポートされていないことが知られているパターン</h2>\n<p>コンストラクタ関数のようにオブジェクトも型を作らない限り、値空間のオブジェクトを型として参照することはできません。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">function aNormalFunction() {}\n/**\n * @type {aNormalFunction}\n */\nvar wrong;\n/**\n * 'typeof'を代わりに使用します:\n * @type {typeof aNormalFunction}\n */\nvar right;\n</code></pre>\n<p>オブジェクトリテラル型のプロパティ型の後ろに等号をつけても、任意のプロパティにはなりません:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @type {{ a: string, b: number= }}\n */\nvar wrong;\n/**\n * 代わりにプロパティ名の後ろにクエスチョンマークを付けます:\n * @type {{ a: string, b?: number }}\n */\nvar right;\n</code></pre>\n<p><code>strictNullChecks</code>が有効化されている場合のみ、Nullable型は動作します:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @type {?number}\n * strictNullChecks: trueの場合  -- number | null\n * strictNullChecks: falseの場合 -- number\n */\nvar nullable;\n</code></pre>\n<p>Union型も使うことができます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @type {number | null}\n * strictNullChecks: trueの場合  -- number | null\n * strictNullChecks: falseの場合 -- number\n */\nvar unionNullable;\n</code></pre>\n<p>非Nullable型は意味を持たず、元の型と同じように扱われます:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @type {!number}\n * 数値型だけをもちます\n */\nvar normal;\n</code></pre>\n<p>JSDocの型システムとは異なり、TypeScriptは型にnullが含まれるかどうか記すことしかできません。\n明示的な非Nullable型はありません — strictNullChecksが有効なら、<code>number</code>はNullableではありません。\n無効なら、<code>number</code>はNullableです。</p>\n<h3 id=\"サポートされていないタグ\" style=\"position:relative;\"><a href=\"#%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%82%BF%E3%82%B0\" aria-label=\"サポートされていないタグ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>サポートされていないタグ</h3>\n<p>TypeScriptはサポートされていないJSDocタグを無視します。</p>\n<p>以下のタグは、サポートを目標とした進行中のIssueがあります:</p>\n<ul>\n<li><code>@const</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/19672\">issue #19672</a>)</li>\n<li><code>@inheritdoc</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/23215\">issue #23215</a>)</li>\n<li><code>@memberof</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/7237\">issue #7237</a>)</li>\n<li><code>@yields</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/23857\">issue #23857</a>)</li>\n<li><code>{@link …}</code> (<a href=\"https://github.com/Microsoft/TypeScript/issues/35524\">issue #35524</a>)</li>\n</ul>\n<h2 id=\"jsクラスの拡張\" style=\"position:relative;\"><a href=\"#js%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AE%E6%8B%A1%E5%BC%B5\" aria-label=\"jsクラスの拡張 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSクラスの拡張</h2>\n<h3 id=\"jsdocプロパティ修飾子\" style=\"position:relative;\"><a href=\"#jsdoc%E3%83%97%E3%83%AD%E3%83%91%E3%83%86%E3%82%A3%E4%BF%AE%E9%A3%BE%E5%AD%90\" aria-label=\"jsdocプロパティ修飾子 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSDocプロパティ修飾子</h3>\n<p>TypeScript 3.8以降、JSDocを使ってクラスプロパティを修飾することができます。まずは、アクセシビリティ修飾子<code>@public</code>、<code>@private</code>、<code>@protected</code>です。\nこれらのタグは、TypeScriptの<code>public</code>、<code>private</code>、<code>protected</code>とそれぞれ同じように動作します。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @errors: 2341\n// @ts-check\n\nclass Car {\n  constructor() {\n    /** @private */\n    this.identifier = 100;\n  }\n\n  printIdentifier() {\n    console.log(this.identifier);\n  }\n}\n\nconst c = new Car();\nconsole.log(c.identifier);\n</code></pre>\n<ul>\n<li><code>@public</code>は常に暗黙的に宣言されており、省略可能です。どこからでもプロパティにアクセスできることを意味します。</li>\n<li><code>@private</code>は、そのプロパティが含まれるクラス内でのみ使用可能であることを意味します。</li>\n<li><code>@protected</code>は、そのプロパティが含まれるクラスと、そのクラスの派生クラス内で使用可能ですが、クラスのインスタンスからはアクセスできません。</li>\n</ul>\n<p>次に、<code>@readonly</code>修飾子を追加しました。これを使用すると、プロパティが初期化時にのみ書き込まれることが保証されます。</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @errors: 2540\n// @ts-check\n\nclass Car {\n  constructor() {\n    /** @readonly */\n    this.identifier = 100;\n  }\n\n  printIdentifier() {\n    console.log(this.identifier);\n  }\n}\n\nconst c = new Car();\nconsole.log(c.identifier);\n</code></pre>","headings":[{"value":"class拡張","depth":4},{"value":"@type","depth":2},{"value":"キャスト","depth":3},{"value":"インポート型","depth":3},{"value":"@paramと@returns","depth":2},{"value":"@typedef、@callbackおよび@param","depth":2},{"value":"@template","depth":2},{"value":"クラス","depth":2},{"value":"@constructor","depth":2},{"value":"@this","depth":2},{"value":"@extends","depth":2},{"value":"@enum","depth":2},{"value":"その他の例","depth":2},{"value":"サポートされていないことが知られているパターン","depth":2},{"value":"サポートされていないタグ","depth":3},{"value":"JSクラスの拡張","depth":2},{"value":"JSDocプロパティ修飾子","depth":3}],"frontmatter":{"permalink":"/ja/docs/handbook/jsdoc-supported-types.html","title":"JSDocリファレンス","disable_toc":null,"handbook":null,"oneline":"TypeScriptを備えたJavaScriptはどのようなJSDocをサポートしているか","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"JavaScriptファイルの型チェック","oneline":"TypeScriptを使ってJavaScriptファイルに型チェックを追加する方法","permalink":"/ja/docs/handbook/type-checking-javascript-files.html"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":".jsファイルから.d.tsファイルを生成する","oneline":"JavaScriptプロジェクトでd.tsファイルを生成する方法","permalink":"/ja/docs/handbook/declaration-files/dts-from-js.html"}}}},"pageContext":{"id":"6-jsdocリファレンス","slug":"/ja/docs/handbook/jsdoc-supported-types.html","repoPath":"/packages/documentation/copy/ja/javascript/JSDoc Reference.md","previousID":"52fefe33-2cba-5319-9804-36abe1e60e40","nextID":"51a859ef-b4a4-5496-9523-ca1cf3ca0de5","lang":"ja","modifiedTime":"2021-05-31T12:18:20.867Z"}},"staticQueryHashes":[]}