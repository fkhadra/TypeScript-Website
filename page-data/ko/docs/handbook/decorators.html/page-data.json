{"componentChunkName":"component---src-templates-documentation-tsx","path":"/ko/docs/handbook/decorators.html","result":{"data":{"markdownRemark":{"id":"fbcaf1fa-8a8a-5a27-a859-cfb7d693731d","excerpt":"소개 (Introduction) TypeScript 및 ES…","html":"<h2 id=\"소개-introduction\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EA%B0%9C-introduction\" aria-label=\"소개 introduction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소개 (Introduction)</h2>\n<blockquote class='bg-reading'>\n  <p>Further Reading:<br /><a href='https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/'>A Complete Guide to TypeScript Decorators</a></p>\n</blockquote>\n<p>TypeScript 및 ES6에 클래스가 도입됨에 따라, 클래스 및 클래스 멤버에 어노테이션을 달거나 수정하기 위해 추가 기능이 필요한 특정 시나리오가 있습니다.\n데코레이터는 클래스 선언과 멤버에 어노테이션과 메타-프로그래밍 구문을 추가할 수 있는 방법을 제공합니다.\n데코레이터는 JavaScript에 대한 <a href=\"https://github.com/tc39/proposal-decorators\">2단계 제안</a>이며 TypeScript의 실험적 기능으로 이용 가능합니다.</p>\n<blockquote>\n<p>참고  데코레이터는 향후 릴리스에서 변경될 수 있는 실험적인 기능입니다.</p>\n</blockquote>\n<p>데코레이터에 대한 실험적 지원을 활성화하려면 명령줄 또는 <code>tsconfig.json</code>에서 <code>experimentDecorators</code> 컴파일러 옵션을 활성화해야합니다:</p>\n<p><strong>명령줄 (Command Line)</strong>:</p>\n<pre><code class=\"language-shell\">tsc --target ES5 --experimentalDecorators\n</code></pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n</code></pre>\n<h1 id=\"데코레이터-decorators\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-decorators\" aria-label=\"데코레이터 decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데코레이터 (Decorators)</h1>\n<p><em>데코레이터</em>는 <a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-class-decorators\">클래스 선언</a>, <a href=\"#%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-method-decorators\">메서드</a>, <a href=\"#%EC%A0%91%EA%B7%BC%EC%9E%90-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-accessor-decorators\">접근자</a>, <a href=\"#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-property-decorators\">프로퍼티</a> 또는 <a href=\"#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-parameter-decorators\">매개 변수</a>에 첨부할 수 있는 특수한 종류의 선언입니다.\n데코레이터는 <code>@expression</code> 형식을 사용합니다. 여기서 <code>expression</code>은 데코레이팅 된 선언에 대한 정보와 함께 런타임에 호출되는 함수여야 합니다.</p>\n<p>예를 들어, 데코레이터 <code>@sealed</code>를 사용하면 다음과 같이 <code>sealed</code> 함수를 작성할 수 있습니다.</p>\n<pre><code class=\"language-ts\">function sealed(target) {\n    // 'target' 변수와 함께 무언가를 수행합니다.\n}\n</code></pre>\n<h2 id=\"데코레이터-팩토리-decorator-factories\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-decorator-factories\" aria-label=\"데코레이터 팩토리 decorator factories permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데코레이터 팩토리 (Decorator Factories)</h2>\n<p>데코레이터가 선언에 적용되는 방식을 원하는 대로 바꾸고 싶다면 데코레이터 팩토리를 작성할 수 있습니다. <em>데코레이터 팩토리</em>는 단순히 데코레이터가 런타임에 호출할 표현식을 반환하는 함수입니다.</p>\n<p>다음과 같은 방식으로 데코레이터 팩토리를 작성할 수 있습니다.</p>\n<pre><code class=\"language-ts\">function color(value: string) { // 데코레이터 팩토리\n    return function (target) { // 데코레이터\n        // 'target'과 'value' 변수를 가지고 무언가를 수행합니다.\n  };\n}\n</code></pre>\n<h2 id=\"데코레이터-합성-decorator-composition\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%95%A9%EC%84%B1-decorator-composition\" aria-label=\"데코레이터 합성 decorator composition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데코레이터 합성 (Decorator Composition)</h2>\n<p>다음 예제와 같이 선언에 여러 데코레이터를 적용할 수 있습니다.</p>\n<ul>\n<li>단일 행일 경우:</li>\n</ul>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\n// @noErrors\nfunction f() {}\nfunction g() {}\n// ---cut---\n@f @g x\n</code></pre>\n<ul>\n<li>여러 행일 경우:</li>\n</ul>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\n// @noErrors\nfunction f() {}\nfunction g() {}\n// ---cut---\n@f\n@g\nx\n</code></pre>\n<p>여러 데코레이터가 단일 선언에 적용되는 경우는 <a href=\"http://en.wikipedia.org/wiki/Function_composition\">수학의 합성 함수</a>와 유사합니다.\n이 모델에서 함수 <em>f</em>와 <em>g</em>을 합성할 때 (<em>f</em>∘<em>g</em>)(<em>x</em>)의 합성 결과는 <em>f</em>(<em>g</em>(<em>x</em>))와 같습니다.</p>\n<p>따라서 TypeScript에서 단일 선언에서 여러 데코레이터를 사용할 때 다음 단계가 수행됩니다.</p>\n<ol>\n<li>각 데코레이터의 표현은 위에서 아래로 평가됩니다.</li>\n<li>그런 다음 결과는 아래에서 위로 함수로 호출됩니다.</li>\n</ol>\n<p><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-decorator-factories\">데코레이터 팩토리</a>를 사용하는 경우 다음 예제를 통해 이 수행 순서를 관찰 할 수 있습니다.</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction first() {\n  console.log(\"first(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"first(): called\");\n  };\n}\n\nfunction second() {\n  console.log(\"second(): factory evaluated\");\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"second(): called\");\n  };\n}\n\nclass ExampleClass {\n  @first()\n  @second()\n  method() {}\n}\n</code></pre>\n<p>이는 결과를 콘솔에 출력합니다.</p>\n<pre><code class=\"language-shell\">first(): factory evaluated\nsecond(): factory evaluated\nsecond(): called\nfirst(): called\n</code></pre>\n<h2 id=\"데코레이터-평가-decorator-evaluation\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8F%89%EA%B0%80-decorator-evaluation\" aria-label=\"데코레이터 평가 decorator evaluation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데코레이터 평가 (Decorator Evaluation)</h2>\n<p>클래스에서 다양한 선언에 데코레이터를 적용하는 방법은 다음과 같이 잘 정의되어 있습니다.</p>\n<ol>\n<li><em>메서드</em>, <em>접근자</em> 또는 <em>프로퍼티 데코레이터</em>가 다음에 오는 <em>매개 변수 데코레이터</em>는 각 인스턴스 멤버에 적용됩니다.</li>\n<li><em>메서드</em>, <em>접근자</em> 또는 <em>프로퍼티 데코레이터</em>가 다음에 오는 <em>매개 변수 데코레이터</em>는 각 정적 멤버에 적용됩니다.</li>\n<li><em>매개 변수 데코레이터</em>는 생성자에 적용됩니다.</li>\n<li><em>클래스 데코레이터</em>는 클래스에 적용됩니다.</li>\n</ol>\n<h2 id=\"클래스-데코레이터-class-decorators\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-class-decorators\" aria-label=\"클래스 데코레이터 class decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 데코레이터 (Class Decorators)</h2>\n<p><strong>클래스 데코레이터</strong>는 클래스 선언 직전에 선언됩니다.\n클래스 데코레이터는 클래스 생성자에 적용되며 클래스 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다.\n클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트 (예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p>\n<p>클래스 데코레이터의 표현식은 데코레이팅된 클래스의 생성자를 유일한 인수로 런타임에 함수로 호출됩니다.</p>\n<p>클래스 데코레이터가 값을 반환하면 클래스가 선언을 제공하는 생성자 함수로 바꿉니다.</p>\n<blockquote>\n<p>참고  새 생성자 함수를 반환하도록 선택한 경우 원래 프로토타입을 유지 관리해야 합니다.\n런타임에 데코레이터를 적용하는 로직은 이 기능을 <strong>대신해주지 않습니다.</strong></p>\n</blockquote>\n<p>다음은 <code>BugReport</code> 클래스에 적용된 클래스 데코레이터 (<code>@sealed</code>)의 예입니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n// ---cut---\n@sealed\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n</code></pre>\n<p>다음 함수 선언을 사용하여 <code>@sealed</code> 데코레이터를 정의할 수 있습니다.</p>\n<pre><code class=\"language-ts\">function sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n</code></pre>\n<p><code>@sealed</code>가 실행되면 생성자와 프로토 타입을 모두 감쌉니다.</p>\n<p>생성자를 재정의하는 방법에 대한 예제는 다음과 같습니다.</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2339\n// @experimentalDecorators\nfunction reportableClassDecorator&#x3C;T extends { new (...args: any[]): {} }>(constructor: T) {\n  return class extends constructor {\n    reportingURL = \"http://www...\";\n  };\n}\n\n@reportableClassDecorator\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n}\n\nconst bug = new BugReport(\"Needs dark mode\");\nconsole.log(bug.title); // Prints \"Needs dark mode\"\nconsole.log(bug.type); // Prints \"report\"\n\n// Note that the decorator _does not_ change the TypeScript type\n// and so the new property `reportingURL` is not known\n// to the type system:\nbug.reportingURL;\n</code></pre>\n<h2 id=\"메서드-데코레이터-method-decorators\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%84%9C%EB%93%9C-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-method-decorators\" aria-label=\"메서드 데코레이터 method decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메서드 데코레이터 (Method Decorators)</h2>\n<p><em>메서드 데코레이터</em>는 메서드 선언 직전에 선언됩니다.\n데코레이터는 메서드의 <em>프로퍼티 설명자(Property Descriptor)</em> 에 적용되며 메서드 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다.\n메서드 데코레이터는 선언 파일, 오버로드 또는 기타 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p>\n<p>메서드 데코레이터의 표현식은 런타임에 다음 세 개의 인수와 함께 함수로 호출됩니다:</p>\n<ol>\n<li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입입니다.</li>\n<li>멤버의 이름</li>\n<li>멤버의 <em>프로퍼티 설명자</em></li>\n</ol>\n<blockquote>\n<p>참고  스크립트 대상이 ‘ES5’보다 낮은 경우 <em>프로퍼티 설명자</em> 는 ‘undefined’이 됩니다.</p>\n</blockquote>\n<p>메서드 데코레이터가 값을 반환하면, 메서드의 <em>프로퍼티 설명자</em> 로 사용됩니다.</p>\n<blockquote>\n<p>참고  스크립트 대상이 ‘ES5’보다 낮은 경우 반환 값은 무시됩니다.</p>\n</blockquote>\n<p>다음은 <code>Greeter</code> 클래스의 메서드에 적용된 메서드 데코레이터 (<code>@enumerable</code>)의 예입니다:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction enumerable(value: boolean) {\n  return function (target: any,propertyKey: string,descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value;\n  };\n}\n// ---cut---\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n</code></pre>\n<p>다음 함수 선언을 사용하여 <code>@enumerable</code> 데코레이터를 정의할 수 있습니다.</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">function enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value;\n  };\n}\n</code></pre>\n<p><code>@enumerable(false)</code>데코레이터는 <a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-DecoratorFactories\">데코레이터 팩토리</a>입니다.\n<code>@enumerable(false)</code> 데코레이터가 호출되면 프로퍼티 설명자의 <code>enumerable</code> 프로퍼티를 수정합니다.</p>\n<h2 id=\"접근자-데코레이터-accessor-decorators\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC%EC%9E%90-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-accessor-decorators\" aria-label=\"접근자 데코레이터 accessor decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근자 데코레이터 (Accessor Decorators)</h2>\n<p><em>접근자 데코레이터</em>는 접근자 선언 바로 전에 선언됩니다.\n접근자 데코레이터는 접근자의 <em>프로퍼티 설명자</em>에 적용되며 접근자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다.\n접근자 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p>\n<blockquote>\n<p>참고  TypeScript는 단일 멤버에 대해 <code>get</code> 및 <code>set</code> 접근자를 데코레이팅 할 수 없습니다.\n대신 멤버의 모든 데코레이터를 문서 순서대로 지정된 첫 번째 접근자에 적용해야 합니다.\n왜냐하면, 데코레이터는 각각의 선언이 아닌 <code>get</code>과 <code>set</code> 접근자를 결합한 <em>프로퍼티 설명자</em>에 적용되기 때문입니다.</p>\n</blockquote>\n<p>접근자 데코레이터의 표현 식은 런타임에 다음 세 가지 인수와 함께 함수로 호출됩니다:</p>\n<ol>\n<li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입</li>\n<li>멤버의 이름</li>\n<li>멤버의 <em>프로퍼티 설명자</em></li>\n</ol>\n<blockquote>\n<p>참고  스크립트 대상이 ‘ES5’보다 낮은 경우 <em>프로퍼티 설명자</em>는 <code>undefined</code>가 됩니다.</p>\n</blockquote>\n<p>접근자 데코레이터가 값을 반환하면 멤버의 <em>프로퍼티 설명자</em>로 사용됩니다.</p>\n<blockquote>\n<p>참고  스크립트 대상이 ‘ES5’보다 낮은 경우 반환 값은 무시됩니다.</p>\n</blockquote>\n<p>다음은 <code>Point</code> 클래스의 멤버에 적용되는 접근자 데코레이터 (<code>@configurable</code>)의 예입니다:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction configurable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    descriptor.configurable = value;\n  };\n}\n// ---cut---\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n\n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}\n</code></pre>\n<p>다음 함수 선언을 사용하여 <code>@configurable</code> 데코레이터를 정의할 수 있습니다:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\">function configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n</code></pre>\n<h2 id=\"프로퍼티-데코레이터-property-decorators\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-property-decorators\" aria-label=\"프로퍼티 데코레이터 property decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로퍼티 데코레이터 (Property Decorators)</h2>\n<p><em>프로퍼티 데코레이터</em>는 프로퍼티 선언 바로 전에 선언됩니다.\n프로퍼티 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p>\n<p>프로퍼티 데코레이터의 표현 식은 런타임에 다음 두 개의 인수와 함께 함수로 호출됩니다:</p>\n<ol>\n<li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입</li>\n<li>멤버의 이름</li>\n</ol>\n<blockquote>\n<p>참고  TypeScript에서 <code>프로퍼티 데코레이터</code>가 초기화되는 방식으로 인해 <em>프로퍼티 설명자</em>가 프로퍼티 데코레이터에 대한 인수로 제공되지 않습니다.\n현재 프로토타입의 멤버를 정의할 때 인스턴스 프로퍼티를 설명하는 메커니즘이 없고 프로퍼티의 이니셜라이저를 관찰하거나 수정할 수 있는 방법이 없기 때문입니다. 반환 값도 무시됩니다.\n따라서 프로퍼티 데코레이터는 특정 이름의 프로퍼티가 클래스에 선언되었음을 관찰하는 데만 사용할 수 있습니다.</p>\n</blockquote>\n<p>이 정보를 사용하여 다음 예와 같이 프로퍼티에 대한 메타데이터를 기록할 수 있습니다:</p>\n<pre><code class=\"language-ts\">class Greeter {\n  @format(\"Hello, %s\")\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  greet() {\n    let formatString = getFormat(this, \"greeting\");\n    return formatString.replace(\"%s\", this.greeting);\n  }\n}\n</code></pre>\n<p>다음 함수 선언을 사용하여 <code>@format</code> 데코레이터와 <code>getFormat</code> 함수를 정의 할 수 있습니다:</p>\n<pre><code class=\"language-ts\">import \"reflect-metadata\";\n\nconst formatMetadataKey = Symbol(\"format\");\n\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n</code></pre>\n<p><code>@format(\"Hello, %s\")</code> 데코레이터는 <a href=\"#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A9%ED%86%A0%EB%A6%AC-Decorator-Factories\">데코레이터 팩토리</a>입니다.\n<code>@format(\"Hello, %s\")</code>가 호출되면 <code>reflect-metadata</code> 라이브러리의 <code>Reflect.metadata</code> 함수를 사용하여 프로퍼티에 대한 메타데이터 항목을 추가합니다.\n<code>getFormat</code>이 호출되면 형식의 메타데이터 값을 읽습니다.</p>\n<blockquote>\n<p>참고  이 예제에는 <code>reflect-metadata</code> 라이브러리가 필요합니다.\n<code>reflect-metadata</code> 라이브러리에 대한 자세한 내용은 <a href=\"#%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0-metadata\">메타데이터</a>를 참조하십시오.</p>\n</blockquote>\n<h2 id=\"매개변수-데코레이터-parameter-decorators\" style=\"position:relative;\"><a href=\"#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-parameter-decorators\" aria-label=\"매개변수 데코레이터 parameter decorators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>매개변수 데코레이터 (Parameter Decorators)</h2>\n<p><em>매개변수 데코레이터</em>는 매개 변수 선언 직전에 선언됩니다.\n매개변수 데코레이터는 클래스 생성자 또는 메서드 선언의 함수에 적용됩니다.\n매개변수 데코레이터는 선언 파일, 오버로드 또는 다른 주변 컨텍스트(예: <code>선언</code> 클래스)에서 사용할 수 없습니다.</p>\n<p>매개 변수 데코레이터의 표현식은 런타임시 다음 세 개의 인수와 함께 함수로 호출됩니다:</p>\n<ol>\n<li>정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토타입</li>\n<li>멤버의 이름</li>\n<li>함수의 매개 변수 목록에 있는 매개 변수의 서수 색인(ordinal index)</li>\n</ol>\n<blockquote>\n<p>참고  매개변수 데코레이터는 매개변수가 메서드에서 선언되었을 때에만 관찰하는 데에 사용할 수 있습니다.</p>\n</blockquote>\n<p>메개변수 데코레이터의 반환 값은 무시됩니다.</p>\n<p>다음은 <code>BugReport</code> 클래스 멤버의 매개 변수에 적용되는 매개 변수 데코레이터 (<code>@required</code>)의 예입니다:</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @experimentalDecorators\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&#x3C;any>) {}\nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {}\n// ---cut---\nclass BugReport {\n  type = \"report\";\n  title: string;\n\n  constructor(t: string) {\n    this.title = t;\n  }\n\n  @validate\n  print(@required verbose: boolean) {\n    if (verbose) {\n      return this.title;\n    } else {\n      return `type: ${this.type}\\ntitle: ${this.title}`;\n    }\n  }\n}\n</code></pre>\n<p>다음 함수 선언을 사용하여 <code>@required</code> 및 <code>@validate</code> 데코레이터를 정의할 수 있습니다.</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2339 2339 2339\n// @experimentalDecorators\n// @emitDecoratorMetadata\nimport \"reflect-metadata\";\nconst requiredMetadataKey = Symbol(\"required\");\n\nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata( requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor&#x3C;Function>) {\n  let method = descriptor.value!;\n\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n</code></pre>\n<p><code>@required</code> 데코레이터는 필요에 따라 매개변수를 표시하는 메타데이터 항목을 추가합니다.\n그런 다음 <code>@validate</code> 데코레이터는 원래 메서드를 호출하기 전에 인수 유효성 검증하는 함수로 기존의 <code>greet</code> 메서드를 감쌉니다.</p>\n<blockquote>\n<p>참고  이 예제에는 <code>reflect-metadata</code> 라이브러리가 필요합니다.\n<code>reflect-metadata</code> 라이브러리에 대한 자세한 내용은 [메타데이터] (#메타데이터-metadata)를 참조하십시오.</p>\n</blockquote>\n<h2 id=\"메타데이터-metadata\" style=\"position:relative;\"><a href=\"#%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0-metadata\" aria-label=\"메타데이터 metadata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메타데이터 (Metadata)</h2>\n<p>일부 예제는 <a href=\"https://github.com/rbuckton/ReflectDecorators\">실험적 메타데이터 API</a>에 대한 폴리필(polyfill)을 추가하는 <code>reflect-metadata</code> 라이브러리를 사용합니다.\n이 라이브러리는 아직 ECMAScript (JavaScript) 표준의 일부가 아닙니다.\n그러나 데코레이터가 공식적으로 ECMAScript 표준의 일부로 채택되면 이러한 확장을 채택하게 될 것입니다.</p>\n<p>npm을 통해 설치할 수 있습니다.</p>\n<pre><code class=\"language-shell\">npm i reflect-metadata --save\n</code></pre>\n<p>TypeScript에는 데코레이터가 있는 선언에 대해 특정 타입의 메타 데이터를 내보내는 실험적인 지원을 포함합니다.\n이 실험적인 지원을 가능하게 하려면, 명령행 또는<code>tsconfig.json</code>에서 <code>emitDecoratorMetadata</code> 컴파일러 옵션을 설정해야 합니다.</p>\n<p><strong>명령줄</strong>:</p>\n<pre><code class=\"language-shell\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n</code></pre>\n<p><strong>tsconfig.json</strong>:</p>\n<pre><code class=\"language-json\" data-meta=\"tsconfig\">{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n</code></pre>\n<p>활성화되면 <code>reflect-metadata</code>라이브러리를 가져오기만 하면 추가 디자인-타임 타입 정보가 런타임에 사용 가능합니다.</p>\n<p>다음 예제에서 이를 확인할 수 있습니다.</p>\n<!-- prettier-ignore -->\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2339\n// @emitDecoratorMetadata\n// @experimentalDecorators\n// @strictPropertyInitialization: false\nimport \"reflect-metadata\";\n\nclass Point {\n  constructor(public x: number, public y: number) {}\n}\n\nclass Line {\n  private _start: Point;\n  private _end: Point;\n\n  @validate\n  set start(value: Point) {\n    this._start = value;\n  }\n\n  get start() {\n    return this._start;\n  }\n\n  @validate\n  set end(value: Point) {\n    this._end = value;\n  }\n\n  get end() {\n    return this._end;\n  }\n}\n\nfunction validate&#x3C;T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor&#x3C;T>) {\n  let set = descriptor.set!;\n  \n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n\n    if (!(value instanceof type)) {\n      throw new TypeError(`Invalid type, got ${typeof value} not ${type.name}.`);\n    }\n\n    set.call(this, value);\n  };\n}\n\nconst line = new Line()\nline.start = new Point(0, 0)\n\n// @ts-ignore\n// line.end = {}\n\n// Fails at runtime with:\n// > Invalid type, got object not Point\n</code></pre>\n<p>TypeScript 컴파일러는 <code>@Reflect.metadata</code> 데코레이터를 사용하여 디자인-타임 타입 정보를 주입합니다.\n다음 TypeScript와 동일하다고 생각할 수 있습니다.</p>\n<pre><code class=\"language-ts\">class Line {\n  private _start: Point;\n  private _end: Point;\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set start(value: Point) {\n    this._start = value;\n  }\n  get start() {\n    return this._start;\n  }\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set end(value: Point) {\n    this._end = value;\n  }\n  get end() {\n    return this._end;\n  }\n}\n</code></pre>\n<blockquote>\n<p>참고  데코레이터 메타 데이터는 실험적인 기능으로 향후 릴리스에서 주요 변경 사항이 있을 수 있습니다.</p>\n</blockquote>","headings":[{"value":"소개 (Introduction)","depth":2},{"value":"데코레이터 (Decorators)","depth":1},{"value":"데코레이터 팩토리 (Decorator Factories)","depth":2},{"value":"데코레이터 합성 (Decorator Composition)","depth":2},{"value":"데코레이터 평가 (Decorator Evaluation)","depth":2},{"value":"클래스 데코레이터 (Class Decorators)","depth":2},{"value":"메서드 데코레이터 (Method Decorators)","depth":2},{"value":"접근자 데코레이터 (Accessor Decorators)","depth":2},{"value":"프로퍼티 데코레이터 (Property Decorators)","depth":2},{"value":"매개변수 데코레이터 (Parameter Decorators)","depth":2},{"value":"메타데이터 (Metadata)","depth":2}],"frontmatter":{"permalink":"/ko/docs/handbook/decorators.html","title":"Decorators","disable_toc":null,"handbook":null,"oneline":"TypeScript Decorators overview","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-decorators","slug":"/ko/docs/handbook/decorators.html","repoPath":"/packages/documentation/copy/ko/reference/Decorators.md","lang":"ko","modifiedTime":"2021-05-31T12:18:20.871Z"}},"staticQueryHashes":[]}