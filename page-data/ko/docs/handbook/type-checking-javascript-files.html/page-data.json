{"componentChunkName":"component---src-templates-documentation-tsx","path":"/ko/docs/handbook/type-checking-javascript-files.html","result":{"data":{"markdownRemark":{"id":"81bd8416-044b-5451-a739-83e61239f570","excerpt":".ts 파일과 .js 파일은 타입을 검사하는 방법에 몇 가지 주목할만한 차이점이 있습니다. 클래스 본문의 할당에서 추론된 프로퍼티 (Properties are inferred from assignments in class bodies) ES201…","html":"<p><code>.ts</code> 파일과 <code>.js</code> 파일은 타입을 검사하는 방법에 몇 가지 주목할만한 차이점이 있습니다.</p>\n<h2 id=\"클래스-본문의-할당에서-추론된-프로퍼티-properties-are-inferred-from-assignments-in-class-bodies\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B3%B8%EB%AC%B8%EC%9D%98-%ED%95%A0%EB%8B%B9%EC%97%90%EC%84%9C-%EC%B6%94%EB%A1%A0%EB%90%9C-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-properties-are-inferred-from-assignments-in-class-bodies\" aria-label=\"클래스 본문의 할당에서 추론된 프로퍼티 properties are inferred from assignments in class bodies permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스 본문의 할당에서 추론된 프로퍼티 (Properties are inferred from assignments in class bodies)</h2>\n<p>ES2015에는 클래스에 프로퍼티를 선언할 수 있는 수단이 없습니다. 프로퍼티는 객체 리터럴과 같이 동적으로 할당됩니다.</p>\n<p><code>.js</code> 파일에서, 컴파일러는 클래스 본문 내부에서 할당된 프로퍼티로부터 프로퍼티들을 추론합니다.\n생성자가 정의되어 있지 않거나, 생성자에서 정의된 타입이 <code>undefined</code>나 <code>null</code>이 아닐 경우, 프로퍼티의 타입은 생성자에서 주어진 타입과 동일합니다.\n전자에 해당 프로퍼티의 경우, 할당되었던 모든 값들의 타입을 가진 유니언 타입이 됩니다.\n생성자에 정의된 프로퍼티는 항상 존재하는 것으로 가정하는 반면, 메서드, getter, setter에서만 정의된 프로퍼티는 선택적인 것으로 간주합니다.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @errors: 2322\nclass C {\n  constructor() {\n    this.constructorOnly = 0;\n    this.constructorUnknown = undefined;\n  }\n  method() {\n    this.constructorOnly = false; // 오류, constructorOnly는 Number 타입임\n    this.constructorUnknown = \"plunkbat\"; // 성공, constructorUnknown의 타입은 string | undefined\n    this.methodOnly = \"ok\"; // 성공, 그러나 methodOnly는 undefined 타입 또한 허용됨\n  }\n  method2() {\n    this.methodOnly = true; // 이 또한 성공, methodOnly의 타입은 string | boolean | undefined\n  }\n}\n</code></pre>\n<p>프로퍼티가 클래스 본문에서 설정되지 않았다면, 알 수 없는 것으로 간주합니다.\n클래스에 읽기 전용 프로퍼티가 있는 경우, 생성자에서 선언에 JSDoc을 사용하여 타입을 추가하여 표시합니다.\n이후엔 초기화하더라도 값을 지정할 필요가 없습니다.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @errors: 2322\nclass C {\n  constructor() {\n    /** @type {number | undefined} */\n    this.prop = undefined;\n    /** @type {number | undefined} */\n    this.count;\n  }\n}\n\nlet c = new C();\nc.prop = 0; // 성공\nc.count = \"string\"; // 오류: string 은 number|undefined에 할당할 수 없음\n</code></pre>\n<h2 id=\"생성자-함수와-클래스는-동일-constructor-functions-are-equivalent-to-classes\" style=\"position:relative;\"><a href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EB%8F%99%EC%9D%BC-constructor-functions-are-equivalent-to-classes\" aria-label=\"생성자 함수와 클래스는 동일 constructor functions are equivalent to classes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>생성자 함수와 클래스는 동일 (Constructor functions are equivalent to classes)</h2>\n<p>ES2015 이전에는, JavaScript는 클래스 대신 생성자 함수를 사용했습니다.\n컴파일러는 이러한 패턴을 지원하며 생성자 함수를 ES2015 클래스와 동일한 것으로 이해합니다.\n앞서 설명한 프로퍼티 추론 규칙 또한 정확히 같은 방식으로 작용합니다.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @errors: 2683 2322\nfunction C() {\n  this.constructorOnly = 0;\n  this.constructorUnknown = undefined;\n}\nC.prototype.method = function () {\n  this.constructorOnly = false; // 오류\n  this.constructorUnknown = \"plunkbat\"; // 성공, 타입은 string | undefined가 됨\n};\n</code></pre>\n<h2 id=\"commonjs-모듈-지원-commonjs-modules-are-supported\" style=\"position:relative;\"><a href=\"#commonjs-%EB%AA%A8%EB%93%88-%EC%A7%80%EC%9B%90-commonjs-modules-are-supported\" aria-label=\"commonjs 모듈 지원 commonjs modules are supported permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CommonJS 모듈 지원 (CommonJS modules are supported)</h2>\n<p><code>.js</code> 파일에서, TypeScript는 CommonJS 모듈 포맷을 이해합니다.\n<code>exports</code>와 <code>module.exports</code> 할당은 export 선언으로 인식됩니다.\n마찬가지로, <code>require</code> 함수 호출은 모듈 import로 인식됩니다. 예를 들어:</p>\n<pre><code class=\"language-js\">// `import module \"fs\"`와 같음\nconst fs = require(\"fs\");\n\n// `export function readFile`과 같음\nmodule.exports.readFile = function(f) {\n    return fs.readFileSync(f);\n}\n</code></pre>\n<p>JavaScript의 모듈 지원은 TypeScript의 모듈 지원보다 구문적으로 훨씬 관용적입니다.\n따라서 대부분의 할당과 선언의 조합이 지원됩니다.</p>\n<h2 id=\"클래스-함수-객체-리터럴은-네임스페이스-classes-functions-and-object-literals-are-namespaces\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%9D%80-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4-classes-functions-and-object-literals-are-namespaces\" aria-label=\"클래스 함수 객체 리터럴은 네임스페이스 classes functions and object literals are namespaces permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래스, 함수, 객체 리터럴은 네임스페이스 (Classes, functions, and object literals are namespaces)</h2>\n<p><code>.js</code> 파일에 있는 클래스는 네임스페이스입니다.\n예를 들어, 다음과 같이 클래스를 중첩하는 데에 사용할 수 있습니다:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">class C {}\nC.D = class {};\n</code></pre>\n<p>그리고 ES2015 이전 코드의 경우, 정적 메서드를 나타내는 데에 사용할 수도 있습니다:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">function Outer() {\n  this.y = 2;\n}\n\nOuter.Inner = function () {\n  this.yy = 2;\n};\n\nOuter.innter();\n</code></pre>\n<p>또한 간단한 네임스페이스를 생성하는 데에 사용할 수도 있습니다:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">var ns = {};\nns.C = class {};\nns.func = function () {};\n\nns;\n</code></pre>\n<p>다른 번형도 허용됩니다:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// 즉시 호출 함수 (IIFE)\nvar ns = (function (n) {\n  return n || {};\n})();\nns.CONST = 1;\n\n// 전역으로 기본 설정\nvar assign =\n  assign ||\n  function () {\n    // 여기엔 코드를\n  };\nassign.extra = 1;\n</code></pre>\n<h2 id=\"객체-리터럴은-확장-가능-object-literals-are-open-ended\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%9D%80-%ED%99%95%EC%9E%A5-%EA%B0%80%EB%8A%A5-object-literals-are-open-ended\" aria-label=\"객체 리터럴은 확장 가능 object literals are open ended permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 리터럴은 확장 가능 (Object literals are open-ended)</h2>\n<p><code>.ts</code> 파일에서, 변수 선언을 초기화하는 객체 리터럴은 선언에 해당 타입을 부여합니다.\n원본 리터럴에 명시되어 있지 않은 새 멤버는 추가될 수 없습니다.\n이 규칙은 <code>.js</code> 파일에선 완화됩니다; 객체 리터럴은 원본에 정의되지 않은 새로운 프로퍼티를 조회하고 추가하는 것이 허용되는 확장 가능한 타입(인덱스 시그니처)을 갖습니다.\n예를 들어:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">var obj = { a: 1 };\nobj.b = 2; // 허용됨\n</code></pre>\n<p>객체 리터럴은 마치 닫힌 객체가 아니라 열린 맵(maps)으로 다뤄지도록 <code>[x:string]: any</code>와 같은 인덱스 시그니처를 가진 것처럼 동작합니다.</p>\n<p>다른 특정 JavaScript 검사 동작과 마찬가지로, 해당 동작은 변수에 JSDoc 타입을 지정하여 변경할 수 있습니다. 예를 들어:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @errors: 2339\n/** @type {{a: number}} */\nvar obj = { a: 1 };\nobj.b = 2; // 오류, {a: number}타입엔 b 프로퍼티가 없음\n</code></pre>\n<h2 id=\"null-undefined-및-빈-배열-이니셜라이저는-any-혹은-any-타입-null-undefined-and-empty-array-initializers-are-of-type-any-or-any\" style=\"position:relative;\"><a href=\"#null-undefined-%EB%B0%8F-%EB%B9%88-%EB%B0%B0%EC%97%B4-%EC%9D%B4%EB%8B%88%EC%85%9C%EB%9D%BC%EC%9D%B4%EC%A0%80%EB%8A%94-any-%ED%98%B9%EC%9D%80-any-%ED%83%80%EC%9E%85-null-undefined-and-empty-array-initializers-are-of-type-any-or-any\" aria-label=\"null undefined 및 빈 배열 이니셜라이저는 any 혹은 any 타입 null undefined and empty array initializers are of type any or any permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>null, undefined 및 빈 배열 이니셜라이저는 any 혹은 any[] 타입 (null, undefined, and empty array initializers are of type any or any[])</h2>\n<p>null 또는 undefined로 초기화된 변수나 매개변수 또는 프로퍼티는, 엄격한 null 검사가 있더라도 any 타입을 갖게 될 것입니다.\n[]로 초기화된 변수나 매개변수 또는 프로퍼티는, 엄격한 null 검사가 있더라도 any[] 타입을 갖게 될 것입니다.\n위에서 설명한 여러 이니셜라이저(initializer)를 갖는 프로퍼티만이 유일한 예외입니다.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">function Foo(i = null) {\n  if (!i) i = 1;\n  var j = undefined;\n  j = 2;\n  this.l = [];\n}\n\nvar foo = new Foo();\nfoo.l.push(foo.i);\nfoo.l.push(\"end\");\n</code></pre>\n<h2 id=\"함수-매개변수는-기본적으로-선택-사항-function-parameters-are-optional-by-default\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%8A%94-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%84%A0%ED%83%9D-%EC%82%AC%ED%95%AD-function-parameters-are-optional-by-default\" aria-label=\"함수 매개변수는 기본적으로 선택 사항 function parameters are optional by default permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 매개변수는 기본적으로 선택 사항 (Function parameters are optional by default)</h2>\n<p>ES2015 이전의 JavaScript는 선택적인 매개변수를 지정할 방법이 없었기 때문에, <code>.js</code> 파일에선 모든 함수의 매개변수는 선택적인 것으로 간주됩니다.\n선언된 매개변수보다 적은 인수로 호출하는 것이 허용됩니다.</p>\n<p>그러나 너무 많은 인수를 넣어 호출하면 오류를 일으킨다는 것에 유의하세요.</p>\n<p>예를 들어:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">// @checkJs\n// @strict: false\n// @errors: 7006 7006 2554\nfunction bar(a, b) {\n  console.log(a + \" \" + b);\n}\n\nbar(1); // 성공, 두 번째 인수는 선택 사항임\nbar(1, 2);\nbar(1, 2, 3); // 오류, 인수의 갯수가 너무 많음\n</code></pre>\n<p>JSDoc 표시가 된 함수는 이 규칙에서 예외입니다.\nJSDoc의 선택적 매개변수 구문 (<code>[</code> <code>]</code>) 을 사용하여 선택 사항을 표시할 수 있습니다. 예시:</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/**\n * @param {string} [somebody] - 누군가의 이름\n */\nfunction sayHello(somebody) {\n  if (!somebody) {\n    somebody = \"John Doe\";\n  }\n  console.log(\"Hello \" + somebody);\n}\n\nsayHello();\n</code></pre>\n<h2 id=\"arguments-사용으로부터-추론된-var-args-매개변수-선언-var-args-parameter-declaration-inferred-from-use-of-arguments\" style=\"position:relative;\"><a href=\"#arguments-%EC%82%AC%EC%9A%A9%EC%9C%BC%EB%A1%9C%EB%B6%80%ED%84%B0-%EC%B6%94%EB%A1%A0%EB%90%9C-var-args-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8-var-args-parameter-declaration-inferred-from-use-of-arguments\" aria-label=\"arguments 사용으로부터 추론된 var args 매개변수 선언 var args parameter declaration inferred from use of arguments permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>arguments</code> 사용으로부터 추론된 var-args 매개변수 선언 (Var-args parameter declaration inferred from use of <code>arguments</code>)</h2>\n<p><code>arguments</code> 참조를 참조하는 본문을 가진 함수는, 암묵적으로 var-args 매개변수(예: <code>(...arg: any[]) => any</code>)를 갖는 것으로 간주합니다. JSDoc의 var-args 구문을 사용하여 인수의 타입을 지정할 수 있습니다.</p>\n<pre><code class=\"language-js\" data-meta=\"twoslash\">/** @param {...number} args */\nfunction sum(/* numbers */) {\n  var total = 0;\n  for (var i = 0; i &#x3C; arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\n</code></pre>\n<h2 id=\"타입이-지정되지-않은-매개변수는-기본적으로-any임-unspecified-type-parameters-default-to-any\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%9D%B4-%EC%A7%80%EC%A0%95%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%8A%94-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-any%EC%9E%84-unspecified-type-parameters-default-to-any\" aria-label=\"타입이 지정되지 않은 매개변수는 기본적으로 any임 unspecified type parameters default to any permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입이 지정되지 않은 매개변수는 기본적으로 <code>any</code>임 (Unspecified type parameters default to <code>any</code>)</h2>\n<p>JavaScript에는 제네릭 타입의 매개변수를 지정하는 구문이 없으므로, 타입이 지정되지 않은 매개변수는 기본적으로 <code>any</code> 타입입니다.</p>\n<h3 id=\"확장-절에서-in-extends-clause\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5-%EC%A0%88%EC%97%90%EC%84%9C-in-extends-clause\" aria-label=\"확장 절에서 in extends clause permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장 절에서 (In extends clause)</h3>\n<p>예를 들어, <code>React.Component</code>는 <code>Props</code>와 <code>State</code>라는 두 타입의 매개변수를 갖도록 정의되어 있습니다.\n<code>.js</code> 파일에는 이러한 것들을 확장 절에 지정할 수 있는 정당한 방법이 없습니다. 기본적으로 해당 타입 인수는 <code>any</code>가 될 것입니다:</p>\n<pre><code class=\"language-js\">import { Component } from \"react\";\n\nclass MyComponent extends Component {\n    render() {\n        this.props.b; // this.props의 타입이 any이므로 허용됨\n    }\n}\n</code></pre>\n<p>타입을 명시적으로 지정하려면 JSDoc의 <code>@augments</code>를 사용하세요. 예를 들어:</p>\n<pre><code class=\"language-js\">import { Component } from \"react\";\n\n/**\n * @augments {Component&#x3C;{a: number}, State>}\n */\nclass MyComponent extends Component {\n    render() {\n        this.props.b; // 오류: b 는 {a:number}에 속하지 않음\n    }\n}\n</code></pre>\n<h3 id=\"jsdoc-참조에서-in-jsdoc-references\" style=\"position:relative;\"><a href=\"#jsdoc-%EC%B0%B8%EC%A1%B0%EC%97%90%EC%84%9C-in-jsdoc-references\" aria-label=\"jsdoc 참조에서 in jsdoc references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSDoc 참조에서 (In JSDoc references)</h3>\n<p>JSDoc의 지정되지 않은 타입 인수는 기본적으로 any입니다:</p>\n<pre><code class=\"language-js\">/** @type{Array} */\nvar x = [];\n\nx.push(1);        // 성공\nx.push(\"string\"); // 성공, x는 Array&#x3C;any> 타입임\n\n/** @type{Array.&#x3C;number>} */\nvar y = [];\n\ny.push(1);        // 성공\ny.push(\"string\"); // 오류, string을 number 타입에 할당할 수 없음\n</code></pre>\n<h3 id=\"함수-호출에서-in-function-calls\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%EC%97%90%EC%84%9C-in-function-calls\" aria-label=\"함수 호출에서 in function calls permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 호출에서 (In function calls)</h3>\n<p>제네릭 함수의 호출은 인수를 사용해 타입 매개변수를 추론합니다. 때때로 이 과정은 추론 소스가 부족하여 어떠한 타입도 추론하지 못하는 경우가 있습니다; 이러한 경우, 매개변수 타입은 기본적으로 <code>any</code>입니다. 예를 들어:</p>\n<pre><code class=\"language-js\">var p = new Promise((resolve, reject) => { reject() });\n\np; // Promise&#x3C;any>;\n</code></pre>\n<p>JSDoc의 모든 기능은 <a href=\"/docs/handbook/jsdoc-supported-types.html\">여기</a>에서 확인할 수 있습니다.</p>","headings":[{"value":"클래스 본문의 할당에서 추론된 프로퍼티 (Properties are inferred from assignments in class bodies)","depth":2},{"value":"생성자 함수와 클래스는 동일 (Constructor functions are equivalent to classes)","depth":2},{"value":"CommonJS 모듈 지원 (CommonJS modules are supported)","depth":2},{"value":"클래스, 함수, 객체 리터럴은 네임스페이스 (Classes, functions, and object literals are namespaces)","depth":2},{"value":"객체 리터럴은 확장 가능 (Object literals are open-ended)","depth":2},{"value":"null, undefined 및 빈 배열 이니셜라이저는 any 혹은 any[] 타입 (null, undefined, and empty array initializers are of type any or any[])","depth":2},{"value":"함수 매개변수는 기본적으로 선택 사항 (Function parameters are optional by default)","depth":2},{"value":"arguments 사용으로부터 추론된 var-args 매개변수 선언 (Var-args parameter declaration inferred from use of arguments)","depth":2},{"value":"타입이 지정되지 않은 매개변수는 기본적으로 any임 (Unspecified type parameters default to any)","depth":2},{"value":"확장 절에서 (In extends clause)","depth":3},{"value":"JSDoc 참조에서 (In JSDoc references)","depth":3},{"value":"함수 호출에서 (In function calls)","depth":3}],"frontmatter":{"permalink":"/ko/docs/handbook/type-checking-javascript-files.html","title":"Type Checking JavaScript Files","disable_toc":null,"handbook":null,"oneline":"How to add type checking to JavaScript files using TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"JS Projects Utilizing TypeScript","oneline":"How to add type checking to JavaScript files using TypeScript","permalink":"/ko/docs/handbook/intro-to-js-ts.html"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"JSDoc Reference","oneline":"What JSDoc does TypeScript-powered JavaScript support?","permalink":"/ko/docs/handbook/jsdoc-supported-types.html"}}}},"pageContext":{"id":"6-type-checking-javascript-files","slug":"/ko/docs/handbook/type-checking-javascript-files.html","repoPath":"/packages/documentation/copy/ko/javascript/Type Checking JavaScript Files.md","previousID":"134ddc3a-63d3-580f-b487-93d4c1ba49c5","nextID":"14789c82-cd47-508c-aac3-f304f0feef66","lang":"ko","modifiedTime":"2021-05-31T12:18:20.871Z"}},"staticQueryHashes":[]}