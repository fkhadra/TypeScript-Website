{"componentChunkName":"component---src-templates-documentation-tsx","path":"/ko/docs/handbook/enums.html","result":{"data":{"markdownRemark":{"id":"323a4381-3b97-5bfa-a8d4-e202a7b54869","excerpt":"열거형은 TypeScript가 제공하는 기능 중 하나입니다. 열거형으로 이름이 있는 상수들의 집합을 정의할 수 있습니다.\n열거형을 사용하면 의도를 문서화 하거나 구분되는 사례 집합을 더 쉽게 만들수 있습니다.\nTypeScript…","html":"<p>열거형은 TypeScript가 제공하는 기능 중 하나입니다.</p>\n<p>열거형으로 이름이 있는 상수들의 집합을 정의할 수 있습니다.\n열거형을 사용하면 의도를 문서화 하거나 구분되는 사례 집합을 더 쉽게 만들수 있습니다.\nTypeScript는 숫자와 문자열-기반 열거형을 제공합니다.</p>\n<h2 id=\"숫자-열거형-numeric-enums\" style=\"position:relative;\"><a href=\"#%EC%88%AB%EC%9E%90-%EC%97%B4%EA%B1%B0%ED%98%95-numeric-enums\" aria-label=\"숫자 열거형 numeric enums permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>숫자 열거형 (Numeric enums)</h2>\n<p>다른 언어를 배워 보신 분들이라면 친숙하게 느끼실 수 있는 숫자 열거형에 대해서 먼저 배워보겠습니다.\n열거형은 <code>enum</code> 키워드를 사용해 정의할 수 있습니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\n</code></pre>\n<p>위 코드에서 <code>Up</code>이 <code>1</code> 로 초기화된 숫자 열거형을 선언했습니다.\n그 지점부터 뒤따르는 멤버들은 자동으로-증가된 값을 갖습니다.\n즉 <code>Direction.Up</code> 은 <code>1</code>,  <code>Down</code> 은 <code>2</code>, <code>Left</code> 는 <code>3</code>, <code>Right</code> 은 <code>4</code> 을 값으로 가집니다.</p>\n<p>원한다면, 전부 초기화 하지 않을 수도 있습니다:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n</code></pre>\n<p>위 경우 <code>Up</code> 값은 <code>0</code>,  <code>Down</code> 은 <code>1</code> 이 됩니다.\n자동-증가하는 기능은 멤버 값 자체에는 신경 쓰지 않지만, 각 값이 같은 열거형의 다른 값과 구별돼야 하는 경우에 유용합니다.</p>\n<p>열거형을 사용하는 것은 간단합니다: 그냥 열거형 자체에서 프로퍼티로 모든 멤버에 접근하며, 열거형의 이름을 사용해 타입을 선언합니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum UserResponse {\n  No = 0,\n  Yes = 1,\n}\n\nfunction respond(recipient: string, message: UserResponse): void {\n  // ...\n}\n\nrespond(\"Princess Caroline\", UserResponse.Yes);\n</code></pre>\n<p>숫자 열거형은 <a href=\"#%EA%B3%84%EC%82%B0%EB%90%9C-%EB%A9%A4%EB%B2%84%EC%99%80-%EC%83%81%EC%88%98-%EB%A9%A4%EB%B2%84-computed-and-constant-members\">계산된 멤버와 상수 멤버 (아래 참조)</a>를 섞어서 사용할 수 있습니다.\n간단히 말해, 초기화되지 않은 열거형이 먼저 나오거나, 숫자 상수 혹은 다른 상수 열거형 멤버와 함께 초기화된 숫자 열거형 이후에 와야 합니다.\n즉 아래 방식은 허용되지 않습니다:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 1061\nconst getSomeValue = () => 23;\n// ---cut---\nenum E {\n  A = getSomeValue(),\n  B, // 오류! 앞에 나온 A가 계산된 멤버이므로 초기화가 필요합니다.\n}\n</code></pre>\n<h2 id=\"문자열-열거형-string-enums\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%B4%EA%B1%B0%ED%98%95-string-enums\" aria-label=\"문자열 열거형 string enums permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열 열거형 (String enums)</h2>\n<p>문자열 열거형은 유사한 개념이지만 아래 설명된 것과 같이 <a href=\"#%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90%EC%84%9C-%EC%97%B4%EA%B1%B0%ED%98%95-enums-at-runtime\">런타임에서 열거형</a>의 동작이 약간 다릅니다.\n문자열 열거형에서 각 멤버들은 문자열 리터럴 또는 다른 문자열 열거형의 멤버로 상수 초기화 해야 합니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\",\n}\n</code></pre>\n<p>문자열 열거형은 숫자 열거형처럼 자동-증가하는 기능은 없지만, “직렬화”를 잘한다는 이점이 있습니다.\n다시 말해서 만약 당신이 숫자 열거형을 이용해서 디버깅하고 있고 그 값을 읽어야 한다면, 종종 그 값이 불확실한 경우가 있습니다 - 숫자만으로는 이것이 어떤 의미인지 유의미한 정보를 제공해주지 않기 때문입니다. (<a href=\"#%EC%97%AD-%EB%A7%A4%ED%95%91-Reverse-mappings\">역 매핑</a> 을 이용하면 도움이 될지라도 말입니다), 반면 문자열 열거형을 이용하면 코드를 실행할 때, 열거형 멤버에 지정된 이름과는 무관하게 유의미하고 읽기 좋은 값을 이용하여 실행할 수 있습니다.</p>\n<h2 id=\"이종-열거형-heterogeneous-enums\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A2%85-%EC%97%B4%EA%B1%B0%ED%98%95-heterogeneous-enums\" aria-label=\"이종 열거형 heterogeneous enums permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이종 열거형 (Heterogeneous enums)</h2>\n<p>기술적으로 열거형은 숫자와 문자를 섞어서 사용할 수 있지만 굳이 그렇게 할 이유는 없습니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum BooleanLikeHeterogeneousEnum {\n  No = 0,\n  Yes = \"YES\",\n}\n</code></pre>\n<p>확실하게 JavaScript 런타임에서 장점을 취하려는 것이 아니라면, 이렇게 사용하지 않는 것을 권장합니다.</p>\n<h2 id=\"계산된-멤버와-상수-멤버-computed-and-constant-members\" style=\"position:relative;\"><a href=\"#%EA%B3%84%EC%82%B0%EB%90%9C-%EB%A9%A4%EB%B2%84%EC%99%80-%EC%83%81%EC%88%98-%EB%A9%A4%EB%B2%84-computed-and-constant-members\" aria-label=\"계산된 멤버와 상수 멤버 computed and constant members permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>계산된 멤버와 상수 멤버 (Computed and constant members)</h2>\n<p>각 열거형의 멤버는 <em>상수</em>이거나 <em>계산된</em> 값일 수 있습니다.\n열거형의 멤버는 아래의 경우 상수로 간주합니다:</p>\n<ul>\n<li>\n<p>열거형의 첫 번째 데이터이며 초기화 값이 없는 경우, 0으로 값이 할당됩니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// E.X는 상수입니다:\nenum E {\nX,\n}\n</code></pre>\n</li>\n<li>\n<p>초기화 값이 없으며 숫자 상수로 초기화된 열거형 멤버 뒤에 따라 나오는 경우.\n앞에 나온 상수 값에 1씩 증가한 값을 상수로 갖습니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// 'E1' 과 'E2' 의 모든 열거형 멤버는 상수입니다.\n\nenum E1 {\nX,\nY,\nZ,\n}\n\nenum E2 {\nA = 1,\nB,\nC,\n}\n</code></pre>\n</li>\n<li>\n<p>열거형 멤버는 상수 열거형 표현식으로 초기화됩니다.\n상수 열거형 표현식은 컴파일 시 알아낼 수 있는 TypeScript 표현식의 일부입니다.\n아래의 경우 상수 열거형 표현식이라고 합니다:</p>\n<ol>\n<li>리터럴 열거형 표현식 (기본적으로 문자 리터럴 또는 숫자 리터럴)</li>\n<li>이전에 정의된 다른 상수 열거형 멤버에 대한 참조 (다른 열거형에서 시작될 수 있음)</li>\n<li>괄호로 묶인 상수 열거형 표현식</li>\n<li>상수 열거형 표현식에 단항 연산자 <code>+</code>, <code>-</code>, <code>~</code> 를 사용한 경우</li>\n<li>상수 열거형 표현식을 이중 연산자 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&#x3C;&#x3C;</code>, <code>>></code>, <code>>>></code>, <code>&#x26;</code>, <code>|</code>, <code>^</code> 의 피연산자로 사용할 경우  </li>\n</ol>\n<p>상수 열거형 표현식 값이 <code>NaN</code> 이거나 <code>Infinity</code> 이면 컴파일 시점에 오류가 납니다.</p>\n</li>\n</ul>\n<p>이외 다른 모든 경우 열거형 멤버는 계산된 것으로 간주합니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum FileAccess {\n  // 상수 멤버\n  None,\n  Read = 1 &#x3C;&#x3C; 1,\n  Write = 1 &#x3C;&#x3C; 2,\n  ReadWrite = Read | Write,\n  // 계산된 멤버\n  G = \"123\".length,\n}\n</code></pre>\n<h2 id=\"유니언-열거형과-열거형-멤버-타입-union-enums-and-enum-member-types\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EB%8B%88%EC%96%B8-%EC%97%B4%EA%B1%B0%ED%98%95%EA%B3%BC-%EC%97%B4%EA%B1%B0%ED%98%95-%EB%A9%A4%EB%B2%84-%ED%83%80%EC%9E%85-union-enums-and-enum-member-types\" aria-label=\"유니언 열거형과 열거형 멤버 타입 union enums and enum member types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유니언 열거형과 열거형 멤버 타입 (Union enums and enum member types)</h2>\n<p>계산되지 않는 상수 열거 멤버의 특수한 부분 집합이 있습니다: 리터럴 열거형 멤버\n리터럴 열거형 멤버는 초기화 값이 존재하지 않거나, 아래 값들로 초기화되는 멤버입니다.</p>\n<ul>\n<li>문자 리터럴 (예시. <code>\"foo\"</code>, <code>\"bar</code>, <code>\"baz\"</code>)</li>\n<li>숫자 리터럴 (예시. <code>1</code>, <code>100</code>)</li>\n<li>숫자 리터럴에 단항 연산자 <code>-</code> 가 적용된 경우 (e.g. <code>-1</code>, <code>-100</code>)</li>\n</ul>\n<p>열거형의 모든 멤버가 리터럴 열거형 값을 가지면 특별한 의미로 쓰이게 됩니다.</p>\n<p>첫째로 열거형 멤버를 타입처럼 사용할 수 있습니다!\n예를 들어 특정 멤버는 <em>오직</em> 열거형 멤버의 값만 가지게 할 수 있습니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2322\nenum ShapeKind {\n  Circle,\n  Square,\n}\n\ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\n\ninterface Square {\n  kind: ShapeKind.Square;\n  sideLength: number;\n}\n\nlet c: Circle = {\n  kind: ShapeKind.Square, // 오류! 'ShapeKind.Circle' 타입에 'ShapeKind.Square' 타입을 할당할 수 없습니다.\n  radius: 100,\n};\n</code></pre>\n<p>또 다른 점은 열거형 타입 자체가 효율적으로 각각의 열거형 멤버의 <em>유니언</em>이 된다는 점입니다.\n유니언 타입 열거형을 사용하면 타입 시스템이 열거형 자체에 존재하는 정확한 값의 집합을 알고 있다는 사실을 활용할 수 있다는 점만 알아두면 됩니다.\n이 때문에 TypeScript는 값을 잘못 비교하는 어리석은 버그를 잡을 수 있습니다.\n예를 들어:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @errors: 2367\nenum E {\n  Foo,\n  Bar,\n}\n\nfunction f(x: E) {\n  if (x !== E.Foo || x !== E.Bar) {\n    //             ~~~~~~~~~~~\n    // 에러! E 타입은 Foo, Bar 둘 중 하나이기 때문에 이 조건은 항상 true를 반환합니다.\n  }\n}\n</code></pre>\n<p>이 예제에서 우리는 <code>x</code> 가 <code>E.Foo</code> 가 <em>아닌지</em> 확인합니다.\n만약 이 조건이 true 라면, <code>||</code> 조건은 더는 체크할 필요가 없으므로 if 아래의 body가 실행될 것입니다.\n그러나 만약 이 조건이 통과되지 않는다면, <code>x</code> 는 반드시 <code>E.Foo</code> 이기 때문에, x가 <code>E.Bar</code> 가 아닌지 묻는 조건과 비교하는 것은 적절하지 않습니다.</p>\n<h2 id=\"런타임에서의-열거형-enums-at-runtime\" style=\"position:relative;\"><a href=\"#%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90%EC%84%9C%EC%9D%98-%EC%97%B4%EA%B1%B0%ED%98%95-enums-at-runtime\" aria-label=\"런타임에서의 열거형 enums at runtime permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>런타임에서의 열거형 (Enums at runtime)</h2>\n<p>열거형은 런타임에 존재하는 실제 객체입니다.\n예를 들어 아래와 같은 열거형은</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum E {\n  X,\n  Y,\n  Z,\n}\n</code></pre>\n<p>실제로 아래와 같이 함수로 전달될 수 있습니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum E {\n  X,\n  Y,\n  Z,\n}\n\nfunction f(obj: { X: number }) {\n  return obj.X;\n}\n\n// E가 X라는 숫자 프로퍼티를 가지고 있기 때문에 동작하는 코드입니다.\nf(E);\n</code></pre>\n<h2 id=\"컴파일-시점에서-열거형-enums-at-compile-time\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%A0%90%EC%97%90%EC%84%9C-%EC%97%B4%EA%B1%B0%ED%98%95-enums-at-compile-time\" aria-label=\"컴파일 시점에서 열거형 enums at compile time permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴파일 시점에서 열거형 (Enums at compile time)</h2>\n<p>열거형이 런타임에 존재하는 실제 객체라고 할지라도, <code>keyof</code> 키워드는 일반적인 객체에서 기대하는 동작과 다르게 동작합니다. 대신, <code>keyof typeof</code> 를 사용하면 모든 열거형의 키를 문자열로 나타내는 타입을 가져옵니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum LogLevel {\n  ERROR,\n  WARN,\n  INFO,\n  DEBUG,\n}\n\n/**\n * 이것은 아래와 동일합니다. :\n * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';\n */\ntype LogLevelStrings = keyof typeof LogLevel;\n\nfunction printImportant(key: LogLevelStrings, message: string) {\n  const num = LogLevel[key];\n  if (num &#x3C;= LogLevel.WARN) {\n    console.log(\"Log level key is:\", key);\n    console.log(\"Log level value is:\", num);\n    console.log(\"Log level message is:\", message);\n  }\n}\nprintImportant(\"ERROR\", \"This is a message\");\n</code></pre>\n<h3 id=\"역-매핑-reverse-mappings\" style=\"position:relative;\"><a href=\"#%EC%97%AD-%EB%A7%A4%ED%95%91-reverse-mappings\" aria-label=\"역 매핑 reverse mappings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>역 매핑 (Reverse mappings)</h3>\n<p>숫자 열거형 멤버는 멤버의 프로퍼티 이름을 가진 객체를 생성하는 것 외에도 열거형 값에서 열거형 이름으로 <em>역 매핑</em> 을 받습니다.\n예를 들어 아래의 예제에서:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">enum Enum {\n  A,\n}\n\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n</code></pre>\n<p>TypeScript는 아래와 같은 JavaScript 코드로 컴파일할 겁니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @showEmit\nenum Enum {\n  A,\n}\n\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n</code></pre>\n<p>이렇게 생성된 코드에서, 열거형은 정방향 (<code>name</code> -> <code>value</code>) 매핑과 역방향 (<code>value</code> -> <code>name</code>) 매핑 두 정보를 모두 저장하는 객체로 컴파일됩니다.\n다른 열거형 멤버 참조는 항상 프로퍼티 접근으로 노출되며 인라인되지 않습니다.</p>\n<p>문자열 열거형은 역 매핑을 생성하지 <em>않는다</em> 는 것을 명심하시길 바랍니다.</p>\n<h3 id=\"const-열거형-const-enums\" style=\"position:relative;\"><a href=\"#const-%EC%97%B4%EA%B1%B0%ED%98%95-const-enums\" aria-label=\"const 열거형 const enums permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>const</code> 열거형 (<code>const</code> enums)</h3>\n<p>대부분의 경우, 열거형은 완벽하게 유효한 해결책입니다.\n하지만 종종 열거형의 요구사항이 좀 더 엄격해 집니다.\n열거형 값에 접근할 때, 추가로 생성된 코드 및 추가적인 간접 참조에 대한 비용을 피하기 위해 <code>const</code> 열거형을 사용할 수 있습니다.\nconst 열거형은 <code>const</code> 지정자를 열거형에 붙여 정의합니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">const enum Enum {\n  A = 1,\n  B = A * 2,\n}\n</code></pre>\n<p>const 열거형은 상수 열거형 표현식만 사용될 수 있으며 일반적인 열거형과 달리 컴파일 과정에서 완전히 제거됩니다.\nconst 열거형은 사용하는 공간에 인라인됩니다.\n이러한 동작은 const 열거형이 계산된 멤버를 가지고 있지 않기 때문에 가능합니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">const enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nlet directions = [\n  Direction.Up,\n  Direction.Down,\n  Direction.Left,\n  Direction.Right,\n];\n</code></pre>\n<p>위 코드는 아래와 같이 컴파일됩니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">// @showEmit\nconst enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nlet directions = [\n  Direction.Up,\n  Direction.Down,\n  Direction.Left,\n  Direction.Right,\n];\n</code></pre>\n<h2 id=\"ambient-열거형-ambient-enums\" style=\"position:relative;\"><a href=\"#ambient-%EC%97%B4%EA%B1%B0%ED%98%95-ambient-enums\" aria-label=\"ambient 열거형 ambient enums permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ambient 열거형 (Ambient enums)</h2>\n<p>Ambient 열거형은 이미 존재하는 열거형 타입의 모습을 묘사하기 위해 사용됩니다.</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">declare enum Enum {\n  A = 1,\n  B,\n  C = 2,\n}\n</code></pre>\n<p>ambient 열거형과 비-ambient 열거형의 가장 큰 차이점은, 일반적인 열거형에서 초기화되지 않은 멤버가 상수로 간주하는 멤버 뒤에 있다면, 이 멤버도 상수로 간주할 것입니다.\n반면 (const가 아닌) ambient 열거형에서 초기화되지 않은 멤버는 <em>항상</em> 계산된 멤버로 간주합니다.</p>\n<h2 id=\"objects-vs-enums\" style=\"position:relative;\"><a href=\"#objects-vs-enums\" aria-label=\"objects vs enums permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Objects vs Enums</h2>\n<p>In modern TypeScript, you may not need an enum when an object with <code>as const</code> could suffice:</p>\n<pre><code class=\"language-ts\" data-meta=\"twoslash\">const enum EDirection {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nconst ODirection = {\n  Up: 0,\n  Down: 1,\n  Left: 2,\n  Right: 3,\n} as const;\n\nEDirection.Up;\n//         ^?\n\nODirection.Up;\n//         ^?\n\n// Using the enum as a parameter\nfunction walk(dir: EDirection) {}\n\n// It requires an extra line to pull out the keys\ntype Direction = typeof ODirection[keyof typeof ODirection];\nfunction run(dir: Direction) {}\n\nwalk(EDirection.Left);\nrun(ODirection.Right);\n</code></pre>\n<p>The biggest argument in favour of this format over is that it keeps your codebase aligned with the state of JavaScript, and <a href=\"https://github.com/rbuckton/proposal-enum\">when/if</a> enums are added to JavaScript then you can move to the additional syntax.</p>","headings":[{"value":"숫자 열거형 (Numeric enums)","depth":2},{"value":"문자열 열거형 (String enums)","depth":2},{"value":"이종 열거형 (Heterogeneous enums)","depth":2},{"value":"계산된 멤버와 상수 멤버 (Computed and constant members)","depth":2},{"value":"유니언 열거형과 열거형 멤버 타입 (Union enums and enum member types)","depth":2},{"value":"런타임에서의 열거형 (Enums at runtime)","depth":2},{"value":"컴파일 시점에서 열거형 (Enums at compile time)","depth":2},{"value":"역 매핑 (Reverse mappings)","depth":3},{"value":"const 열거형 (const enums)","depth":3},{"value":"Ambient 열거형 (Ambient enums)","depth":2},{"value":"Objects vs Enums","depth":2}],"frontmatter":{"permalink":"/ko/docs/handbook/enums.html","title":"Enums","disable_toc":null,"handbook":"true","oneline":"How TypeScript enums work","preamble":null,"deprecated_by":null,"deprecation_redirects":null}},"prev":null,"next":null},"pageContext":{"id":"2-enums","slug":"/ko/docs/handbook/enums.html","repoPath":"/packages/documentation/copy/ko/reference/Enums.md","lang":"ko","modifiedTime":"2021-05-31T12:18:20.871Z"}},"staticQueryHashes":[]}